Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
Rule 2     go_to_main -> <empty>
Rule 3     empty_global_variables_table -> <empty>
Rule 4     empty_local_variables_table -> <empty>
Rule 5     fill_go_to_main_quad -> <empty>
Rule 6     add_id -> <empty>
Rule 7     save_ids -> <empty>
Rule 8     save_parameter -> <empty>
Rule 9     save_function -> <empty>
Rule 10    VARS_PRIME -> VARS VARS_PRIME
Rule 11    VARS_PRIME -> empty
Rule 12    FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 13    FUNCTION_PRIME -> empty
Rule 14    FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 15    FUNC_PRIME -> empty
Rule 16    add_type -> <empty>
Rule 17    add_current_type -> <empty>
Rule 18    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 19    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 20    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
Rule 21    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
Rule 22    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 23    TIPO_PRIME -> empty
Rule 24    get_variable -> <empty>
Rule 25    VARIABLE -> ID get_variable
Rule 26    VARIABLE -> ID [ EXPRESSION ]
Rule 27    TIPO_SIMPLE -> INT add_type
Rule 28    TIPO_SIMPLE -> FLOAT add_type
Rule 29    TIPO_SIMPLE -> CHAR add_type
Rule 30    TIPO_COMP -> DATAFRAME
Rule 31    add_function_type -> <empty>
Rule 32    save_function_as_variable -> <empty>
Rule 33    return_quad -> <empty>
Rule 34    FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
Rule 35    FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
Rule 36    add_parameters -> <empty>
Rule 37    PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
Rule 38    PARAM -> empty
Rule 39    PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
Rule 40    PARAM_PRIME -> empty
Rule 41    BLOCK -> STATEMENT BLOCK
Rule 42    BLOCK -> empty
Rule 43    STATEMENT -> ASSIGNATION
Rule 44    STATEMENT -> FUNC_CALL
Rule 45    STATEMENT -> EXPRESSION ;
Rule 46    STATEMENT -> WRITE ;
Rule 47    STATEMENT -> CONDITION
Rule 48    STATEMENT -> WHILE_STMT
Rule 49    STATEMENT -> FOR_STMT
Rule 50    STATEMENT -> DESCRIBE_STMT
Rule 51    add_operator -> <empty>
Rule 52    add_operand -> <empty>
Rule 53    add_assignation_quad -> <empty>
Rule 54    add_assignation_for_quad -> <empty>
Rule 55    functions_assignation -> <empty>
Rule 56    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 57    ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
Rule 58    ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
Rule 59    era_quad -> <empty>
Rule 60    param_quad -> <empty>
Rule 61    go_sub_quad -> <empty>
Rule 62    FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
Rule 63    FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME
Rule 64    FUNC_CALL_PRIME -> empty
Rule 65    print_quad -> <empty>
Rule 66    add_print_operator -> <empty>
Rule 67    WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
Rule 68    WRITE -> PRINT add_operator ( TITLE WRITE_PRIME )
Rule 69    WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME
Rule 70    WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME
Rule 71    WRITE_PRIME -> empty
Rule 72    go_to_false_quad -> <empty>
Rule 73    fill_go_to_false_quad -> <empty>
Rule 74    go_to_true_quad -> <empty>
Rule 75    fill_go_to_true_quad -> <empty>
Rule 76    go_to_quad -> <empty>
Rule 77    pop_operand -> <empty>
Rule 78    pop_type -> <empty>
Rule 79    append_jump -> <empty>
Rule 80    CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
Rule 81    ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
Rule 82    ELSE_STMT -> empty pop_operand
Rule 83    WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
Rule 84    check_exact_type_for -> <empty>
Rule 85    add_final_counter_for -> <empty>
Rule 86    generate_for_quad -> <empty>
Rule 87    check_boolean_expression_for -> <empty>
Rule 88    end_for -> <empty>
Rule 89    FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
Rule 90    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 91    aritmetics_operation -> <empty>
Rule 92    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 93    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 94    EXPRESSION_PRIME -> empty
Rule 95    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 96    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 97    AND_EXP_PRIME -> empty
Rule 98    B_EXP -> TRUE
Rule 99    B_EXP -> FALSE
Rule 100   B_EXP -> EXP B_EXP_PRIME
Rule 101   B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation
Rule 102   B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation
Rule 103   B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation
Rule 104   B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation
Rule 105   B_EXP_PRIME -> empty
Rule 106   EXP -> TERM EXP_PRIME
Rule 107   EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation
Rule 108   EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation
Rule 109   EXP_PRIME -> empty
Rule 110   TERM -> FACTOR TERM_PRIME
Rule 111   TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 112   TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 113   TERM_PRIME -> empty
Rule 114   FACTOR -> ( EXPRESSION )
Rule 115   FACTOR -> * VAR_CT
Rule 116   FACTOR -> / VAR_CT
Rule 117   FACTOR -> VAR_CT
Rule 118   VAR_CT -> ID add_operand
Rule 119   VAR_CT -> I_CONST add_operand
Rule 120   VAR_CT -> F_CONST add_operand
Rule 121   VAR_CT -> C_CONST add_operand
Rule 122   VAR_CT -> FUNC_CALL
Rule 123   empty -> <empty>

Terminals, with rules where they appear

(                    : 34 35 62 67 68 80 83 89 90 114
)                    : 34 35 62 67 68 80 83 89 90 114
*                    : 111 115
+                    : 107
,                    : 22 39 63 69 70
-                    : 108
.                    : 90
/                    : 112 116
;                    : 1 18 19 20 21 34 45 46 56
<                    : 102
=                    : 56 57 58
>                    : 101
AND                  : 96
CHAR                 : 29
C_CONST              : 121
DATAFRAME            : 30
DESCRIBE             : 90
DIFFERENT            : 103
DO                   : 89
ELSE                 : 81
EQUAL                : 104
FALSE                : 99
FLOAT                : 28
FOR                  : 57
FUNC                 : 34 35 62
F_CONST              : 120
ID                   : 1 18 19 20 21 22 25 26 34 35 37 39 62 90 118
IF                   : 80
INT                  : 27
I_CONST              : 119
MAIN                 : 1
OR                   : 93
PRINT                : 67 68
PROG                 : 1
RETURN               : 34
TITLE                : 68 70
TO                   : 89
TRUE                 : 98
VAR                  : 18 19 20 21
VOID                 : 1 35
WHILE                : 83
[                    : 20 21 21 26
]                    : 20 21 21 26
error                : 
{                    : 1 34 35 80 81 83 89
}                    : 1 34 35 80 81 83 89

Nonterminals, with rules where they appear

AND_EXP              : 92 93
AND_EXP_PRIME        : 95 96
ASSIGNATION          : 43 89
BLOCK                : 1 34 35 41 80 81 83 89
B_EXP                : 95 96 101 102 103 104
B_EXP_PRIME          : 100
CONDITION            : 47
DESCRIBE_STMT        : 50
ELSE_STMT            : 80
EXP                  : 100
EXPRESSION           : 20 21 21 26 34 45 56 57 62 63 67 69 80 83 89 114
EXPRESSION_PRIME     : 92 93
EXP_PRIME            : 106 107 108
FACTOR               : 110 111 112
FOR_STMT             : 49
FUNCTION             : 12 14
FUNCTION_PRIME       : 1
FUNC_CALL            : 44 58 122
FUNC_CALL_PRIME      : 62 63
FUNC_PRIME           : 12 14
PARAM                : 34 35
PARAM_PRIME          : 37 39
PROGRAM              : 0
STATEMENT            : 41
TERM                 : 106 107 108
TERM_PRIME           : 110 111 112
TIPO_COMP            : 18
TIPO_PRIME           : 18 19 22
TIPO_SIMPLE          : 19 20 21 34 37 39
VARIABLE             : 56 57 58
VARS                 : 10
VARS_PRIME           : 1 1 10 34 35
VAR_CT               : 115 116 117
WHILE_STMT           : 48
WRITE                : 46
WRITE_PRIME          : 67 68 69 70
add_assignation_for_quad : 57
add_assignation_quad : 56 58
add_current_type     : 22
add_final_counter_for : 89
add_function_type    : 34
add_id               : 1 18 19 22 34 35 37 39
add_operand          : 118 119 120 121
add_operator         : 56 57 58 67 68 101 102 103 104 107 108 111 112
add_parameters       : 34 35
add_print_operator   : 69 70
add_type             : 1 27 28 29 35
append_jump          : 83
aritmetics_operation : 101 102 103 104 107 108 111 112
check_boolean_expression_for : 89
check_exact_type_for : 89 89
empty                : 11 13 15 23 38 40 42 64 71 82 94 97 105 109 113
empty_global_variables_table : 1
empty_local_variables_table : 34 35
end_for              : 89
era_quad             : 62
fill_go_to_false_quad : 80 83
fill_go_to_main_quad : 1
fill_go_to_true_quad : 81
functions_assignation : 58
generate_for_quad    : 89
get_variable         : 25
go_sub_quad          : 62
go_to_false_quad     : 80 83
go_to_main           : 1
go_to_quad           : 83
go_to_true_quad      : 81
param_quad           : 62 63
pop_operand          : 82 83
pop_type             : 80 83
print_quad           : 67 69 70
return_quad          : 34
save_function        : 1 34 35
save_function_as_variable : 34
save_ids             : 18 19
save_parameter       : 37 39

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (6) add_id -> .

    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (2) go_to_main -> .

    VAR             reduce using rule 2 (go_to_main -> .)
    FUNC            reduce using rule 2 (go_to_main -> .)
    VOID            reduce using rule 2 (go_to_main -> .)

    go_to_main                     shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main . save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (9) save_function -> .

    VAR             reduce using rule 9 (save_function -> .)
    FUNC            reduce using rule 9 (save_function -> .)
    VOID            reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 8

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function . VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (18) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (123) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 123 (empty -> .)
    VOID            reduce using rule 123 (empty -> .)

    VARS_PRIME                     shift and go to state 9
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 9

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME . FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (12) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (13) FUNCTION_PRIME -> . empty
    (34) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (35) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (123) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 123 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 13
    FUNCTION                       shift and go to state 14
    empty                          shift and go to state 15

state 10

    (10) VARS_PRIME -> VARS . VARS_PRIME
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (18) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (123) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 123 (empty -> .)
    VOID            reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    VARS                           shift and go to state 10
    VARS_PRIME                     shift and go to state 17
    empty                          shift and go to state 11

state 11

    (11) VARS_PRIME -> empty .

    FUNC            reduce using rule 11 (VARS_PRIME -> empty .)
    VOID            reduce using rule 11 (VARS_PRIME -> empty .)
    FOR             reduce using rule 11 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 11 (VARS_PRIME -> empty .)
    IF              reduce using rule 11 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 11 (VARS_PRIME -> empty .)
    ID              reduce using rule 11 (VARS_PRIME -> empty .)
    TRUE            reduce using rule 11 (VARS_PRIME -> empty .)
    FALSE           reduce using rule 11 (VARS_PRIME -> empty .)
    (               reduce using rule 11 (VARS_PRIME -> empty .)
    *               reduce using rule 11 (VARS_PRIME -> empty .)
    /               reduce using rule 11 (VARS_PRIME -> empty .)
    I_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    F_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    C_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    }               reduce using rule 11 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 11 (VARS_PRIME -> empty .)


state 12

    (18) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (30) TIPO_COMP -> . DATAFRAME
    (27) TIPO_SIMPLE -> . INT add_type
    (28) TIPO_SIMPLE -> . FLOAT add_type
    (29) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 20
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_COMP                      shift and go to state 18
    TIPO_SIMPLE                    shift and go to state 19

state 13

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME . VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    VOID            shift and go to state 24


state 14

    (12) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (14) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (15) FUNC_PRIME -> . empty
    (34) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (35) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (123) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 123 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 26
    empty                          shift and go to state 27

state 15

    (13) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 13 (FUNCTION_PRIME -> empty .)


state 16

    (34) FUNCTION -> FUNC . TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (35) FUNCTION -> FUNC . VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (27) TIPO_SIMPLE -> . INT add_type
    (28) TIPO_SIMPLE -> . FLOAT add_type
    (29) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 29
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 28

state 17

    (10) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    TRUE            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    FALSE           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    (               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    *               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    /               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    I_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    F_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    C_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)


state 18

    (18) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 30


state 19

    (19) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] ;
    (21) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] [ EXPRESSION ] ;

    ID              shift and go to state 31


state 20

    (30) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 30 (TIPO_COMP -> DATAFRAME .)


state 21

    (27) TIPO_SIMPLE -> INT . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (28) TIPO_SIMPLE -> FLOAT . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (29) TIPO_SIMPLE -> CHAR . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 34

state 24

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID . MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    MAIN            shift and go to state 35


state 25

    (14) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (14) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (15) FUNC_PRIME -> . empty
    (34) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (35) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (123) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 123 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 36
    empty                          shift and go to state 27

state 26

    (12) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 12 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 27

    (15) FUNC_PRIME -> empty .

    VOID            reduce using rule 15 (FUNC_PRIME -> empty .)


state 28

    (34) FUNCTION -> FUNC TIPO_SIMPLE . add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (31) add_function_type -> .

    ID              reduce using rule 31 (add_function_type -> .)

    add_function_type              shift and go to state 37

state 29

    (35) FUNCTION -> FUNC VOID . add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 38

state 30

    (18) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (19) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (20) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] ;
    (21) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] [ EXPRESSION ] ;
    (6) add_id -> .

    [               shift and go to state 41
    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 40

state 32

    (27) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 27 (TIPO_SIMPLE -> INT add_type .)


state 33

    (28) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 28 (TIPO_SIMPLE -> FLOAT add_type .)


state 34

    (29) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 29 (TIPO_SIMPLE -> CHAR add_type .)


state 35

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN . { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    {               shift and go to state 42


state 36

    (14) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 14 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 37

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type . ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    ID              shift and go to state 43


state 38

    (35) FUNCTION -> FUNC VOID add_type . ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table

    ID              shift and go to state 44


state 39

    (18) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (22) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (23) TIPO_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 123 (empty -> .)

    TIPO_PRIME                     shift and go to state 45
    empty                          shift and go to state 47

state 40

    (19) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (22) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (23) TIPO_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 123 (empty -> .)

    TIPO_PRIME                     shift and go to state 48
    empty                          shift and go to state 47

state 41

    (20) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] ;
    (21) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] [ EXPRESSION ] ;
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 50
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 42

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { . fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (5) fill_go_to_main_quad -> .

    VAR             reduce using rule 5 (fill_go_to_main_quad -> .)
    FOR             reduce using rule 5 (fill_go_to_main_quad -> .)
    FUNC            reduce using rule 5 (fill_go_to_main_quad -> .)
    PRINT           reduce using rule 5 (fill_go_to_main_quad -> .)
    IF              reduce using rule 5 (fill_go_to_main_quad -> .)
    WHILE           reduce using rule 5 (fill_go_to_main_quad -> .)
    ID              reduce using rule 5 (fill_go_to_main_quad -> .)
    TRUE            reduce using rule 5 (fill_go_to_main_quad -> .)
    FALSE           reduce using rule 5 (fill_go_to_main_quad -> .)
    (               reduce using rule 5 (fill_go_to_main_quad -> .)
    *               reduce using rule 5 (fill_go_to_main_quad -> .)
    /               reduce using rule 5 (fill_go_to_main_quad -> .)
    I_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    F_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    C_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    }               reduce using rule 5 (fill_go_to_main_quad -> .)

    fill_go_to_main_quad           shift and go to state 67

state 43

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID . add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (6) add_id -> .

    (               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 68

state 44

    (35) FUNCTION -> FUNC VOID add_type ID . add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (6) add_id -> .

    (               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 69

state 45

    (18) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 70


state 46

    (22) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 71


state 47

    (23) TIPO_PRIME -> empty .

    ;               reduce using rule 23 (TIPO_PRIME -> empty .)


state 48

    (19) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 72


state 49

    (118) VAR_CT -> ID . add_operand
    (52) add_operand -> .

    *               reduce using rule 52 (add_operand -> .)
    /               reduce using rule 52 (add_operand -> .)
    +               reduce using rule 52 (add_operand -> .)
    -               reduce using rule 52 (add_operand -> .)
    >               reduce using rule 52 (add_operand -> .)
    <               reduce using rule 52 (add_operand -> .)
    DIFFERENT       reduce using rule 52 (add_operand -> .)
    EQUAL           reduce using rule 52 (add_operand -> .)
    AND             reduce using rule 52 (add_operand -> .)
    OR              reduce using rule 52 (add_operand -> .)
    ]               reduce using rule 52 (add_operand -> .)
    )               reduce using rule 52 (add_operand -> .)
    ;               reduce using rule 52 (add_operand -> .)
    ,               reduce using rule 52 (add_operand -> .)
    TO              reduce using rule 52 (add_operand -> .)
    FOR             reduce using rule 52 (add_operand -> .)
    FUNC            reduce using rule 52 (add_operand -> .)
    PRINT           reduce using rule 52 (add_operand -> .)
    IF              reduce using rule 52 (add_operand -> .)
    WHILE           reduce using rule 52 (add_operand -> .)
    ID              reduce using rule 52 (add_operand -> .)
    TRUE            reduce using rule 52 (add_operand -> .)
    FALSE           reduce using rule 52 (add_operand -> .)
    (               reduce using rule 52 (add_operand -> .)
    I_CONST         reduce using rule 52 (add_operand -> .)
    F_CONST         reduce using rule 52 (add_operand -> .)
    C_CONST         reduce using rule 52 (add_operand -> .)
    }               reduce using rule 52 (add_operand -> .)
    RETURN          reduce using rule 52 (add_operand -> .)

    add_operand                    shift and go to state 73

state 50

    (20) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] ;
    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] [ EXPRESSION ] ;

    ]               shift and go to state 74


state 51

    (92) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (93) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (94) EXPRESSION_PRIME -> . empty
    (123) empty -> .

    OR              shift and go to state 76
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 75
    empty                          shift and go to state 77

state 52

    (95) AND_EXP -> B_EXP . AND_EXP_PRIME
    (96) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (97) AND_EXP_PRIME -> . empty
    (123) empty -> .

    AND             shift and go to state 79
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 78
    empty                          shift and go to state 80

state 53

    (98) B_EXP -> TRUE .

    AND             reduce using rule 98 (B_EXP -> TRUE .)
    OR              reduce using rule 98 (B_EXP -> TRUE .)
    ]               reduce using rule 98 (B_EXP -> TRUE .)
    )               reduce using rule 98 (B_EXP -> TRUE .)
    ;               reduce using rule 98 (B_EXP -> TRUE .)
    ,               reduce using rule 98 (B_EXP -> TRUE .)
    TO              reduce using rule 98 (B_EXP -> TRUE .)
    FOR             reduce using rule 98 (B_EXP -> TRUE .)
    FUNC            reduce using rule 98 (B_EXP -> TRUE .)
    PRINT           reduce using rule 98 (B_EXP -> TRUE .)
    IF              reduce using rule 98 (B_EXP -> TRUE .)
    WHILE           reduce using rule 98 (B_EXP -> TRUE .)
    ID              reduce using rule 98 (B_EXP -> TRUE .)
    TRUE            reduce using rule 98 (B_EXP -> TRUE .)
    FALSE           reduce using rule 98 (B_EXP -> TRUE .)
    (               reduce using rule 98 (B_EXP -> TRUE .)
    *               reduce using rule 98 (B_EXP -> TRUE .)
    /               reduce using rule 98 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 98 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 98 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 98 (B_EXP -> TRUE .)
    }               reduce using rule 98 (B_EXP -> TRUE .)
    RETURN          reduce using rule 98 (B_EXP -> TRUE .)


state 54

    (99) B_EXP -> FALSE .

    AND             reduce using rule 99 (B_EXP -> FALSE .)
    OR              reduce using rule 99 (B_EXP -> FALSE .)
    ]               reduce using rule 99 (B_EXP -> FALSE .)
    )               reduce using rule 99 (B_EXP -> FALSE .)
    ;               reduce using rule 99 (B_EXP -> FALSE .)
    ,               reduce using rule 99 (B_EXP -> FALSE .)
    TO              reduce using rule 99 (B_EXP -> FALSE .)
    FOR             reduce using rule 99 (B_EXP -> FALSE .)
    FUNC            reduce using rule 99 (B_EXP -> FALSE .)
    PRINT           reduce using rule 99 (B_EXP -> FALSE .)
    IF              reduce using rule 99 (B_EXP -> FALSE .)
    WHILE           reduce using rule 99 (B_EXP -> FALSE .)
    ID              reduce using rule 99 (B_EXP -> FALSE .)
    TRUE            reduce using rule 99 (B_EXP -> FALSE .)
    FALSE           reduce using rule 99 (B_EXP -> FALSE .)
    (               reduce using rule 99 (B_EXP -> FALSE .)
    *               reduce using rule 99 (B_EXP -> FALSE .)
    /               reduce using rule 99 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 99 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 99 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 99 (B_EXP -> FALSE .)
    }               reduce using rule 99 (B_EXP -> FALSE .)
    RETURN          reduce using rule 99 (B_EXP -> FALSE .)


state 55

    (100) B_EXP -> EXP . B_EXP_PRIME
    (101) B_EXP_PRIME -> . > add_operator B_EXP aritmetics_operation
    (102) B_EXP_PRIME -> . < add_operator B_EXP aritmetics_operation
    (103) B_EXP_PRIME -> . DIFFERENT add_operator B_EXP aritmetics_operation
    (104) B_EXP_PRIME -> . EQUAL add_operator B_EXP aritmetics_operation
    (105) B_EXP_PRIME -> . empty
    (123) empty -> .

    >               shift and go to state 82
    <               shift and go to state 83
    DIFFERENT       shift and go to state 84
    EQUAL           shift and go to state 85
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    B_EXP_PRIME                    shift and go to state 81
    empty                          shift and go to state 86

state 56

    (106) EXP -> TERM . EXP_PRIME
    (107) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (108) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (109) EXP_PRIME -> . empty
    (123) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    EXP_PRIME                      shift and go to state 87
    empty                          shift and go to state 90

state 57

    (110) TERM -> FACTOR . TERM_PRIME
    (111) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (112) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (113) TERM_PRIME -> . empty
    (123) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 123 (empty -> .)
    -               reduce using rule 123 (empty -> .)
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

  ! *               [ reduce using rule 123 (empty -> .) ]
  ! /               [ reduce using rule 123 (empty -> .) ]

    TERM_PRIME                     shift and go to state 91
    empty                          shift and go to state 94

state 58

    (114) FACTOR -> ( . EXPRESSION )
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 95
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 59

    (115) FACTOR -> * . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    VAR_CT                         shift and go to state 96
    FUNC_CALL                      shift and go to state 65

state 60

    (117) FACTOR -> VAR_CT .

    *               reduce using rule 117 (FACTOR -> VAR_CT .)
    /               reduce using rule 117 (FACTOR -> VAR_CT .)
    +               reduce using rule 117 (FACTOR -> VAR_CT .)
    -               reduce using rule 117 (FACTOR -> VAR_CT .)
    >               reduce using rule 117 (FACTOR -> VAR_CT .)
    <               reduce using rule 117 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 117 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 117 (FACTOR -> VAR_CT .)
    AND             reduce using rule 117 (FACTOR -> VAR_CT .)
    OR              reduce using rule 117 (FACTOR -> VAR_CT .)
    ]               reduce using rule 117 (FACTOR -> VAR_CT .)
    )               reduce using rule 117 (FACTOR -> VAR_CT .)
    ;               reduce using rule 117 (FACTOR -> VAR_CT .)
    ,               reduce using rule 117 (FACTOR -> VAR_CT .)
    TO              reduce using rule 117 (FACTOR -> VAR_CT .)
    FOR             reduce using rule 117 (FACTOR -> VAR_CT .)
    FUNC            reduce using rule 117 (FACTOR -> VAR_CT .)
    PRINT           reduce using rule 117 (FACTOR -> VAR_CT .)
    IF              reduce using rule 117 (FACTOR -> VAR_CT .)
    WHILE           reduce using rule 117 (FACTOR -> VAR_CT .)
    ID              reduce using rule 117 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 117 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 117 (FACTOR -> VAR_CT .)
    (               reduce using rule 117 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 117 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 117 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 117 (FACTOR -> VAR_CT .)
    }               reduce using rule 117 (FACTOR -> VAR_CT .)
    RETURN          reduce using rule 117 (FACTOR -> VAR_CT .)


state 61

    (116) FACTOR -> / . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    VAR_CT                         shift and go to state 97
    FUNC_CALL                      shift and go to state 65

state 62

    (119) VAR_CT -> I_CONST . add_operand
    (52) add_operand -> .

    *               reduce using rule 52 (add_operand -> .)
    /               reduce using rule 52 (add_operand -> .)
    +               reduce using rule 52 (add_operand -> .)
    -               reduce using rule 52 (add_operand -> .)
    >               reduce using rule 52 (add_operand -> .)
    <               reduce using rule 52 (add_operand -> .)
    DIFFERENT       reduce using rule 52 (add_operand -> .)
    EQUAL           reduce using rule 52 (add_operand -> .)
    AND             reduce using rule 52 (add_operand -> .)
    OR              reduce using rule 52 (add_operand -> .)
    ]               reduce using rule 52 (add_operand -> .)
    )               reduce using rule 52 (add_operand -> .)
    ;               reduce using rule 52 (add_operand -> .)
    ,               reduce using rule 52 (add_operand -> .)
    TO              reduce using rule 52 (add_operand -> .)
    FOR             reduce using rule 52 (add_operand -> .)
    FUNC            reduce using rule 52 (add_operand -> .)
    PRINT           reduce using rule 52 (add_operand -> .)
    IF              reduce using rule 52 (add_operand -> .)
    WHILE           reduce using rule 52 (add_operand -> .)
    ID              reduce using rule 52 (add_operand -> .)
    TRUE            reduce using rule 52 (add_operand -> .)
    FALSE           reduce using rule 52 (add_operand -> .)
    (               reduce using rule 52 (add_operand -> .)
    I_CONST         reduce using rule 52 (add_operand -> .)
    F_CONST         reduce using rule 52 (add_operand -> .)
    C_CONST         reduce using rule 52 (add_operand -> .)
    }               reduce using rule 52 (add_operand -> .)
    RETURN          reduce using rule 52 (add_operand -> .)

    add_operand                    shift and go to state 98

state 63

    (120) VAR_CT -> F_CONST . add_operand
    (52) add_operand -> .

    *               reduce using rule 52 (add_operand -> .)
    /               reduce using rule 52 (add_operand -> .)
    +               reduce using rule 52 (add_operand -> .)
    -               reduce using rule 52 (add_operand -> .)
    >               reduce using rule 52 (add_operand -> .)
    <               reduce using rule 52 (add_operand -> .)
    DIFFERENT       reduce using rule 52 (add_operand -> .)
    EQUAL           reduce using rule 52 (add_operand -> .)
    AND             reduce using rule 52 (add_operand -> .)
    OR              reduce using rule 52 (add_operand -> .)
    ]               reduce using rule 52 (add_operand -> .)
    )               reduce using rule 52 (add_operand -> .)
    ;               reduce using rule 52 (add_operand -> .)
    ,               reduce using rule 52 (add_operand -> .)
    TO              reduce using rule 52 (add_operand -> .)
    FOR             reduce using rule 52 (add_operand -> .)
    FUNC            reduce using rule 52 (add_operand -> .)
    PRINT           reduce using rule 52 (add_operand -> .)
    IF              reduce using rule 52 (add_operand -> .)
    WHILE           reduce using rule 52 (add_operand -> .)
    ID              reduce using rule 52 (add_operand -> .)
    TRUE            reduce using rule 52 (add_operand -> .)
    FALSE           reduce using rule 52 (add_operand -> .)
    (               reduce using rule 52 (add_operand -> .)
    I_CONST         reduce using rule 52 (add_operand -> .)
    F_CONST         reduce using rule 52 (add_operand -> .)
    C_CONST         reduce using rule 52 (add_operand -> .)
    }               reduce using rule 52 (add_operand -> .)
    RETURN          reduce using rule 52 (add_operand -> .)

    add_operand                    shift and go to state 99

state 64

    (121) VAR_CT -> C_CONST . add_operand
    (52) add_operand -> .

    *               reduce using rule 52 (add_operand -> .)
    /               reduce using rule 52 (add_operand -> .)
    +               reduce using rule 52 (add_operand -> .)
    -               reduce using rule 52 (add_operand -> .)
    >               reduce using rule 52 (add_operand -> .)
    <               reduce using rule 52 (add_operand -> .)
    DIFFERENT       reduce using rule 52 (add_operand -> .)
    EQUAL           reduce using rule 52 (add_operand -> .)
    AND             reduce using rule 52 (add_operand -> .)
    OR              reduce using rule 52 (add_operand -> .)
    ]               reduce using rule 52 (add_operand -> .)
    )               reduce using rule 52 (add_operand -> .)
    ;               reduce using rule 52 (add_operand -> .)
    ,               reduce using rule 52 (add_operand -> .)
    TO              reduce using rule 52 (add_operand -> .)
    FOR             reduce using rule 52 (add_operand -> .)
    FUNC            reduce using rule 52 (add_operand -> .)
    PRINT           reduce using rule 52 (add_operand -> .)
    IF              reduce using rule 52 (add_operand -> .)
    WHILE           reduce using rule 52 (add_operand -> .)
    ID              reduce using rule 52 (add_operand -> .)
    TRUE            reduce using rule 52 (add_operand -> .)
    FALSE           reduce using rule 52 (add_operand -> .)
    (               reduce using rule 52 (add_operand -> .)
    I_CONST         reduce using rule 52 (add_operand -> .)
    F_CONST         reduce using rule 52 (add_operand -> .)
    C_CONST         reduce using rule 52 (add_operand -> .)
    }               reduce using rule 52 (add_operand -> .)
    RETURN          reduce using rule 52 (add_operand -> .)

    add_operand                    shift and go to state 100

state 65

    (122) VAR_CT -> FUNC_CALL .

    *               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    /               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    +               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ]               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    )               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ,               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    TO              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    FOR             reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    FUNC            reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    PRINT           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    IF              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    WHILE           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ID              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    TRUE            reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    FALSE           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    (               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    I_CONST         reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    F_CONST         reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    C_CONST         reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    }               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    RETURN          reduce using rule 122 (VAR_CT -> FUNC_CALL .)


state 66

    (62) FUNC_CALL -> FUNC . ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 101


state 67

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad . VARS_PRIME BLOCK } empty_global_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (18) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (123) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)

    VARS_PRIME                     shift and go to state 102
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 68

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id . save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (9) save_function -> .

    (               reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 103

state 69

    (35) FUNCTION -> FUNC VOID add_type ID add_id . save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (9) save_function -> .

    (               reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 104

state 70

    (18) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (7) save_ids -> .

    VAR             reduce using rule 7 (save_ids -> .)
    FUNC            reduce using rule 7 (save_ids -> .)
    VOID            reduce using rule 7 (save_ids -> .)
    FOR             reduce using rule 7 (save_ids -> .)
    PRINT           reduce using rule 7 (save_ids -> .)
    IF              reduce using rule 7 (save_ids -> .)
    WHILE           reduce using rule 7 (save_ids -> .)
    ID              reduce using rule 7 (save_ids -> .)
    TRUE            reduce using rule 7 (save_ids -> .)
    FALSE           reduce using rule 7 (save_ids -> .)
    (               reduce using rule 7 (save_ids -> .)
    *               reduce using rule 7 (save_ids -> .)
    /               reduce using rule 7 (save_ids -> .)
    I_CONST         reduce using rule 7 (save_ids -> .)
    F_CONST         reduce using rule 7 (save_ids -> .)
    C_CONST         reduce using rule 7 (save_ids -> .)
    }               reduce using rule 7 (save_ids -> .)
    RETURN          reduce using rule 7 (save_ids -> .)

    save_ids                       shift and go to state 105

state 71

    (22) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 106

state 72

    (19) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (7) save_ids -> .

    VAR             reduce using rule 7 (save_ids -> .)
    FUNC            reduce using rule 7 (save_ids -> .)
    VOID            reduce using rule 7 (save_ids -> .)
    FOR             reduce using rule 7 (save_ids -> .)
    PRINT           reduce using rule 7 (save_ids -> .)
    IF              reduce using rule 7 (save_ids -> .)
    WHILE           reduce using rule 7 (save_ids -> .)
    ID              reduce using rule 7 (save_ids -> .)
    TRUE            reduce using rule 7 (save_ids -> .)
    FALSE           reduce using rule 7 (save_ids -> .)
    (               reduce using rule 7 (save_ids -> .)
    *               reduce using rule 7 (save_ids -> .)
    /               reduce using rule 7 (save_ids -> .)
    I_CONST         reduce using rule 7 (save_ids -> .)
    F_CONST         reduce using rule 7 (save_ids -> .)
    C_CONST         reduce using rule 7 (save_ids -> .)
    }               reduce using rule 7 (save_ids -> .)
    RETURN          reduce using rule 7 (save_ids -> .)

    save_ids                       shift and go to state 107

state 73

    (118) VAR_CT -> ID add_operand .

    *               reduce using rule 118 (VAR_CT -> ID add_operand .)
    /               reduce using rule 118 (VAR_CT -> ID add_operand .)
    +               reduce using rule 118 (VAR_CT -> ID add_operand .)
    -               reduce using rule 118 (VAR_CT -> ID add_operand .)
    >               reduce using rule 118 (VAR_CT -> ID add_operand .)
    <               reduce using rule 118 (VAR_CT -> ID add_operand .)
    DIFFERENT       reduce using rule 118 (VAR_CT -> ID add_operand .)
    EQUAL           reduce using rule 118 (VAR_CT -> ID add_operand .)
    AND             reduce using rule 118 (VAR_CT -> ID add_operand .)
    OR              reduce using rule 118 (VAR_CT -> ID add_operand .)
    ]               reduce using rule 118 (VAR_CT -> ID add_operand .)
    )               reduce using rule 118 (VAR_CT -> ID add_operand .)
    ;               reduce using rule 118 (VAR_CT -> ID add_operand .)
    ,               reduce using rule 118 (VAR_CT -> ID add_operand .)
    TO              reduce using rule 118 (VAR_CT -> ID add_operand .)
    FOR             reduce using rule 118 (VAR_CT -> ID add_operand .)
    FUNC            reduce using rule 118 (VAR_CT -> ID add_operand .)
    PRINT           reduce using rule 118 (VAR_CT -> ID add_operand .)
    IF              reduce using rule 118 (VAR_CT -> ID add_operand .)
    WHILE           reduce using rule 118 (VAR_CT -> ID add_operand .)
    ID              reduce using rule 118 (VAR_CT -> ID add_operand .)
    TRUE            reduce using rule 118 (VAR_CT -> ID add_operand .)
    FALSE           reduce using rule 118 (VAR_CT -> ID add_operand .)
    (               reduce using rule 118 (VAR_CT -> ID add_operand .)
    I_CONST         reduce using rule 118 (VAR_CT -> ID add_operand .)
    F_CONST         reduce using rule 118 (VAR_CT -> ID add_operand .)
    C_CONST         reduce using rule 118 (VAR_CT -> ID add_operand .)
    }               reduce using rule 118 (VAR_CT -> ID add_operand .)
    RETURN          reduce using rule 118 (VAR_CT -> ID add_operand .)


state 74

    (20) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . ;
    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . [ EXPRESSION ] ;

    ;               shift and go to state 109
    [               shift and go to state 108


state 75

    (92) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FUNC            reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 92 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 76

    (93) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    AND_EXP                        shift and go to state 110
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 77

    (94) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    FOR             reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    FUNC            reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    PRINT           reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    IF              reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    WHILE           reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 94 (EXPRESSION_PRIME -> empty .)
    RETURN          reduce using rule 94 (EXPRESSION_PRIME -> empty .)


state 78

    (95) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FUNC            reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 95 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 79

    (96) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    B_EXP                          shift and go to state 111
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 80

    (97) AND_EXP_PRIME -> empty .

    OR              reduce using rule 97 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 97 (AND_EXP_PRIME -> empty .)
    FOR             reduce using rule 97 (AND_EXP_PRIME -> empty .)
    FUNC            reduce using rule 97 (AND_EXP_PRIME -> empty .)
    PRINT           reduce using rule 97 (AND_EXP_PRIME -> empty .)
    IF              reduce using rule 97 (AND_EXP_PRIME -> empty .)
    WHILE           reduce using rule 97 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 97 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 97 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 97 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 97 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 97 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 97 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 97 (AND_EXP_PRIME -> empty .)
    RETURN          reduce using rule 97 (AND_EXP_PRIME -> empty .)


state 81

    (100) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    FOR             reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    FUNC            reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    PRINT           reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    IF              reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    WHILE           reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)
    RETURN          reduce using rule 100 (B_EXP -> EXP B_EXP_PRIME .)


state 82

    (101) B_EXP_PRIME -> > . add_operator B_EXP aritmetics_operation
    (51) add_operator -> .

    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 112

state 83

    (102) B_EXP_PRIME -> < . add_operator B_EXP aritmetics_operation
    (51) add_operator -> .

    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 113

state 84

    (103) B_EXP_PRIME -> DIFFERENT . add_operator B_EXP aritmetics_operation
    (51) add_operator -> .

    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 114

state 85

    (104) B_EXP_PRIME -> EQUAL . add_operator B_EXP aritmetics_operation
    (51) add_operator -> .

    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 115

state 86

    (105) B_EXP_PRIME -> empty .

    AND             reduce using rule 105 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 105 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 105 (B_EXP_PRIME -> empty .)
    )               reduce using rule 105 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 105 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 105 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 105 (B_EXP_PRIME -> empty .)
    FOR             reduce using rule 105 (B_EXP_PRIME -> empty .)
    FUNC            reduce using rule 105 (B_EXP_PRIME -> empty .)
    PRINT           reduce using rule 105 (B_EXP_PRIME -> empty .)
    IF              reduce using rule 105 (B_EXP_PRIME -> empty .)
    WHILE           reduce using rule 105 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 105 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 105 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 105 (B_EXP_PRIME -> empty .)
    (               reduce using rule 105 (B_EXP_PRIME -> empty .)
    *               reduce using rule 105 (B_EXP_PRIME -> empty .)
    /               reduce using rule 105 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 105 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 105 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 105 (B_EXP_PRIME -> empty .)
    }               reduce using rule 105 (B_EXP_PRIME -> empty .)
    RETURN          reduce using rule 105 (B_EXP_PRIME -> empty .)


state 87

    (106) EXP -> TERM EXP_PRIME .

    >               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    FOR             reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    FUNC            reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    PRINT           reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    IF              reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    WHILE           reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 106 (EXP -> TERM EXP_PRIME .)
    RETURN          reduce using rule 106 (EXP -> TERM EXP_PRIME .)


state 88

    (107) EXP_PRIME -> + . add_operator TERM EXP_PRIME aritmetics_operation
    (51) add_operator -> .

    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 116

state 89

    (108) EXP_PRIME -> - . add_operator TERM EXP_PRIME aritmetics_operation
    (51) add_operator -> .

    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 117

state 90

    (109) EXP_PRIME -> empty .

    >               reduce using rule 109 (EXP_PRIME -> empty .)
    <               reduce using rule 109 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 109 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 109 (EXP_PRIME -> empty .)
    AND             reduce using rule 109 (EXP_PRIME -> empty .)
    OR              reduce using rule 109 (EXP_PRIME -> empty .)
    ]               reduce using rule 109 (EXP_PRIME -> empty .)
    )               reduce using rule 109 (EXP_PRIME -> empty .)
    ;               reduce using rule 109 (EXP_PRIME -> empty .)
    ,               reduce using rule 109 (EXP_PRIME -> empty .)
    TO              reduce using rule 109 (EXP_PRIME -> empty .)
    FOR             reduce using rule 109 (EXP_PRIME -> empty .)
    FUNC            reduce using rule 109 (EXP_PRIME -> empty .)
    PRINT           reduce using rule 109 (EXP_PRIME -> empty .)
    IF              reduce using rule 109 (EXP_PRIME -> empty .)
    WHILE           reduce using rule 109 (EXP_PRIME -> empty .)
    ID              reduce using rule 109 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 109 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 109 (EXP_PRIME -> empty .)
    (               reduce using rule 109 (EXP_PRIME -> empty .)
    *               reduce using rule 109 (EXP_PRIME -> empty .)
    /               reduce using rule 109 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 109 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 109 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 109 (EXP_PRIME -> empty .)
    }               reduce using rule 109 (EXP_PRIME -> empty .)
    RETURN          reduce using rule 109 (EXP_PRIME -> empty .)


state 91

    (110) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    FOR             reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    FUNC            reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    PRINT           reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    IF              reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    WHILE           reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)
    RETURN          reduce using rule 110 (TERM -> FACTOR TERM_PRIME .)


state 92

    (111) TERM_PRIME -> * . add_operator FACTOR aritmetics_operation TERM_PRIME
    (51) add_operator -> .

    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 118

state 93

    (112) TERM_PRIME -> / . add_operator FACTOR aritmetics_operation TERM_PRIME
    (51) add_operator -> .

    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 119

state 94

    (113) TERM_PRIME -> empty .

    +               reduce using rule 113 (TERM_PRIME -> empty .)
    -               reduce using rule 113 (TERM_PRIME -> empty .)
    >               reduce using rule 113 (TERM_PRIME -> empty .)
    <               reduce using rule 113 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 113 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 113 (TERM_PRIME -> empty .)
    AND             reduce using rule 113 (TERM_PRIME -> empty .)
    OR              reduce using rule 113 (TERM_PRIME -> empty .)
    ]               reduce using rule 113 (TERM_PRIME -> empty .)
    )               reduce using rule 113 (TERM_PRIME -> empty .)
    ;               reduce using rule 113 (TERM_PRIME -> empty .)
    ,               reduce using rule 113 (TERM_PRIME -> empty .)
    TO              reduce using rule 113 (TERM_PRIME -> empty .)
    FOR             reduce using rule 113 (TERM_PRIME -> empty .)
    FUNC            reduce using rule 113 (TERM_PRIME -> empty .)
    PRINT           reduce using rule 113 (TERM_PRIME -> empty .)
    IF              reduce using rule 113 (TERM_PRIME -> empty .)
    WHILE           reduce using rule 113 (TERM_PRIME -> empty .)
    ID              reduce using rule 113 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 113 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 113 (TERM_PRIME -> empty .)
    (               reduce using rule 113 (TERM_PRIME -> empty .)
    *               reduce using rule 113 (TERM_PRIME -> empty .)
    /               reduce using rule 113 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 113 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 113 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 113 (TERM_PRIME -> empty .)
    }               reduce using rule 113 (TERM_PRIME -> empty .)
    RETURN          reduce using rule 113 (TERM_PRIME -> empty .)


state 95

    (114) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 120


state 96

    (115) FACTOR -> * VAR_CT .

    *               reduce using rule 115 (FACTOR -> * VAR_CT .)
    /               reduce using rule 115 (FACTOR -> * VAR_CT .)
    +               reduce using rule 115 (FACTOR -> * VAR_CT .)
    -               reduce using rule 115 (FACTOR -> * VAR_CT .)
    >               reduce using rule 115 (FACTOR -> * VAR_CT .)
    <               reduce using rule 115 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 115 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 115 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 115 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 115 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 115 (FACTOR -> * VAR_CT .)
    )               reduce using rule 115 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 115 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 115 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 115 (FACTOR -> * VAR_CT .)
    FOR             reduce using rule 115 (FACTOR -> * VAR_CT .)
    FUNC            reduce using rule 115 (FACTOR -> * VAR_CT .)
    PRINT           reduce using rule 115 (FACTOR -> * VAR_CT .)
    IF              reduce using rule 115 (FACTOR -> * VAR_CT .)
    WHILE           reduce using rule 115 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 115 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 115 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 115 (FACTOR -> * VAR_CT .)
    (               reduce using rule 115 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 115 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 115 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 115 (FACTOR -> * VAR_CT .)
    }               reduce using rule 115 (FACTOR -> * VAR_CT .)
    RETURN          reduce using rule 115 (FACTOR -> * VAR_CT .)


state 97

    (116) FACTOR -> / VAR_CT .

    *               reduce using rule 116 (FACTOR -> / VAR_CT .)
    /               reduce using rule 116 (FACTOR -> / VAR_CT .)
    +               reduce using rule 116 (FACTOR -> / VAR_CT .)
    -               reduce using rule 116 (FACTOR -> / VAR_CT .)
    >               reduce using rule 116 (FACTOR -> / VAR_CT .)
    <               reduce using rule 116 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 116 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 116 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 116 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 116 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 116 (FACTOR -> / VAR_CT .)
    )               reduce using rule 116 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 116 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 116 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 116 (FACTOR -> / VAR_CT .)
    FOR             reduce using rule 116 (FACTOR -> / VAR_CT .)
    FUNC            reduce using rule 116 (FACTOR -> / VAR_CT .)
    PRINT           reduce using rule 116 (FACTOR -> / VAR_CT .)
    IF              reduce using rule 116 (FACTOR -> / VAR_CT .)
    WHILE           reduce using rule 116 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 116 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 116 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 116 (FACTOR -> / VAR_CT .)
    (               reduce using rule 116 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 116 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 116 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 116 (FACTOR -> / VAR_CT .)
    }               reduce using rule 116 (FACTOR -> / VAR_CT .)
    RETURN          reduce using rule 116 (FACTOR -> / VAR_CT .)


state 98

    (119) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    FOR             reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    FUNC            reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    PRINT           reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    IF              reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    WHILE           reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 119 (VAR_CT -> I_CONST add_operand .)
    RETURN          reduce using rule 119 (VAR_CT -> I_CONST add_operand .)


state 99

    (120) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    FOR             reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    FUNC            reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    PRINT           reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    IF              reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    WHILE           reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 120 (VAR_CT -> F_CONST add_operand .)
    RETURN          reduce using rule 120 (VAR_CT -> F_CONST add_operand .)


state 100

    (121) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    FOR             reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    FUNC            reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    PRINT           reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    IF              reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    WHILE           reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 121 (VAR_CT -> C_CONST add_operand .)
    RETURN          reduce using rule 121 (VAR_CT -> C_CONST add_operand .)


state 101

    (62) FUNC_CALL -> FUNC ID . era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (59) era_quad -> .

    (               reduce using rule 59 (era_quad -> .)

    era_quad                       shift and go to state 121

state 102

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME . BLOCK } empty_global_variables_table
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 123
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    EXPRESSION                     shift and go to state 128
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 103

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function . ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    (               shift and go to state 139


state 104

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function . ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table

    (               shift and go to state 140


state 105

    (18) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 18 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 106

    (22) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (17) add_current_type -> .

    ,               reduce using rule 17 (add_current_type -> .)
    ;               reduce using rule 17 (add_current_type -> .)

    add_current_type               shift and go to state 141

state 107

    (19) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 19 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 108

    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ . EXPRESSION ] ;
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 142
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 109

    (20) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .

    VAR             reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FUNC            reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    VOID            reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FOR             reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    PRINT           reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    IF              reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    WHILE           reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    ID              reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    TRUE            reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FALSE           reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    (               reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    *               reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    /               reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    }               reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    RETURN          reduce using rule 20 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)


state 110

    (93) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (93) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (94) EXPRESSION_PRIME -> . empty
    (123) empty -> .

    OR              shift and go to state 76
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 143
    empty                          shift and go to state 77

state 111

    (96) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (96) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (97) AND_EXP_PRIME -> . empty
    (123) empty -> .

    AND             shift and go to state 79
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 144
    empty                          shift and go to state 80

state 112

    (101) B_EXP_PRIME -> > add_operator . B_EXP aritmetics_operation
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    B_EXP                          shift and go to state 145
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 113

    (102) B_EXP_PRIME -> < add_operator . B_EXP aritmetics_operation
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    B_EXP                          shift and go to state 146
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 114

    (103) B_EXP_PRIME -> DIFFERENT add_operator . B_EXP aritmetics_operation
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    B_EXP                          shift and go to state 147
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 115

    (104) B_EXP_PRIME -> EQUAL add_operator . B_EXP aritmetics_operation
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    B_EXP                          shift and go to state 148
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 116

    (107) EXP_PRIME -> + add_operator . TERM EXP_PRIME aritmetics_operation
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    TERM                           shift and go to state 149
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 117

    (108) EXP_PRIME -> - add_operator . TERM EXP_PRIME aritmetics_operation
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    TERM                           shift and go to state 150
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 118

    (111) TERM_PRIME -> * add_operator . FACTOR aritmetics_operation TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    FACTOR                         shift and go to state 151
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 119

    (112) TERM_PRIME -> / add_operator . FACTOR aritmetics_operation TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    FACTOR                         shift and go to state 152
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 120

    (114) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    FOR             reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    FUNC            reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    PRINT           reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    IF              reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    WHILE           reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)
    RETURN          reduce using rule 114 (FACTOR -> ( EXPRESSION ) .)


state 121

    (62) FUNC_CALL -> FUNC ID era_quad . ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 153


state 122

    (90) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (25) VARIABLE -> ID . get_variable
    (26) VARIABLE -> ID . [ EXPRESSION ]
    (118) VAR_CT -> ID . add_operand
    (24) get_variable -> .
    (52) add_operand -> .

    .               shift and go to state 154
    [               shift and go to state 156
    =               reduce using rule 24 (get_variable -> .)
    *               reduce using rule 52 (add_operand -> .)
    /               reduce using rule 52 (add_operand -> .)
    +               reduce using rule 52 (add_operand -> .)
    -               reduce using rule 52 (add_operand -> .)
    >               reduce using rule 52 (add_operand -> .)
    <               reduce using rule 52 (add_operand -> .)
    DIFFERENT       reduce using rule 52 (add_operand -> .)
    EQUAL           reduce using rule 52 (add_operand -> .)
    AND             reduce using rule 52 (add_operand -> .)
    OR              reduce using rule 52 (add_operand -> .)
    ;               reduce using rule 52 (add_operand -> .)

    get_variable                   shift and go to state 155
    add_operand                    shift and go to state 73

state 123

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK . } empty_global_variables_table

    }               shift and go to state 157


state 124

    (41) BLOCK -> STATEMENT . BLOCK
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    STATEMENT                      shift and go to state 124
    BLOCK                          shift and go to state 158
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    EXPRESSION                     shift and go to state 128
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 125

    (42) BLOCK -> empty .

    }               reduce using rule 42 (BLOCK -> empty .)
    RETURN          reduce using rule 42 (BLOCK -> empty .)


state 126

    (43) STATEMENT -> ASSIGNATION .
    (89) FOR_STMT -> ASSIGNATION . check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (84) check_exact_type_for -> .

    FOR             reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    FUNC            reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    ID              reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    TRUE            reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    FALSE           reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    (               reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    *               reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    /               reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    I_CONST         reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    F_CONST         reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    C_CONST         reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 43 (STATEMENT -> ASSIGNATION .)
    TO              reduce using rule 84 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 159

state 127

    (44) STATEMENT -> FUNC_CALL .
    (122) VAR_CT -> FUNC_CALL .

  ! reduce/reduce conflict for * resolved using rule 44 (STATEMENT -> FUNC_CALL .)
  ! reduce/reduce conflict for / resolved using rule 44 (STATEMENT -> FUNC_CALL .)
    FOR             reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    FUNC            reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    ID              reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    TRUE            reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    FALSE           reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    (               reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    *               reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    /               reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    I_CONST         reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    F_CONST         reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    C_CONST         reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 44 (STATEMENT -> FUNC_CALL .)
    +               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 122 (VAR_CT -> FUNC_CALL .)

  ! *               [ reduce using rule 122 (VAR_CT -> FUNC_CALL .) ]
  ! /               [ reduce using rule 122 (VAR_CT -> FUNC_CALL .) ]


state 128

    (45) STATEMENT -> EXPRESSION . ;

    ;               shift and go to state 160


state 129

    (46) STATEMENT -> WRITE . ;

    ;               shift and go to state 161


state 130

    (47) STATEMENT -> CONDITION .

    FOR             reduce using rule 47 (STATEMENT -> CONDITION .)
    FUNC            reduce using rule 47 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 47 (STATEMENT -> CONDITION .)
    IF              reduce using rule 47 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 47 (STATEMENT -> CONDITION .)
    ID              reduce using rule 47 (STATEMENT -> CONDITION .)
    TRUE            reduce using rule 47 (STATEMENT -> CONDITION .)
    FALSE           reduce using rule 47 (STATEMENT -> CONDITION .)
    (               reduce using rule 47 (STATEMENT -> CONDITION .)
    *               reduce using rule 47 (STATEMENT -> CONDITION .)
    /               reduce using rule 47 (STATEMENT -> CONDITION .)
    I_CONST         reduce using rule 47 (STATEMENT -> CONDITION .)
    F_CONST         reduce using rule 47 (STATEMENT -> CONDITION .)
    C_CONST         reduce using rule 47 (STATEMENT -> CONDITION .)
    }               reduce using rule 47 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 47 (STATEMENT -> CONDITION .)


state 131

    (48) STATEMENT -> WHILE_STMT .

    FOR             reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    FUNC            reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    ID              reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    TRUE            reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    FALSE           reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    (               reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    *               reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    /               reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    I_CONST         reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    F_CONST         reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    C_CONST         reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 48 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 48 (STATEMENT -> WHILE_STMT .)


state 132

    (49) STATEMENT -> FOR_STMT .

    FOR             reduce using rule 49 (STATEMENT -> FOR_STMT .)
    FUNC            reduce using rule 49 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 49 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 49 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 49 (STATEMENT -> FOR_STMT .)
    ID              reduce using rule 49 (STATEMENT -> FOR_STMT .)
    TRUE            reduce using rule 49 (STATEMENT -> FOR_STMT .)
    FALSE           reduce using rule 49 (STATEMENT -> FOR_STMT .)
    (               reduce using rule 49 (STATEMENT -> FOR_STMT .)
    *               reduce using rule 49 (STATEMENT -> FOR_STMT .)
    /               reduce using rule 49 (STATEMENT -> FOR_STMT .)
    I_CONST         reduce using rule 49 (STATEMENT -> FOR_STMT .)
    F_CONST         reduce using rule 49 (STATEMENT -> FOR_STMT .)
    C_CONST         reduce using rule 49 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 49 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 49 (STATEMENT -> FOR_STMT .)


state 133

    (50) STATEMENT -> DESCRIBE_STMT .

    FOR             reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    FUNC            reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    ID              reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    TRUE            reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    FALSE           reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    (               reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    *               reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    /               reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    I_CONST         reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    F_CONST         reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    C_CONST         reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 50 (STATEMENT -> DESCRIBE_STMT .)


state 134

    (56) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad
    (58) ASSIGNATION -> VARIABLE . = add_operator FUNC_CALL functions_assignation add_assignation_quad

    =               shift and go to state 162


state 135

    (57) ASSIGNATION -> FOR . VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]

    ID              shift and go to state 164

    VARIABLE                       shift and go to state 163

state 136

    (67) WRITE -> PRINT . add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> PRINT . add_operator ( TITLE WRITE_PRIME )
    (51) add_operator -> .

    (               reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 165

state 137

    (80) CONDITION -> IF . ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    (               shift and go to state 166


state 138

    (83) WHILE_STMT -> WHILE . ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    (               shift and go to state 167


state 139

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( . PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (37) PARAM -> . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (38) PARAM -> . empty
    (27) TIPO_SIMPLE -> . INT add_type
    (28) TIPO_SIMPLE -> . FLOAT add_type
    (29) TIPO_SIMPLE -> . CHAR add_type
    (123) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 123 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 168
    PARAM                          shift and go to state 169
    empty                          shift and go to state 170

state 140

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( . PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (37) PARAM -> . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (38) PARAM -> . empty
    (27) TIPO_SIMPLE -> . INT add_type
    (28) TIPO_SIMPLE -> . FLOAT add_type
    (29) TIPO_SIMPLE -> . CHAR add_type
    (123) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 123 (empty -> .)

    PARAM                          shift and go to state 171
    TIPO_SIMPLE                    shift and go to state 168
    empty                          shift and go to state 170

state 141

    (22) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (22) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (23) TIPO_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 123 (empty -> .)

    TIPO_PRIME                     shift and go to state 172
    empty                          shift and go to state 47

state 142

    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION . ] ;

    ]               shift and go to state 173


state 143

    (93) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FUNC            reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 93 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 144

    (96) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FUNC            reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 96 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 145

    (101) B_EXP_PRIME -> > add_operator B_EXP . aritmetics_operation
    (91) aritmetics_operation -> .

    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 174

state 146

    (102) B_EXP_PRIME -> < add_operator B_EXP . aritmetics_operation
    (91) aritmetics_operation -> .

    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 175

state 147

    (103) B_EXP_PRIME -> DIFFERENT add_operator B_EXP . aritmetics_operation
    (91) aritmetics_operation -> .

    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 176

state 148

    (104) B_EXP_PRIME -> EQUAL add_operator B_EXP . aritmetics_operation
    (91) aritmetics_operation -> .

    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 177

state 149

    (107) EXP_PRIME -> + add_operator TERM . EXP_PRIME aritmetics_operation
    (107) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (108) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (109) EXP_PRIME -> . empty
    (123) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    EXP_PRIME                      shift and go to state 178
    empty                          shift and go to state 90

state 150

    (108) EXP_PRIME -> - add_operator TERM . EXP_PRIME aritmetics_operation
    (107) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (108) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (109) EXP_PRIME -> . empty
    (123) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    EXP_PRIME                      shift and go to state 179
    empty                          shift and go to state 90

state 151

    (111) TERM_PRIME -> * add_operator FACTOR . aritmetics_operation TERM_PRIME
    (91) aritmetics_operation -> .

    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    +               reduce using rule 91 (aritmetics_operation -> .)
    -               reduce using rule 91 (aritmetics_operation -> .)
    >               reduce using rule 91 (aritmetics_operation -> .)
    <               reduce using rule 91 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 91 (aritmetics_operation -> .)
    EQUAL           reduce using rule 91 (aritmetics_operation -> .)
    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 180

state 152

    (112) TERM_PRIME -> / add_operator FACTOR . aritmetics_operation TERM_PRIME
    (91) aritmetics_operation -> .

    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    +               reduce using rule 91 (aritmetics_operation -> .)
    -               reduce using rule 91 (aritmetics_operation -> .)
    >               reduce using rule 91 (aritmetics_operation -> .)
    <               reduce using rule 91 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 91 (aritmetics_operation -> .)
    EQUAL           reduce using rule 91 (aritmetics_operation -> .)
    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 181

state 153

    (62) FUNC_CALL -> FUNC ID era_quad ( . EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 182
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 154

    (90) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 183


state 155

    (25) VARIABLE -> ID get_variable .

    =               reduce using rule 25 (VARIABLE -> ID get_variable .)


state 156

    (26) VARIABLE -> ID [ . EXPRESSION ]
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 184
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 157

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } . empty_global_variables_table
    (3) empty_global_variables_table -> .

    $end            reduce using rule 3 (empty_global_variables_table -> .)

    empty_global_variables_table   shift and go to state 185

state 158

    (41) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 41 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 41 (BLOCK -> STATEMENT BLOCK .)


state 159

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for . TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    TO              shift and go to state 186


state 160

    (45) STATEMENT -> EXPRESSION ; .

    FOR             reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    FUNC            reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    PRINT           reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    IF              reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    WHILE           reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    ID              reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    TRUE            reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    FALSE           reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    (               reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    *               reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    /               reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    I_CONST         reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    F_CONST         reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    C_CONST         reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    }               reduce using rule 45 (STATEMENT -> EXPRESSION ; .)
    RETURN          reduce using rule 45 (STATEMENT -> EXPRESSION ; .)


state 161

    (46) STATEMENT -> WRITE ; .

    FOR             reduce using rule 46 (STATEMENT -> WRITE ; .)
    FUNC            reduce using rule 46 (STATEMENT -> WRITE ; .)
    PRINT           reduce using rule 46 (STATEMENT -> WRITE ; .)
    IF              reduce using rule 46 (STATEMENT -> WRITE ; .)
    WHILE           reduce using rule 46 (STATEMENT -> WRITE ; .)
    ID              reduce using rule 46 (STATEMENT -> WRITE ; .)
    TRUE            reduce using rule 46 (STATEMENT -> WRITE ; .)
    FALSE           reduce using rule 46 (STATEMENT -> WRITE ; .)
    (               reduce using rule 46 (STATEMENT -> WRITE ; .)
    *               reduce using rule 46 (STATEMENT -> WRITE ; .)
    /               reduce using rule 46 (STATEMENT -> WRITE ; .)
    I_CONST         reduce using rule 46 (STATEMENT -> WRITE ; .)
    F_CONST         reduce using rule 46 (STATEMENT -> WRITE ; .)
    C_CONST         reduce using rule 46 (STATEMENT -> WRITE ; .)
    }               reduce using rule 46 (STATEMENT -> WRITE ; .)
    RETURN          reduce using rule 46 (STATEMENT -> WRITE ; .)


state 162

    (56) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (58) ASSIGNATION -> VARIABLE = . add_operator FUNC_CALL functions_assignation add_assignation_quad
    (51) add_operator -> .

    FUNC            reduce using rule 51 (add_operator -> .)
    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 187

state 163

    (57) ASSIGNATION -> FOR VARIABLE . = add_operator EXPRESSION add_assignation_for_quad

    =               shift and go to state 188


state 164

    (25) VARIABLE -> ID . get_variable
    (26) VARIABLE -> ID . [ EXPRESSION ]
    (24) get_variable -> .

    [               shift and go to state 156
    =               reduce using rule 24 (get_variable -> .)

    get_variable                   shift and go to state 155

state 165

    (67) WRITE -> PRINT add_operator . ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> PRINT add_operator . ( TITLE WRITE_PRIME )

    (               shift and go to state 189


state 166

    (80) CONDITION -> IF ( . EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 190
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 167

    (83) WHILE_STMT -> WHILE ( . append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (79) append_jump -> .

    TRUE            reduce using rule 79 (append_jump -> .)
    FALSE           reduce using rule 79 (append_jump -> .)
    (               reduce using rule 79 (append_jump -> .)
    *               reduce using rule 79 (append_jump -> .)
    /               reduce using rule 79 (append_jump -> .)
    ID              reduce using rule 79 (append_jump -> .)
    I_CONST         reduce using rule 79 (append_jump -> .)
    F_CONST         reduce using rule 79 (append_jump -> .)
    C_CONST         reduce using rule 79 (append_jump -> .)
    FUNC            reduce using rule 79 (append_jump -> .)

    append_jump                    shift and go to state 191

state 168

    (37) PARAM -> TIPO_SIMPLE . ID add_id save_parameter PARAM_PRIME

    ID              shift and go to state 192


state 169

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM . add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (36) add_parameters -> .

    )               reduce using rule 36 (add_parameters -> .)

    add_parameters                 shift and go to state 193

state 170

    (38) PARAM -> empty .

    )               reduce using rule 38 (PARAM -> empty .)


state 171

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM . add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (36) add_parameters -> .

    )               reduce using rule 36 (add_parameters -> .)

    add_parameters                 shift and go to state 194

state 172

    (22) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 22 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 173

    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] . ;

    ;               shift and go to state 195


state 174

    (101) B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 101 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)


state 175

    (102) B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 102 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)


state 176

    (103) B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 103 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)


state 177

    (104) B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 104 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)


state 178

    (107) EXP_PRIME -> + add_operator TERM EXP_PRIME . aritmetics_operation
    (91) aritmetics_operation -> .

    >               reduce using rule 91 (aritmetics_operation -> .)
    <               reduce using rule 91 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 91 (aritmetics_operation -> .)
    EQUAL           reduce using rule 91 (aritmetics_operation -> .)
    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 196

state 179

    (108) EXP_PRIME -> - add_operator TERM EXP_PRIME . aritmetics_operation
    (91) aritmetics_operation -> .

    >               reduce using rule 91 (aritmetics_operation -> .)
    <               reduce using rule 91 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 91 (aritmetics_operation -> .)
    EQUAL           reduce using rule 91 (aritmetics_operation -> .)
    AND             reduce using rule 91 (aritmetics_operation -> .)
    OR              reduce using rule 91 (aritmetics_operation -> .)
    ]               reduce using rule 91 (aritmetics_operation -> .)
    )               reduce using rule 91 (aritmetics_operation -> .)
    ;               reduce using rule 91 (aritmetics_operation -> .)
    ,               reduce using rule 91 (aritmetics_operation -> .)
    TO              reduce using rule 91 (aritmetics_operation -> .)
    FOR             reduce using rule 91 (aritmetics_operation -> .)
    FUNC            reduce using rule 91 (aritmetics_operation -> .)
    PRINT           reduce using rule 91 (aritmetics_operation -> .)
    IF              reduce using rule 91 (aritmetics_operation -> .)
    WHILE           reduce using rule 91 (aritmetics_operation -> .)
    ID              reduce using rule 91 (aritmetics_operation -> .)
    TRUE            reduce using rule 91 (aritmetics_operation -> .)
    FALSE           reduce using rule 91 (aritmetics_operation -> .)
    (               reduce using rule 91 (aritmetics_operation -> .)
    *               reduce using rule 91 (aritmetics_operation -> .)
    /               reduce using rule 91 (aritmetics_operation -> .)
    I_CONST         reduce using rule 91 (aritmetics_operation -> .)
    F_CONST         reduce using rule 91 (aritmetics_operation -> .)
    C_CONST         reduce using rule 91 (aritmetics_operation -> .)
    }               reduce using rule 91 (aritmetics_operation -> .)
    RETURN          reduce using rule 91 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 197

state 180

    (111) TERM_PRIME -> * add_operator FACTOR aritmetics_operation . TERM_PRIME
    (111) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (112) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (113) TERM_PRIME -> . empty
    (123) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 123 (empty -> .)
    -               reduce using rule 123 (empty -> .)
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

  ! *               [ reduce using rule 123 (empty -> .) ]
  ! /               [ reduce using rule 123 (empty -> .) ]

    TERM_PRIME                     shift and go to state 198
    empty                          shift and go to state 94

state 181

    (112) TERM_PRIME -> / add_operator FACTOR aritmetics_operation . TERM_PRIME
    (111) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (112) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (113) TERM_PRIME -> . empty
    (123) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 123 (empty -> .)
    -               reduce using rule 123 (empty -> .)
    >               reduce using rule 123 (empty -> .)
    <               reduce using rule 123 (empty -> .)
    DIFFERENT       reduce using rule 123 (empty -> .)
    EQUAL           reduce using rule 123 (empty -> .)
    AND             reduce using rule 123 (empty -> .)
    OR              reduce using rule 123 (empty -> .)
    ]               reduce using rule 123 (empty -> .)
    )               reduce using rule 123 (empty -> .)
    ;               reduce using rule 123 (empty -> .)
    ,               reduce using rule 123 (empty -> .)
    TO              reduce using rule 123 (empty -> .)
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

  ! *               [ reduce using rule 123 (empty -> .) ]
  ! /               [ reduce using rule 123 (empty -> .) ]

    TERM_PRIME                     shift and go to state 199
    empty                          shift and go to state 94

state 182

    (62) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION . param_quad FUNC_CALL_PRIME ) go_sub_quad
    (60) param_quad -> .

    ,               reduce using rule 60 (param_quad -> .)
    )               reduce using rule 60 (param_quad -> .)

    param_quad                     shift and go to state 200

state 183

    (90) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 201


state 184

    (26) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 202


state 185

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table .)


state 186

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO . ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    (               shift and go to state 203


state 187

    (56) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (58) ASSIGNATION -> VARIABLE = add_operator . FUNC_CALL functions_assignation add_assignation_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    FUNC            shift and go to state 66
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 204
    FUNC_CALL                      shift and go to state 205
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 188

    (57) ASSIGNATION -> FOR VARIABLE = . add_operator EXPRESSION add_assignation_for_quad
    (51) add_operator -> .

    TRUE            reduce using rule 51 (add_operator -> .)
    FALSE           reduce using rule 51 (add_operator -> .)
    (               reduce using rule 51 (add_operator -> .)
    *               reduce using rule 51 (add_operator -> .)
    /               reduce using rule 51 (add_operator -> .)
    ID              reduce using rule 51 (add_operator -> .)
    I_CONST         reduce using rule 51 (add_operator -> .)
    F_CONST         reduce using rule 51 (add_operator -> .)
    C_CONST         reduce using rule 51 (add_operator -> .)
    FUNC            reduce using rule 51 (add_operator -> .)

    add_operator                   shift and go to state 206

state 189

    (67) WRITE -> PRINT add_operator ( . EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> PRINT add_operator ( . TITLE WRITE_PRIME )
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TITLE           shift and go to state 208
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 207
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 190

    (80) CONDITION -> IF ( EXPRESSION . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (78) pop_type -> .

    )               reduce using rule 78 (pop_type -> .)

    pop_type                       shift and go to state 209

state 191

    (83) WHILE_STMT -> WHILE ( append_jump . EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 210
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 192

    (37) PARAM -> TIPO_SIMPLE ID . add_id save_parameter PARAM_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    )               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 211

state 193

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters . ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    )               shift and go to state 212


state 194

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters . ) { VARS_PRIME BLOCK } empty_local_variables_table

    )               shift and go to state 213


state 195

    (21) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .

    VAR             reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FUNC            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    VOID            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FOR             reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    PRINT           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    IF              reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    WHILE           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    ID              reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    TRUE            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FALSE           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    (               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    *               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    /               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    }               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    RETURN          reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)


state 196

    (107) EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FUNC            reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 107 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)


state 197

    (108) EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FUNC            reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 108 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)


state 198

    (111) TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FUNC            reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 111 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 199

    (112) TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FUNC            reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 112 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 200

    (62) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad . FUNC_CALL_PRIME ) go_sub_quad
    (63) FUNC_CALL_PRIME -> . , EXPRESSION param_quad FUNC_CALL_PRIME
    (64) FUNC_CALL_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 215
    )               reduce using rule 123 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 214
    empty                          shift and go to state 216

state 201

    (90) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 217


state 202

    (26) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 26 (VARIABLE -> ID [ EXPRESSION ] .)


state 203

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( . EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 218
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 204

    (56) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 219


state 205

    (58) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL . functions_assignation add_assignation_quad
    (122) VAR_CT -> FUNC_CALL .
    (55) functions_assignation -> .

  ! reduce/reduce conflict for * resolved using rule 55 (functions_assignation -> .)
  ! reduce/reduce conflict for / resolved using rule 55 (functions_assignation -> .)
    +               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 122 (VAR_CT -> FUNC_CALL .)
    TO              reduce using rule 55 (functions_assignation -> .)
    FOR             reduce using rule 55 (functions_assignation -> .)
    FUNC            reduce using rule 55 (functions_assignation -> .)
    PRINT           reduce using rule 55 (functions_assignation -> .)
    IF              reduce using rule 55 (functions_assignation -> .)
    WHILE           reduce using rule 55 (functions_assignation -> .)
    ID              reduce using rule 55 (functions_assignation -> .)
    TRUE            reduce using rule 55 (functions_assignation -> .)
    FALSE           reduce using rule 55 (functions_assignation -> .)
    (               reduce using rule 55 (functions_assignation -> .)
    *               reduce using rule 55 (functions_assignation -> .)
    /               reduce using rule 55 (functions_assignation -> .)
    I_CONST         reduce using rule 55 (functions_assignation -> .)
    F_CONST         reduce using rule 55 (functions_assignation -> .)
    C_CONST         reduce using rule 55 (functions_assignation -> .)
    }               reduce using rule 55 (functions_assignation -> .)
    RETURN          reduce using rule 55 (functions_assignation -> .)

  ! *               [ reduce using rule 122 (VAR_CT -> FUNC_CALL .) ]
  ! /               [ reduce using rule 122 (VAR_CT -> FUNC_CALL .) ]

    functions_assignation          shift and go to state 220

state 206

    (57) ASSIGNATION -> FOR VARIABLE = add_operator . EXPRESSION add_assignation_for_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 221
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 207

    (67) WRITE -> PRINT add_operator ( EXPRESSION . print_quad WRITE_PRIME )
    (65) print_quad -> .

    ,               reduce using rule 65 (print_quad -> .)
    )               reduce using rule 65 (print_quad -> .)

    print_quad                     shift and go to state 222

state 208

    (68) WRITE -> PRINT add_operator ( TITLE . WRITE_PRIME )
    (69) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (71) WRITE_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 224
    )               reduce using rule 123 (empty -> .)

    WRITE_PRIME                    shift and go to state 223
    empty                          shift and go to state 225

state 209

    (80) CONDITION -> IF ( EXPRESSION pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    )               shift and go to state 226


state 210

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (78) pop_type -> .

    )               reduce using rule 78 (pop_type -> .)

    pop_type                       shift and go to state 227

state 211

    (37) PARAM -> TIPO_SIMPLE ID add_id . save_parameter PARAM_PRIME
    (8) save_parameter -> .

    ,               reduce using rule 8 (save_parameter -> .)
    )               reduce using rule 8 (save_parameter -> .)

    save_parameter                 shift and go to state 228

state 212

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) . save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (32) save_function_as_variable -> .

    {               reduce using rule 32 (save_function_as_variable -> .)

    save_function_as_variable      shift and go to state 229

state 213

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) . { VARS_PRIME BLOCK } empty_local_variables_table

    {               shift and go to state 230


state 214

    (62) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME . ) go_sub_quad

    )               shift and go to state 231


state 215

    (63) FUNC_CALL_PRIME -> , . EXPRESSION param_quad FUNC_CALL_PRIME
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 232
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 216

    (64) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 64 (FUNC_CALL_PRIME -> empty .)


state 217

    (90) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    FOR             reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FUNC            reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    ID              reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    TRUE            reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FALSE           reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    (               reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    *               reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    /               reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    I_CONST         reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    F_CONST         reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    C_CONST         reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 90 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 218

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION . check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (84) check_exact_type_for -> .

    )               reduce using rule 84 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 233

state 219

    (56) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (53) add_assignation_quad -> .

    TO              reduce using rule 53 (add_assignation_quad -> .)
    FOR             reduce using rule 53 (add_assignation_quad -> .)
    FUNC            reduce using rule 53 (add_assignation_quad -> .)
    PRINT           reduce using rule 53 (add_assignation_quad -> .)
    IF              reduce using rule 53 (add_assignation_quad -> .)
    WHILE           reduce using rule 53 (add_assignation_quad -> .)
    ID              reduce using rule 53 (add_assignation_quad -> .)
    TRUE            reduce using rule 53 (add_assignation_quad -> .)
    FALSE           reduce using rule 53 (add_assignation_quad -> .)
    (               reduce using rule 53 (add_assignation_quad -> .)
    *               reduce using rule 53 (add_assignation_quad -> .)
    /               reduce using rule 53 (add_assignation_quad -> .)
    I_CONST         reduce using rule 53 (add_assignation_quad -> .)
    F_CONST         reduce using rule 53 (add_assignation_quad -> .)
    C_CONST         reduce using rule 53 (add_assignation_quad -> .)
    }               reduce using rule 53 (add_assignation_quad -> .)
    RETURN          reduce using rule 53 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 234

state 220

    (58) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation . add_assignation_quad
    (53) add_assignation_quad -> .

    TO              reduce using rule 53 (add_assignation_quad -> .)
    FOR             reduce using rule 53 (add_assignation_quad -> .)
    FUNC            reduce using rule 53 (add_assignation_quad -> .)
    PRINT           reduce using rule 53 (add_assignation_quad -> .)
    IF              reduce using rule 53 (add_assignation_quad -> .)
    WHILE           reduce using rule 53 (add_assignation_quad -> .)
    ID              reduce using rule 53 (add_assignation_quad -> .)
    TRUE            reduce using rule 53 (add_assignation_quad -> .)
    FALSE           reduce using rule 53 (add_assignation_quad -> .)
    (               reduce using rule 53 (add_assignation_quad -> .)
    *               reduce using rule 53 (add_assignation_quad -> .)
    /               reduce using rule 53 (add_assignation_quad -> .)
    I_CONST         reduce using rule 53 (add_assignation_quad -> .)
    F_CONST         reduce using rule 53 (add_assignation_quad -> .)
    C_CONST         reduce using rule 53 (add_assignation_quad -> .)
    }               reduce using rule 53 (add_assignation_quad -> .)
    RETURN          reduce using rule 53 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 235

state 221

    (57) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION . add_assignation_for_quad
    (54) add_assignation_for_quad -> .

    TO              reduce using rule 54 (add_assignation_for_quad -> .)
    FOR             reduce using rule 54 (add_assignation_for_quad -> .)
    FUNC            reduce using rule 54 (add_assignation_for_quad -> .)
    PRINT           reduce using rule 54 (add_assignation_for_quad -> .)
    IF              reduce using rule 54 (add_assignation_for_quad -> .)
    WHILE           reduce using rule 54 (add_assignation_for_quad -> .)
    ID              reduce using rule 54 (add_assignation_for_quad -> .)
    TRUE            reduce using rule 54 (add_assignation_for_quad -> .)
    FALSE           reduce using rule 54 (add_assignation_for_quad -> .)
    (               reduce using rule 54 (add_assignation_for_quad -> .)
    *               reduce using rule 54 (add_assignation_for_quad -> .)
    /               reduce using rule 54 (add_assignation_for_quad -> .)
    I_CONST         reduce using rule 54 (add_assignation_for_quad -> .)
    F_CONST         reduce using rule 54 (add_assignation_for_quad -> .)
    C_CONST         reduce using rule 54 (add_assignation_for_quad -> .)
    }               reduce using rule 54 (add_assignation_for_quad -> .)
    RETURN          reduce using rule 54 (add_assignation_for_quad -> .)

    add_assignation_for_quad       shift and go to state 236

state 222

    (67) WRITE -> PRINT add_operator ( EXPRESSION print_quad . WRITE_PRIME )
    (69) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (71) WRITE_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 224
    )               reduce using rule 123 (empty -> .)

    WRITE_PRIME                    shift and go to state 237
    empty                          shift and go to state 225

state 223

    (68) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME . )

    )               shift and go to state 238


state 224

    (69) WRITE_PRIME -> , . add_print_operator EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> , . add_print_operator TITLE print_quad WRITE_PRIME
    (66) add_print_operator -> .

    TITLE           reduce using rule 66 (add_print_operator -> .)
    TRUE            reduce using rule 66 (add_print_operator -> .)
    FALSE           reduce using rule 66 (add_print_operator -> .)
    (               reduce using rule 66 (add_print_operator -> .)
    *               reduce using rule 66 (add_print_operator -> .)
    /               reduce using rule 66 (add_print_operator -> .)
    ID              reduce using rule 66 (add_print_operator -> .)
    I_CONST         reduce using rule 66 (add_print_operator -> .)
    F_CONST         reduce using rule 66 (add_print_operator -> .)
    C_CONST         reduce using rule 66 (add_print_operator -> .)
    FUNC            reduce using rule 66 (add_print_operator -> .)

    add_print_operator             shift and go to state 239

state 225

    (71) WRITE_PRIME -> empty .

    )               reduce using rule 71 (WRITE_PRIME -> empty .)


state 226

    (80) CONDITION -> IF ( EXPRESSION pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    {               shift and go to state 240


state 227

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    )               shift and go to state 241


state 228

    (37) PARAM -> TIPO_SIMPLE ID add_id save_parameter . PARAM_PRIME
    (39) PARAM_PRIME -> . , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (40) PARAM_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 243
    )               reduce using rule 123 (empty -> .)

    PARAM_PRIME                    shift and go to state 242
    empty                          shift and go to state 244

state 229

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable . { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    {               shift and go to state 245


state 230

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { . VARS_PRIME BLOCK } empty_local_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (18) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (123) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)

    VARS_PRIME                     shift and go to state 246
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 231

    (62) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) . go_sub_quad
    (61) go_sub_quad -> .

    *               reduce using rule 61 (go_sub_quad -> .)
    /               reduce using rule 61 (go_sub_quad -> .)
    +               reduce using rule 61 (go_sub_quad -> .)
    -               reduce using rule 61 (go_sub_quad -> .)
    >               reduce using rule 61 (go_sub_quad -> .)
    <               reduce using rule 61 (go_sub_quad -> .)
    DIFFERENT       reduce using rule 61 (go_sub_quad -> .)
    EQUAL           reduce using rule 61 (go_sub_quad -> .)
    AND             reduce using rule 61 (go_sub_quad -> .)
    OR              reduce using rule 61 (go_sub_quad -> .)
    ]               reduce using rule 61 (go_sub_quad -> .)
    )               reduce using rule 61 (go_sub_quad -> .)
    ;               reduce using rule 61 (go_sub_quad -> .)
    ,               reduce using rule 61 (go_sub_quad -> .)
    TO              reduce using rule 61 (go_sub_quad -> .)
    FOR             reduce using rule 61 (go_sub_quad -> .)
    FUNC            reduce using rule 61 (go_sub_quad -> .)
    PRINT           reduce using rule 61 (go_sub_quad -> .)
    IF              reduce using rule 61 (go_sub_quad -> .)
    WHILE           reduce using rule 61 (go_sub_quad -> .)
    ID              reduce using rule 61 (go_sub_quad -> .)
    TRUE            reduce using rule 61 (go_sub_quad -> .)
    FALSE           reduce using rule 61 (go_sub_quad -> .)
    (               reduce using rule 61 (go_sub_quad -> .)
    I_CONST         reduce using rule 61 (go_sub_quad -> .)
    F_CONST         reduce using rule 61 (go_sub_quad -> .)
    C_CONST         reduce using rule 61 (go_sub_quad -> .)
    }               reduce using rule 61 (go_sub_quad -> .)
    RETURN          reduce using rule 61 (go_sub_quad -> .)

    go_sub_quad                    shift and go to state 247

state 232

    (63) FUNC_CALL_PRIME -> , EXPRESSION . param_quad FUNC_CALL_PRIME
    (60) param_quad -> .

    ,               reduce using rule 60 (param_quad -> .)
    )               reduce using rule 60 (param_quad -> .)

    param_quad                     shift and go to state 248

state 233

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for . add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (85) add_final_counter_for -> .

    )               reduce using rule 85 (add_final_counter_for -> .)

    add_final_counter_for          shift and go to state 249

state 234

    (56) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    TO              reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FUNC            reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    ID              reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    TRUE            reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FALSE           reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    (               reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    *               reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    /               reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    I_CONST         reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    F_CONST         reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    C_CONST         reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 56 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 235

    (58) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .

    TO              reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FOR             reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FUNC            reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    PRINT           reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    IF              reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    WHILE           reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    ID              reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    TRUE            reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FALSE           reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    (               reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    *               reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    /               reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    I_CONST         reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    F_CONST         reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    C_CONST         reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    }               reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    RETURN          reduce using rule 58 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)


state 236

    (57) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .

    TO              reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FOR             reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FUNC            reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    PRINT           reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    IF              reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    WHILE           reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    ID              reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    TRUE            reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FALSE           reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    (               reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    *               reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    /               reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    I_CONST         reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    F_CONST         reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    C_CONST         reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    }               reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    RETURN          reduce using rule 57 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)


state 237

    (67) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME . )

    )               shift and go to state 250


state 238

    (68) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .

    ;               reduce using rule 68 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)


state 239

    (69) WRITE_PRIME -> , add_print_operator . EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> , add_print_operator . TITLE print_quad WRITE_PRIME
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TITLE           shift and go to state 252
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 251
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 240

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) go_to_false_quad -> .

    FOR             reduce using rule 72 (go_to_false_quad -> .)
    FUNC            reduce using rule 72 (go_to_false_quad -> .)
    PRINT           reduce using rule 72 (go_to_false_quad -> .)
    IF              reduce using rule 72 (go_to_false_quad -> .)
    WHILE           reduce using rule 72 (go_to_false_quad -> .)
    ID              reduce using rule 72 (go_to_false_quad -> .)
    TRUE            reduce using rule 72 (go_to_false_quad -> .)
    FALSE           reduce using rule 72 (go_to_false_quad -> .)
    (               reduce using rule 72 (go_to_false_quad -> .)
    *               reduce using rule 72 (go_to_false_quad -> .)
    /               reduce using rule 72 (go_to_false_quad -> .)
    I_CONST         reduce using rule 72 (go_to_false_quad -> .)
    F_CONST         reduce using rule 72 (go_to_false_quad -> .)
    C_CONST         reduce using rule 72 (go_to_false_quad -> .)
    }               reduce using rule 72 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 253

state 241

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    {               shift and go to state 254


state 242

    (37) PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .

    )               reduce using rule 37 (PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .)


state 243

    (39) PARAM_PRIME -> , . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (27) TIPO_SIMPLE -> . INT add_type
    (28) TIPO_SIMPLE -> . FLOAT add_type
    (29) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 255

state 244

    (40) PARAM_PRIME -> empty .

    )               reduce using rule 40 (PARAM_PRIME -> empty .)


state 245

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { . VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (18) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (19) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (20) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (21) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (123) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    VARS_PRIME                     shift and go to state 256
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 246

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME . BLOCK } empty_local_variables_table
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 257
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    EXPRESSION                     shift and go to state 128
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 247

    (62) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .

    *               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    /               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    +               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    -               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    >               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    <               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    DIFFERENT       reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    EQUAL           reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    AND             reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    OR              reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ]               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    )               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ;               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ,               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    TO              reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FOR             reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FUNC            reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    PRINT           reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    IF              reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    WHILE           reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ID              reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    TRUE            reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FALSE           reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    (               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    I_CONST         reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    F_CONST         reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    C_CONST         reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    }               reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    RETURN          reduce using rule 62 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)


state 248

    (63) FUNC_CALL_PRIME -> , EXPRESSION param_quad . FUNC_CALL_PRIME
    (63) FUNC_CALL_PRIME -> . , EXPRESSION param_quad FUNC_CALL_PRIME
    (64) FUNC_CALL_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 215
    )               reduce using rule 123 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 258
    empty                          shift and go to state 216

state 249

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for . check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (87) check_boolean_expression_for -> .

    )               reduce using rule 87 (check_boolean_expression_for -> .)

    check_boolean_expression_for   shift and go to state 259

state 250

    (67) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .

    ;               reduce using rule 67 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)


state 251

    (69) WRITE_PRIME -> , add_print_operator EXPRESSION . print_quad WRITE_PRIME
    (65) print_quad -> .

    ,               reduce using rule 65 (print_quad -> .)
    )               reduce using rule 65 (print_quad -> .)

    print_quad                     shift and go to state 260

state 252

    (70) WRITE_PRIME -> , add_print_operator TITLE . print_quad WRITE_PRIME
    (65) print_quad -> .

    ,               reduce using rule 65 (print_quad -> .)
    )               reduce using rule 65 (print_quad -> .)

    print_quad                     shift and go to state 261

state 253

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad ELSE_STMT
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 128
    BLOCK                          shift and go to state 262
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 254

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (72) go_to_false_quad -> .

    FOR             reduce using rule 72 (go_to_false_quad -> .)
    FUNC            reduce using rule 72 (go_to_false_quad -> .)
    PRINT           reduce using rule 72 (go_to_false_quad -> .)
    IF              reduce using rule 72 (go_to_false_quad -> .)
    WHILE           reduce using rule 72 (go_to_false_quad -> .)
    ID              reduce using rule 72 (go_to_false_quad -> .)
    TRUE            reduce using rule 72 (go_to_false_quad -> .)
    FALSE           reduce using rule 72 (go_to_false_quad -> .)
    (               reduce using rule 72 (go_to_false_quad -> .)
    *               reduce using rule 72 (go_to_false_quad -> .)
    /               reduce using rule 72 (go_to_false_quad -> .)
    I_CONST         reduce using rule 72 (go_to_false_quad -> .)
    F_CONST         reduce using rule 72 (go_to_false_quad -> .)
    C_CONST         reduce using rule 72 (go_to_false_quad -> .)
    }               reduce using rule 72 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 263

state 255

    (39) PARAM_PRIME -> , TIPO_SIMPLE . ID add_id save_parameter PARAM_PRIME

    ID              shift and go to state 264


state 256

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME . BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    RETURN          reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 265
    EXPRESSION                     shift and go to state 128
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 257

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK . } empty_local_variables_table

    }               shift and go to state 266


state 258

    (63) FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME .

    )               reduce using rule 63 (FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME .)


state 259

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for . ) generate_for_quad DO { BLOCK } end_for

    )               shift and go to state 267


state 260

    (69) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad . WRITE_PRIME
    (69) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (71) WRITE_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 224
    )               reduce using rule 123 (empty -> .)

    WRITE_PRIME                    shift and go to state 268
    empty                          shift and go to state 225

state 261

    (70) WRITE_PRIME -> , add_print_operator TITLE print_quad . WRITE_PRIME
    (69) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (70) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (71) WRITE_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 224
    )               reduce using rule 123 (empty -> .)

    WRITE_PRIME                    shift and go to state 269
    empty                          shift and go to state 225

state 262

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad ELSE_STMT

    }               shift and go to state 270


state 263

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 128
    BLOCK                          shift and go to state 271
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 264

    (39) PARAM_PRIME -> , TIPO_SIMPLE ID . add_id save_parameter PARAM_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    )               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 272

state 265

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK . RETURN EXPRESSION ; return_quad } empty_local_variables_table

    RETURN          shift and go to state 273


state 266

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } . empty_local_variables_table
    (4) empty_local_variables_table -> .

    FUNC            reduce using rule 4 (empty_local_variables_table -> .)
    VOID            reduce using rule 4 (empty_local_variables_table -> .)

    empty_local_variables_table    shift and go to state 274

state 267

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) . generate_for_quad DO { BLOCK } end_for
    (86) generate_for_quad -> .

    DO              reduce using rule 86 (generate_for_quad -> .)

    generate_for_quad              shift and go to state 275

state 268

    (69) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .

    )               reduce using rule 69 (WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .)


state 269

    (70) WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .

    )               reduce using rule 70 (WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .)


state 270

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad ELSE_STMT
    (73) fill_go_to_false_quad -> .

    ELSE            reduce using rule 73 (fill_go_to_false_quad -> .)
    FOR             reduce using rule 73 (fill_go_to_false_quad -> .)
    FUNC            reduce using rule 73 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 73 (fill_go_to_false_quad -> .)
    IF              reduce using rule 73 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 73 (fill_go_to_false_quad -> .)
    ID              reduce using rule 73 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 73 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 73 (fill_go_to_false_quad -> .)
    (               reduce using rule 73 (fill_go_to_false_quad -> .)
    *               reduce using rule 73 (fill_go_to_false_quad -> .)
    /               reduce using rule 73 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    }               reduce using rule 73 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 73 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 276

state 271

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad go_to_quad pop_operand

    }               shift and go to state 277


state 272

    (39) PARAM_PRIME -> , TIPO_SIMPLE ID add_id . save_parameter PARAM_PRIME
    (8) save_parameter -> .

    ,               reduce using rule 8 (save_parameter -> .)
    )               reduce using rule 8 (save_parameter -> .)

    save_parameter                 shift and go to state 278

state 273

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN . EXPRESSION ; return_quad } empty_local_variables_table
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    FUNC            shift and go to state 66

    EXPRESSION                     shift and go to state 279
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60
    FUNC_CALL                      shift and go to state 65

state 274

    (35) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .

    FUNC            reduce using rule 35 (FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .)
    VOID            reduce using rule 35 (FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .)


state 275

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad . DO { BLOCK } end_for

    DO              shift and go to state 280


state 276

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad . ELSE_STMT
    (81) ELSE_STMT -> . ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
    (82) ELSE_STMT -> . empty pop_operand
    (123) empty -> .

    ELSE            shift and go to state 282
    FOR             reduce using rule 123 (empty -> .)
    FUNC            reduce using rule 123 (empty -> .)
    PRINT           reduce using rule 123 (empty -> .)
    IF              reduce using rule 123 (empty -> .)
    WHILE           reduce using rule 123 (empty -> .)
    ID              reduce using rule 123 (empty -> .)
    TRUE            reduce using rule 123 (empty -> .)
    FALSE           reduce using rule 123 (empty -> .)
    (               reduce using rule 123 (empty -> .)
    *               reduce using rule 123 (empty -> .)
    /               reduce using rule 123 (empty -> .)
    I_CONST         reduce using rule 123 (empty -> .)
    F_CONST         reduce using rule 123 (empty -> .)
    C_CONST         reduce using rule 123 (empty -> .)
    }               reduce using rule 123 (empty -> .)
    RETURN          reduce using rule 123 (empty -> .)

    ELSE_STMT                      shift and go to state 281
    empty                          shift and go to state 283

state 277

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad go_to_quad pop_operand
    (73) fill_go_to_false_quad -> .

    FOR             reduce using rule 73 (fill_go_to_false_quad -> .)
    FUNC            reduce using rule 73 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 73 (fill_go_to_false_quad -> .)
    IF              reduce using rule 73 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 73 (fill_go_to_false_quad -> .)
    ID              reduce using rule 73 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 73 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 73 (fill_go_to_false_quad -> .)
    (               reduce using rule 73 (fill_go_to_false_quad -> .)
    *               reduce using rule 73 (fill_go_to_false_quad -> .)
    /               reduce using rule 73 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 73 (fill_go_to_false_quad -> .)
    }               reduce using rule 73 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 73 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 284

state 278

    (39) PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter . PARAM_PRIME
    (39) PARAM_PRIME -> . , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (40) PARAM_PRIME -> . empty
    (123) empty -> .

    ,               shift and go to state 243
    )               reduce using rule 123 (empty -> .)

    PARAM_PRIME                    shift and go to state 285
    empty                          shift and go to state 244

state 279

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION . ; return_quad } empty_local_variables_table

    ;               shift and go to state 286


state 280

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO . { BLOCK } end_for

    {               shift and go to state 287


state 281

    (80) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .

    FOR             reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    FUNC            reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    PRINT           reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    IF              reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    WHILE           reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    ID              reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    TRUE            reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    FALSE           reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    (               reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    *               reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    /               reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    I_CONST         reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    F_CONST         reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    C_CONST         reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    }               reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    RETURN          reduce using rule 80 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)


state 282

    (81) ELSE_STMT -> ELSE . { go_to_true_quad BLOCK } fill_go_to_true_quad

    {               shift and go to state 288


state 283

    (82) ELSE_STMT -> empty . pop_operand
    (77) pop_operand -> .

    FOR             reduce using rule 77 (pop_operand -> .)
    FUNC            reduce using rule 77 (pop_operand -> .)
    PRINT           reduce using rule 77 (pop_operand -> .)
    IF              reduce using rule 77 (pop_operand -> .)
    WHILE           reduce using rule 77 (pop_operand -> .)
    ID              reduce using rule 77 (pop_operand -> .)
    TRUE            reduce using rule 77 (pop_operand -> .)
    FALSE           reduce using rule 77 (pop_operand -> .)
    (               reduce using rule 77 (pop_operand -> .)
    *               reduce using rule 77 (pop_operand -> .)
    /               reduce using rule 77 (pop_operand -> .)
    I_CONST         reduce using rule 77 (pop_operand -> .)
    F_CONST         reduce using rule 77 (pop_operand -> .)
    C_CONST         reduce using rule 77 (pop_operand -> .)
    }               reduce using rule 77 (pop_operand -> .)
    RETURN          reduce using rule 77 (pop_operand -> .)

    pop_operand                    shift and go to state 289

state 284

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad . go_to_quad pop_operand
    (76) go_to_quad -> .

    FOR             reduce using rule 76 (go_to_quad -> .)
    FUNC            reduce using rule 76 (go_to_quad -> .)
    PRINT           reduce using rule 76 (go_to_quad -> .)
    IF              reduce using rule 76 (go_to_quad -> .)
    WHILE           reduce using rule 76 (go_to_quad -> .)
    ID              reduce using rule 76 (go_to_quad -> .)
    TRUE            reduce using rule 76 (go_to_quad -> .)
    FALSE           reduce using rule 76 (go_to_quad -> .)
    (               reduce using rule 76 (go_to_quad -> .)
    *               reduce using rule 76 (go_to_quad -> .)
    /               reduce using rule 76 (go_to_quad -> .)
    I_CONST         reduce using rule 76 (go_to_quad -> .)
    F_CONST         reduce using rule 76 (go_to_quad -> .)
    C_CONST         reduce using rule 76 (go_to_quad -> .)
    }               reduce using rule 76 (go_to_quad -> .)
    RETURN          reduce using rule 76 (go_to_quad -> .)

    go_to_quad                     shift and go to state 290

state 285

    (39) PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .

    )               reduce using rule 39 (PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .)


state 286

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; . return_quad } empty_local_variables_table
    (33) return_quad -> .

    }               reduce using rule 33 (return_quad -> .)

    return_quad                    shift and go to state 291

state 287

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { . BLOCK } end_for
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    ASSIGNATION                    shift and go to state 126
    EXPRESSION                     shift and go to state 128
    BLOCK                          shift and go to state 292
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    FUNC_CALL                      shift and go to state 127
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 288

    (81) ELSE_STMT -> ELSE { . go_to_true_quad BLOCK } fill_go_to_true_quad
    (74) go_to_true_quad -> .

    FOR             reduce using rule 74 (go_to_true_quad -> .)
    FUNC            reduce using rule 74 (go_to_true_quad -> .)
    PRINT           reduce using rule 74 (go_to_true_quad -> .)
    IF              reduce using rule 74 (go_to_true_quad -> .)
    WHILE           reduce using rule 74 (go_to_true_quad -> .)
    ID              reduce using rule 74 (go_to_true_quad -> .)
    TRUE            reduce using rule 74 (go_to_true_quad -> .)
    FALSE           reduce using rule 74 (go_to_true_quad -> .)
    (               reduce using rule 74 (go_to_true_quad -> .)
    *               reduce using rule 74 (go_to_true_quad -> .)
    /               reduce using rule 74 (go_to_true_quad -> .)
    I_CONST         reduce using rule 74 (go_to_true_quad -> .)
    F_CONST         reduce using rule 74 (go_to_true_quad -> .)
    C_CONST         reduce using rule 74 (go_to_true_quad -> .)
    }               reduce using rule 74 (go_to_true_quad -> .)

    go_to_true_quad                shift and go to state 293

state 289

    (82) ELSE_STMT -> empty pop_operand .

    FOR             reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    FUNC            reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    PRINT           reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    IF              reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    WHILE           reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    ID              reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    TRUE            reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    FALSE           reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    (               reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    *               reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    /               reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    I_CONST         reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    F_CONST         reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    C_CONST         reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    }               reduce using rule 82 (ELSE_STMT -> empty pop_operand .)
    RETURN          reduce using rule 82 (ELSE_STMT -> empty pop_operand .)


state 290

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad . pop_operand
    (77) pop_operand -> .

    FOR             reduce using rule 77 (pop_operand -> .)
    FUNC            reduce using rule 77 (pop_operand -> .)
    PRINT           reduce using rule 77 (pop_operand -> .)
    IF              reduce using rule 77 (pop_operand -> .)
    WHILE           reduce using rule 77 (pop_operand -> .)
    ID              reduce using rule 77 (pop_operand -> .)
    TRUE            reduce using rule 77 (pop_operand -> .)
    FALSE           reduce using rule 77 (pop_operand -> .)
    (               reduce using rule 77 (pop_operand -> .)
    *               reduce using rule 77 (pop_operand -> .)
    /               reduce using rule 77 (pop_operand -> .)
    I_CONST         reduce using rule 77 (pop_operand -> .)
    F_CONST         reduce using rule 77 (pop_operand -> .)
    C_CONST         reduce using rule 77 (pop_operand -> .)
    }               reduce using rule 77 (pop_operand -> .)
    RETURN          reduce using rule 77 (pop_operand -> .)

    pop_operand                    shift and go to state 294

state 291

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad . } empty_local_variables_table

    }               shift and go to state 295


state 292

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK . } end_for

    }               shift and go to state 296


state 293

    (81) ELSE_STMT -> ELSE { go_to_true_quad . BLOCK } fill_go_to_true_quad
    (41) BLOCK -> . STATEMENT BLOCK
    (42) BLOCK -> . empty
    (43) STATEMENT -> . ASSIGNATION
    (44) STATEMENT -> . FUNC_CALL
    (45) STATEMENT -> . EXPRESSION ;
    (46) STATEMENT -> . WRITE ;
    (47) STATEMENT -> . CONDITION
    (48) STATEMENT -> . WHILE_STMT
    (49) STATEMENT -> . FOR_STMT
    (50) STATEMENT -> . DESCRIBE_STMT
    (123) empty -> .
    (56) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (57) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (58) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (62) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (92) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (67) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (68) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (80) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (83) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (89) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (90) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (25) VARIABLE -> . ID get_variable
    (26) VARIABLE -> . ID [ EXPRESSION ]
    (95) AND_EXP -> . B_EXP AND_EXP_PRIME
    (98) B_EXP -> . TRUE
    (99) B_EXP -> . FALSE
    (100) B_EXP -> . EXP B_EXP_PRIME
    (106) EXP -> . TERM EXP_PRIME
    (110) TERM -> . FACTOR TERM_PRIME
    (114) FACTOR -> . ( EXPRESSION )
    (115) FACTOR -> . * VAR_CT
    (116) FACTOR -> . / VAR_CT
    (117) FACTOR -> . VAR_CT
    (118) VAR_CT -> . ID add_operand
    (119) VAR_CT -> . I_CONST add_operand
    (120) VAR_CT -> . F_CONST add_operand
    (121) VAR_CT -> . C_CONST add_operand
    (122) VAR_CT -> . FUNC_CALL

    }               reduce using rule 123 (empty -> .)
    FOR             shift and go to state 135
    FUNC            shift and go to state 66
    PRINT           shift and go to state 136
    IF              shift and go to state 137
    WHILE           shift and go to state 138
    ID              shift and go to state 122
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 297
    STATEMENT                      shift and go to state 124
    empty                          shift and go to state 125
    ASSIGNATION                    shift and go to state 126
    FUNC_CALL                      shift and go to state 127
    EXPRESSION                     shift and go to state 128
    WRITE                          shift and go to state 129
    CONDITION                      shift and go to state 130
    WHILE_STMT                     shift and go to state 131
    FOR_STMT                       shift and go to state 132
    DESCRIBE_STMT                  shift and go to state 133
    VARIABLE                       shift and go to state 134
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 294

    (83) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .

    FOR             reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    FUNC            reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    PRINT           reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    IF              reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    WHILE           reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    ID              reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    TRUE            reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    FALSE           reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    (               reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    *               reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    /               reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    I_CONST         reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    F_CONST         reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    C_CONST         reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    }               reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    RETURN          reduce using rule 83 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)


state 295

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } . empty_local_variables_table
    (4) empty_local_variables_table -> .

    FUNC            reduce using rule 4 (empty_local_variables_table -> .)
    VOID            reduce using rule 4 (empty_local_variables_table -> .)

    empty_local_variables_table    shift and go to state 298

state 296

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } . end_for
    (88) end_for -> .

    FOR             reduce using rule 88 (end_for -> .)
    FUNC            reduce using rule 88 (end_for -> .)
    PRINT           reduce using rule 88 (end_for -> .)
    IF              reduce using rule 88 (end_for -> .)
    WHILE           reduce using rule 88 (end_for -> .)
    ID              reduce using rule 88 (end_for -> .)
    TRUE            reduce using rule 88 (end_for -> .)
    FALSE           reduce using rule 88 (end_for -> .)
    (               reduce using rule 88 (end_for -> .)
    *               reduce using rule 88 (end_for -> .)
    /               reduce using rule 88 (end_for -> .)
    I_CONST         reduce using rule 88 (end_for -> .)
    F_CONST         reduce using rule 88 (end_for -> .)
    C_CONST         reduce using rule 88 (end_for -> .)
    }               reduce using rule 88 (end_for -> .)
    RETURN          reduce using rule 88 (end_for -> .)

    end_for                        shift and go to state 299

state 297

    (81) ELSE_STMT -> ELSE { go_to_true_quad BLOCK . } fill_go_to_true_quad

    }               shift and go to state 300


state 298

    (34) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .

    FUNC            reduce using rule 34 (FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .)
    VOID            reduce using rule 34 (FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .)


state 299

    (89) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .

    FOR             reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FUNC            reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    PRINT           reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    IF              reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    WHILE           reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    ID              reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    TRUE            reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FALSE           reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    (               reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    *               reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    /               reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    I_CONST         reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    F_CONST         reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    C_CONST         reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    }               reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    RETURN          reduce using rule 89 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)


state 300

    (81) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } . fill_go_to_true_quad
    (75) fill_go_to_true_quad -> .

    FOR             reduce using rule 75 (fill_go_to_true_quad -> .)
    FUNC            reduce using rule 75 (fill_go_to_true_quad -> .)
    PRINT           reduce using rule 75 (fill_go_to_true_quad -> .)
    IF              reduce using rule 75 (fill_go_to_true_quad -> .)
    WHILE           reduce using rule 75 (fill_go_to_true_quad -> .)
    ID              reduce using rule 75 (fill_go_to_true_quad -> .)
    TRUE            reduce using rule 75 (fill_go_to_true_quad -> .)
    FALSE           reduce using rule 75 (fill_go_to_true_quad -> .)
    (               reduce using rule 75 (fill_go_to_true_quad -> .)
    *               reduce using rule 75 (fill_go_to_true_quad -> .)
    /               reduce using rule 75 (fill_go_to_true_quad -> .)
    I_CONST         reduce using rule 75 (fill_go_to_true_quad -> .)
    F_CONST         reduce using rule 75 (fill_go_to_true_quad -> .)
    C_CONST         reduce using rule 75 (fill_go_to_true_quad -> .)
    }               reduce using rule 75 (fill_go_to_true_quad -> .)
    RETURN          reduce using rule 75 (fill_go_to_true_quad -> .)

    fill_go_to_true_quad           shift and go to state 301

state 301

    (81) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .

    FOR             reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FUNC            reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    PRINT           reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    IF              reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    WHILE           reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    ID              reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    TRUE            reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FALSE           reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    (               reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    *               reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    /               reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    I_CONST         reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    F_CONST         reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    C_CONST         reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    }               reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    RETURN          reduce using rule 81 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 57 resolved as shift
WARNING: shift/reduce conflict for / in state 57 resolved as shift
WARNING: shift/reduce conflict for * in state 180 resolved as shift
WARNING: shift/reduce conflict for / in state 180 resolved as shift
WARNING: shift/reduce conflict for * in state 181 resolved as shift
WARNING: shift/reduce conflict for / in state 181 resolved as shift
WARNING: reduce/reduce conflict in state 127 resolved using rule (STATEMENT -> FUNC_CALL)
WARNING: rejected rule (VAR_CT -> FUNC_CALL) in state 127
WARNING: reduce/reduce conflict in state 205 resolved using rule (functions_assignation -> <empty>)
WARNING: rejected rule (VAR_CT -> FUNC_CALL) in state 205
