Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
Rule 2     go_to_main -> <empty>
Rule 3     fill_go_to_main_quad -> <empty>
Rule 4     add_id -> <empty>
Rule 5     save_ids -> <empty>
Rule 6     save_function -> <empty>
Rule 7     VARS_PRIME -> VARS VARS_PRIME
Rule 8     VARS_PRIME -> empty
Rule 9     FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 10    FUNCTION_PRIME -> empty
Rule 11    FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 12    FUNC_PRIME -> empty
Rule 13    add_type -> <empty>
Rule 14    add_current_type -> <empty>
Rule 15    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 16    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 17    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
Rule 18    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
Rule 19    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 20    TIPO_PRIME -> empty
Rule 21    get_variable -> <empty>
Rule 22    VARIABLE -> ID get_variable
Rule 23    VARIABLE -> ID [ EXPRESSION ]
Rule 24    TIPO_SIMPLE -> INT add_type
Rule 25    TIPO_SIMPLE -> FLOAT add_type
Rule 26    TIPO_SIMPLE -> CHAR add_type
Rule 27    TIPO_COMP -> DATAFRAME
Rule 28    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
Rule 29    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
Rule 30    FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
Rule 31    PARAM -> TIPO_SIMPLE ID PARAM_PRIME
Rule 32    PARAM -> empty
Rule 33    PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME
Rule 34    PARAM_PRIME -> empty
Rule 35    BLOCK -> STATEMENT BLOCK
Rule 36    BLOCK -> empty
Rule 37    STATEMENT -> ASSIGNATION
Rule 38    STATEMENT -> FUNC_CALL
Rule 39    STATEMENT -> EXPRESSION ;
Rule 40    STATEMENT -> WRITE ;
Rule 41    STATEMENT -> CONDITION
Rule 42    STATEMENT -> WHILE_STMT
Rule 43    STATEMENT -> FOR_STMT
Rule 44    STATEMENT -> DESCRIBE_STMT
Rule 45    add_operator -> <empty>
Rule 46    add_operand -> <empty>
Rule 47    add_assignation_quad -> <empty>
Rule 48    add_assignation_for_quad -> <empty>
Rule 49    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 50    ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
Rule 51    FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME )
Rule 52    FUNC_CALL_PRIME -> , EXPRESSION FUNC_CALL_PRIME
Rule 53    FUNC_CALL_PRIME -> empty
Rule 54    print_quad -> <empty>
Rule 55    add_print_operator -> <empty>
Rule 56    WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
Rule 57    WRITE -> PRINT add_operator ( TITLE WRITE_PRIME )
Rule 58    WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME
Rule 59    WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME
Rule 60    WRITE_PRIME -> empty
Rule 61    go_to_false_quad -> <empty>
Rule 62    fill_go_to_false_quad -> <empty>
Rule 63    go_to_true_quad -> <empty>
Rule 64    fill_go_to_true_quad -> <empty>
Rule 65    go_to_quad -> <empty>
Rule 66    pop_operand -> <empty>
Rule 67    pop_type -> <empty>
Rule 68    append_jump -> <empty>
Rule 69    CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
Rule 70    ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
Rule 71    ELSE_STMT -> empty
Rule 72    WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
Rule 73    check_exact_type_for -> <empty>
Rule 74    add_final_counter_for -> <empty>
Rule 75    generate_for_quad -> <empty>
Rule 76    check_boolean_expression_for -> <empty>
Rule 77    end_for -> <empty>
Rule 78    FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
Rule 79    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 80    aritmetics_operation -> <empty>
Rule 81    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 82    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 83    EXPRESSION_PRIME -> empty
Rule 84    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 85    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 86    AND_EXP_PRIME -> empty
Rule 87    B_EXP -> TRUE
Rule 88    B_EXP -> FALSE
Rule 89    B_EXP -> EXP B_EXP_PRIME
Rule 90    B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation
Rule 91    B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation
Rule 92    B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation
Rule 93    B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation
Rule 94    B_EXP_PRIME -> empty
Rule 95    EXP -> TERM EXP_PRIME
Rule 96    EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation
Rule 97    EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation
Rule 98    EXP_PRIME -> empty
Rule 99    TERM -> FACTOR TERM_PRIME
Rule 100   TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 101   TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 102   TERM_PRIME -> empty
Rule 103   FACTOR -> ( EXPRESSION )
Rule 104   FACTOR -> * VAR_CT
Rule 105   FACTOR -> / VAR_CT
Rule 106   FACTOR -> VAR_CT
Rule 107   VAR_CT -> ID add_operand
Rule 108   VAR_CT -> I_CONST add_operand
Rule 109   VAR_CT -> F_CONST add_operand
Rule 110   VAR_CT -> C_CONST add_operand
Rule 111   empty -> <empty>

Terminals, with rules where they appear

(                    : 28 29 30 51 56 57 69 72 78 79 103
)                    : 28 29 30 51 56 57 69 72 78 79 103
*                    : 100 104
+                    : 96
,                    : 19 33 52 58 59
-                    : 97
.                    : 79
/                    : 101 105
;                    : 1 15 16 17 18 39 40 49
<                    : 91
=                    : 49 50
>                    : 90
AND                  : 85
CHAR                 : 26
C_CONST              : 110
DATAFRAME            : 27
DESCRIBE             : 79
DIFFERENT            : 92
DO                   : 78
ELSE                 : 70
EQUAL                : 93
FALSE                : 88
FLOAT                : 25
FOR                  : 50
FUNC                 : 28 29 30
F_CONST              : 109
ID                   : 1 15 16 17 18 19 22 23 28 29 30 31 33 51 79 107
IF                   : 69
INT                  : 24
I_CONST              : 108
MAIN                 : 1
OR                   : 82
PRINT                : 56 57
PROG                 : 1
RETURN               : 28 29
TITLE                : 57 59
TO                   : 78
TRUE                 : 87
VAR                  : 15 16 17 18
VOID                 : 1 30
WHILE                : 72
[                    : 17 18 18 23
]                    : 17 18 18 23
error                : 
{                    : 1 28 29 30 69 70 72 78
}                    : 1 28 29 30 69 70 72 78

Nonterminals, with rules where they appear

AND_EXP              : 81 82
AND_EXP_PRIME        : 84 85
ASSIGNATION          : 37 78
BLOCK                : 1 28 29 30 35 69 70 72 78
B_EXP                : 84 85 90 91 92 93
B_EXP_PRIME          : 89
CONDITION            : 41
DESCRIBE_STMT        : 44
ELSE_STMT            : 69
EXP                  : 89
EXPRESSION           : 17 18 18 23 28 39 49 50 51 52 56 58 69 72 78 103
EXPRESSION_PRIME     : 81 82
EXP_PRIME            : 95 96 97
FACTOR               : 99 100 101
FOR_STMT             : 43
FUNCTION             : 9 11
FUNCTION_PRIME       : 1
FUNC_CALL            : 38
FUNC_CALL_PRIME      : 51 52
FUNC_PRIME           : 9 11
PARAM                : 28 29 30
PARAM_PRIME          : 31 33
PROGRAM              : 0
STATEMENT            : 35
TERM                 : 95 96 97
TERM_PRIME           : 99 100 101
TIPO_COMP            : 15
TIPO_PRIME           : 15 16 19
TIPO_SIMPLE          : 16 17 18 28 29 31 33
VARIABLE             : 49 50
VARS                 : 7
VARS_PRIME           : 1 1 7 28 29 30
VAR_CT               : 29 104 105 106
WHILE_STMT           : 42
WRITE                : 40
WRITE_PRIME          : 56 57 58 59
add_assignation_for_quad : 50
add_assignation_quad : 49
add_current_type     : 19
add_final_counter_for : 78
add_id               : 1 15 16 19
add_operand          : 107 108 109 110
add_operator         : 49 50 56 57 90 91 92 93 96 97 100 101
add_print_operator   : 58 59
add_type             : 1 24 25 26
append_jump          : 72
aritmetics_operation : 90 91 92 93 96 97 100 101
check_boolean_expression_for : 78
check_exact_type_for : 78 78
empty                : 8 10 12 20 32 34 36 53 60 71 83 86 94 98 102
end_for              : 78
fill_go_to_false_quad : 69 72
fill_go_to_main_quad : 1
fill_go_to_true_quad : 70
generate_for_quad    : 78
get_variable         : 22
go_to_false_quad     : 69 72
go_to_main           : 1
go_to_quad           : 72
go_to_true_quad      : 70
pop_operand          : 69 72
pop_type             : 69 72
print_quad           : 56 58 59
save_function        : 1
save_ids             : 15 16

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (13) add_type -> .

    ID              reduce using rule 13 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (4) add_id -> .

    ;               reduce using rule 4 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (2) go_to_main -> .

    VAR             reduce using rule 2 (go_to_main -> .)
    FUNC            reduce using rule 2 (go_to_main -> .)
    VOID            reduce using rule 2 (go_to_main -> .)

    go_to_main                     shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main . save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (6) save_function -> .

    VAR             reduce using rule 6 (save_function -> .)
    FUNC            reduce using rule 6 (save_function -> .)
    VOID            reduce using rule 6 (save_function -> .)

    save_function                  shift and go to state 8

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function . VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (7) VARS_PRIME -> . VARS VARS_PRIME
    (8) VARS_PRIME -> . empty
    (15) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (111) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 111 (empty -> .)
    VOID            reduce using rule 111 (empty -> .)

    VARS_PRIME                     shift and go to state 9
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 9

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME . FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }
    (9) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (10) FUNCTION_PRIME -> . empty
    (28) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (30) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (111) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 111 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 13
    FUNCTION                       shift and go to state 14
    empty                          shift and go to state 15

state 10

    (7) VARS_PRIME -> VARS . VARS_PRIME
    (7) VARS_PRIME -> . VARS VARS_PRIME
    (8) VARS_PRIME -> . empty
    (15) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (111) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 111 (empty -> .)
    VOID            reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    VARS                           shift and go to state 10
    VARS_PRIME                     shift and go to state 17
    empty                          shift and go to state 11

state 11

    (8) VARS_PRIME -> empty .

    FUNC            reduce using rule 8 (VARS_PRIME -> empty .)
    VOID            reduce using rule 8 (VARS_PRIME -> empty .)
    FOR             reduce using rule 8 (VARS_PRIME -> empty .)
    ID              reduce using rule 8 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 8 (VARS_PRIME -> empty .)
    IF              reduce using rule 8 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 8 (VARS_PRIME -> empty .)
    TRUE            reduce using rule 8 (VARS_PRIME -> empty .)
    FALSE           reduce using rule 8 (VARS_PRIME -> empty .)
    (               reduce using rule 8 (VARS_PRIME -> empty .)
    *               reduce using rule 8 (VARS_PRIME -> empty .)
    /               reduce using rule 8 (VARS_PRIME -> empty .)
    I_CONST         reduce using rule 8 (VARS_PRIME -> empty .)
    F_CONST         reduce using rule 8 (VARS_PRIME -> empty .)
    C_CONST         reduce using rule 8 (VARS_PRIME -> empty .)
    }               reduce using rule 8 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 8 (VARS_PRIME -> empty .)


state 12

    (15) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (27) TIPO_COMP -> . DATAFRAME
    (24) TIPO_SIMPLE -> . INT add_type
    (25) TIPO_SIMPLE -> . FLOAT add_type
    (26) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 20
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_COMP                      shift and go to state 18
    TIPO_SIMPLE                    shift and go to state 19

state 13

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME . VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }

    VOID            shift and go to state 24


state 14

    (9) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (11) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (12) FUNC_PRIME -> . empty
    (28) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (30) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (111) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 111 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 26
    empty                          shift and go to state 27

state 15

    (10) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 10 (FUNCTION_PRIME -> empty .)


state 16

    (28) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (30) FUNCTION -> FUNC . VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (24) TIPO_SIMPLE -> . INT add_type
    (25) TIPO_SIMPLE -> . FLOAT add_type
    (26) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 29
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 28

state 17

    (7) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    TRUE            reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    FALSE           reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    (               reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    *               reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    /               reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    I_CONST         reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    F_CONST         reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    C_CONST         reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 7 (VARS_PRIME -> VARS VARS_PRIME .)


state 18

    (15) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 30


state 19

    (16) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] ;
    (18) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] [ EXPRESSION ] ;

    ID              shift and go to state 31


state 20

    (27) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 27 (TIPO_COMP -> DATAFRAME .)


state 21

    (24) TIPO_SIMPLE -> INT . add_type
    (13) add_type -> .

    ID              reduce using rule 13 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (25) TIPO_SIMPLE -> FLOAT . add_type
    (13) add_type -> .

    ID              reduce using rule 13 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (26) TIPO_SIMPLE -> CHAR . add_type
    (13) add_type -> .

    ID              reduce using rule 13 (add_type -> .)

    add_type                       shift and go to state 34

state 24

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID . MAIN { fill_go_to_main_quad VARS_PRIME BLOCK }

    MAIN            shift and go to state 35


state 25

    (11) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (11) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (12) FUNC_PRIME -> . empty
    (28) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (30) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (111) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 111 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 36
    empty                          shift and go to state 27

state 26

    (9) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 9 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 27

    (12) FUNC_PRIME -> empty .

    VOID            reduce using rule 12 (FUNC_PRIME -> empty .)


state 28

    (28) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    ID              shift and go to state 37


state 29

    (30) FUNCTION -> FUNC VOID . ID ( PARAM ) { VARS_PRIME BLOCK }

    ID              shift and go to state 38


state 30

    (15) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (4) add_id -> .

    ,               reduce using rule 4 (add_id -> .)
    ;               reduce using rule 4 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (16) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (17) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] ;
    (18) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] [ EXPRESSION ] ;
    (4) add_id -> .

    [               shift and go to state 41
    ,               reduce using rule 4 (add_id -> .)
    ;               reduce using rule 4 (add_id -> .)

    add_id                         shift and go to state 40

state 32

    (24) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 24 (TIPO_SIMPLE -> INT add_type .)


state 33

    (25) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 25 (TIPO_SIMPLE -> FLOAT add_type .)


state 34

    (26) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 26 (TIPO_SIMPLE -> CHAR add_type .)


state 35

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN . { fill_go_to_main_quad VARS_PRIME BLOCK }

    {               shift and go to state 42


state 36

    (11) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 11 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 37

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    (               shift and go to state 43


state 38

    (30) FUNCTION -> FUNC VOID ID . ( PARAM ) { VARS_PRIME BLOCK }

    (               shift and go to state 44


state 39

    (15) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (19) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (20) TIPO_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 111 (empty -> .)

    TIPO_PRIME                     shift and go to state 45
    empty                          shift and go to state 47

state 40

    (16) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (19) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (20) TIPO_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 111 (empty -> .)

    TIPO_PRIME                     shift and go to state 48
    empty                          shift and go to state 47

state 41

    (17) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] ;
    (18) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] [ EXPRESSION ] ;
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 50
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 42

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { . fill_go_to_main_quad VARS_PRIME BLOCK }
    (3) fill_go_to_main_quad -> .

    VAR             reduce using rule 3 (fill_go_to_main_quad -> .)
    FOR             reduce using rule 3 (fill_go_to_main_quad -> .)
    ID              reduce using rule 3 (fill_go_to_main_quad -> .)
    PRINT           reduce using rule 3 (fill_go_to_main_quad -> .)
    IF              reduce using rule 3 (fill_go_to_main_quad -> .)
    WHILE           reduce using rule 3 (fill_go_to_main_quad -> .)
    TRUE            reduce using rule 3 (fill_go_to_main_quad -> .)
    FALSE           reduce using rule 3 (fill_go_to_main_quad -> .)
    (               reduce using rule 3 (fill_go_to_main_quad -> .)
    *               reduce using rule 3 (fill_go_to_main_quad -> .)
    /               reduce using rule 3 (fill_go_to_main_quad -> .)
    I_CONST         reduce using rule 3 (fill_go_to_main_quad -> .)
    F_CONST         reduce using rule 3 (fill_go_to_main_quad -> .)
    C_CONST         reduce using rule 3 (fill_go_to_main_quad -> .)
    }               reduce using rule 3 (fill_go_to_main_quad -> .)

    fill_go_to_main_quad           shift and go to state 65

state 43

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (31) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (32) PARAM -> . empty
    (24) TIPO_SIMPLE -> . INT add_type
    (25) TIPO_SIMPLE -> . FLOAT add_type
    (26) TIPO_SIMPLE -> . CHAR add_type
    (111) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 111 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 66
    PARAM                          shift and go to state 67
    empty                          shift and go to state 68

state 44

    (30) FUNCTION -> FUNC VOID ID ( . PARAM ) { VARS_PRIME BLOCK }
    (31) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (32) PARAM -> . empty
    (24) TIPO_SIMPLE -> . INT add_type
    (25) TIPO_SIMPLE -> . FLOAT add_type
    (26) TIPO_SIMPLE -> . CHAR add_type
    (111) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 111 (empty -> .)

    PARAM                          shift and go to state 69
    TIPO_SIMPLE                    shift and go to state 66
    empty                          shift and go to state 68

state 45

    (15) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 70


state 46

    (19) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 71


state 47

    (20) TIPO_PRIME -> empty .

    ;               reduce using rule 20 (TIPO_PRIME -> empty .)


state 48

    (16) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 72


state 49

    (107) VAR_CT -> ID . add_operand
    (46) add_operand -> .

    *               reduce using rule 46 (add_operand -> .)
    /               reduce using rule 46 (add_operand -> .)
    +               reduce using rule 46 (add_operand -> .)
    -               reduce using rule 46 (add_operand -> .)
    >               reduce using rule 46 (add_operand -> .)
    <               reduce using rule 46 (add_operand -> .)
    DIFFERENT       reduce using rule 46 (add_operand -> .)
    EQUAL           reduce using rule 46 (add_operand -> .)
    AND             reduce using rule 46 (add_operand -> .)
    OR              reduce using rule 46 (add_operand -> .)
    ]               reduce using rule 46 (add_operand -> .)
    )               reduce using rule 46 (add_operand -> .)
    ;               reduce using rule 46 (add_operand -> .)
    ,               reduce using rule 46 (add_operand -> .)
    TO              reduce using rule 46 (add_operand -> .)
    FOR             reduce using rule 46 (add_operand -> .)
    ID              reduce using rule 46 (add_operand -> .)
    PRINT           reduce using rule 46 (add_operand -> .)
    IF              reduce using rule 46 (add_operand -> .)
    WHILE           reduce using rule 46 (add_operand -> .)
    TRUE            reduce using rule 46 (add_operand -> .)
    FALSE           reduce using rule 46 (add_operand -> .)
    (               reduce using rule 46 (add_operand -> .)
    I_CONST         reduce using rule 46 (add_operand -> .)
    F_CONST         reduce using rule 46 (add_operand -> .)
    C_CONST         reduce using rule 46 (add_operand -> .)
    }               reduce using rule 46 (add_operand -> .)
    RETURN          reduce using rule 46 (add_operand -> .)

    add_operand                    shift and go to state 73

state 50

    (17) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] ;
    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] [ EXPRESSION ] ;

    ]               shift and go to state 74


state 51

    (81) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (82) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (83) EXPRESSION_PRIME -> . empty
    (111) empty -> .

    OR              shift and go to state 76
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 75
    empty                          shift and go to state 77

state 52

    (84) AND_EXP -> B_EXP . AND_EXP_PRIME
    (85) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (86) AND_EXP_PRIME -> . empty
    (111) empty -> .

    AND             shift and go to state 79
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 78
    empty                          shift and go to state 80

state 53

    (87) B_EXP -> TRUE .

    AND             reduce using rule 87 (B_EXP -> TRUE .)
    OR              reduce using rule 87 (B_EXP -> TRUE .)
    ]               reduce using rule 87 (B_EXP -> TRUE .)
    )               reduce using rule 87 (B_EXP -> TRUE .)
    ;               reduce using rule 87 (B_EXP -> TRUE .)
    ,               reduce using rule 87 (B_EXP -> TRUE .)
    TO              reduce using rule 87 (B_EXP -> TRUE .)
    FOR             reduce using rule 87 (B_EXP -> TRUE .)
    ID              reduce using rule 87 (B_EXP -> TRUE .)
    PRINT           reduce using rule 87 (B_EXP -> TRUE .)
    IF              reduce using rule 87 (B_EXP -> TRUE .)
    WHILE           reduce using rule 87 (B_EXP -> TRUE .)
    TRUE            reduce using rule 87 (B_EXP -> TRUE .)
    FALSE           reduce using rule 87 (B_EXP -> TRUE .)
    (               reduce using rule 87 (B_EXP -> TRUE .)
    *               reduce using rule 87 (B_EXP -> TRUE .)
    /               reduce using rule 87 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 87 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 87 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 87 (B_EXP -> TRUE .)
    }               reduce using rule 87 (B_EXP -> TRUE .)
    RETURN          reduce using rule 87 (B_EXP -> TRUE .)


state 54

    (88) B_EXP -> FALSE .

    AND             reduce using rule 88 (B_EXP -> FALSE .)
    OR              reduce using rule 88 (B_EXP -> FALSE .)
    ]               reduce using rule 88 (B_EXP -> FALSE .)
    )               reduce using rule 88 (B_EXP -> FALSE .)
    ;               reduce using rule 88 (B_EXP -> FALSE .)
    ,               reduce using rule 88 (B_EXP -> FALSE .)
    TO              reduce using rule 88 (B_EXP -> FALSE .)
    FOR             reduce using rule 88 (B_EXP -> FALSE .)
    ID              reduce using rule 88 (B_EXP -> FALSE .)
    PRINT           reduce using rule 88 (B_EXP -> FALSE .)
    IF              reduce using rule 88 (B_EXP -> FALSE .)
    WHILE           reduce using rule 88 (B_EXP -> FALSE .)
    TRUE            reduce using rule 88 (B_EXP -> FALSE .)
    FALSE           reduce using rule 88 (B_EXP -> FALSE .)
    (               reduce using rule 88 (B_EXP -> FALSE .)
    *               reduce using rule 88 (B_EXP -> FALSE .)
    /               reduce using rule 88 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 88 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 88 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 88 (B_EXP -> FALSE .)
    }               reduce using rule 88 (B_EXP -> FALSE .)
    RETURN          reduce using rule 88 (B_EXP -> FALSE .)


state 55

    (89) B_EXP -> EXP . B_EXP_PRIME
    (90) B_EXP_PRIME -> . > add_operator B_EXP aritmetics_operation
    (91) B_EXP_PRIME -> . < add_operator B_EXP aritmetics_operation
    (92) B_EXP_PRIME -> . DIFFERENT add_operator B_EXP aritmetics_operation
    (93) B_EXP_PRIME -> . EQUAL add_operator B_EXP aritmetics_operation
    (94) B_EXP_PRIME -> . empty
    (111) empty -> .

    >               shift and go to state 82
    <               shift and go to state 83
    DIFFERENT       shift and go to state 84
    EQUAL           shift and go to state 85
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    B_EXP_PRIME                    shift and go to state 81
    empty                          shift and go to state 86

state 56

    (95) EXP -> TERM . EXP_PRIME
    (96) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (97) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (98) EXP_PRIME -> . empty
    (111) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    EXP_PRIME                      shift and go to state 87
    empty                          shift and go to state 90

state 57

    (99) TERM -> FACTOR . TERM_PRIME
    (100) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (101) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (102) TERM_PRIME -> . empty
    (111) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 111 (empty -> .)
    -               reduce using rule 111 (empty -> .)
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

  ! *               [ reduce using rule 111 (empty -> .) ]
  ! /               [ reduce using rule 111 (empty -> .) ]

    TERM_PRIME                     shift and go to state 91
    empty                          shift and go to state 94

state 58

    (103) FACTOR -> ( . EXPRESSION )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 95
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 59

    (104) FACTOR -> * . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    VAR_CT                         shift and go to state 96

state 60

    (106) FACTOR -> VAR_CT .

    *               reduce using rule 106 (FACTOR -> VAR_CT .)
    /               reduce using rule 106 (FACTOR -> VAR_CT .)
    +               reduce using rule 106 (FACTOR -> VAR_CT .)
    -               reduce using rule 106 (FACTOR -> VAR_CT .)
    >               reduce using rule 106 (FACTOR -> VAR_CT .)
    <               reduce using rule 106 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 106 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 106 (FACTOR -> VAR_CT .)
    AND             reduce using rule 106 (FACTOR -> VAR_CT .)
    OR              reduce using rule 106 (FACTOR -> VAR_CT .)
    ]               reduce using rule 106 (FACTOR -> VAR_CT .)
    )               reduce using rule 106 (FACTOR -> VAR_CT .)
    ;               reduce using rule 106 (FACTOR -> VAR_CT .)
    ,               reduce using rule 106 (FACTOR -> VAR_CT .)
    TO              reduce using rule 106 (FACTOR -> VAR_CT .)
    FOR             reduce using rule 106 (FACTOR -> VAR_CT .)
    ID              reduce using rule 106 (FACTOR -> VAR_CT .)
    PRINT           reduce using rule 106 (FACTOR -> VAR_CT .)
    IF              reduce using rule 106 (FACTOR -> VAR_CT .)
    WHILE           reduce using rule 106 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 106 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 106 (FACTOR -> VAR_CT .)
    (               reduce using rule 106 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 106 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 106 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 106 (FACTOR -> VAR_CT .)
    }               reduce using rule 106 (FACTOR -> VAR_CT .)
    RETURN          reduce using rule 106 (FACTOR -> VAR_CT .)


state 61

    (105) FACTOR -> / . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    VAR_CT                         shift and go to state 97

state 62

    (108) VAR_CT -> I_CONST . add_operand
    (46) add_operand -> .

    *               reduce using rule 46 (add_operand -> .)
    /               reduce using rule 46 (add_operand -> .)
    +               reduce using rule 46 (add_operand -> .)
    -               reduce using rule 46 (add_operand -> .)
    >               reduce using rule 46 (add_operand -> .)
    <               reduce using rule 46 (add_operand -> .)
    DIFFERENT       reduce using rule 46 (add_operand -> .)
    EQUAL           reduce using rule 46 (add_operand -> .)
    AND             reduce using rule 46 (add_operand -> .)
    OR              reduce using rule 46 (add_operand -> .)
    ]               reduce using rule 46 (add_operand -> .)
    )               reduce using rule 46 (add_operand -> .)
    ;               reduce using rule 46 (add_operand -> .)
    ,               reduce using rule 46 (add_operand -> .)
    TO              reduce using rule 46 (add_operand -> .)
    FOR             reduce using rule 46 (add_operand -> .)
    ID              reduce using rule 46 (add_operand -> .)
    PRINT           reduce using rule 46 (add_operand -> .)
    IF              reduce using rule 46 (add_operand -> .)
    WHILE           reduce using rule 46 (add_operand -> .)
    TRUE            reduce using rule 46 (add_operand -> .)
    FALSE           reduce using rule 46 (add_operand -> .)
    (               reduce using rule 46 (add_operand -> .)
    I_CONST         reduce using rule 46 (add_operand -> .)
    F_CONST         reduce using rule 46 (add_operand -> .)
    C_CONST         reduce using rule 46 (add_operand -> .)
    }               reduce using rule 46 (add_operand -> .)
    RETURN          reduce using rule 46 (add_operand -> .)

    add_operand                    shift and go to state 98

state 63

    (109) VAR_CT -> F_CONST . add_operand
    (46) add_operand -> .

    *               reduce using rule 46 (add_operand -> .)
    /               reduce using rule 46 (add_operand -> .)
    +               reduce using rule 46 (add_operand -> .)
    -               reduce using rule 46 (add_operand -> .)
    >               reduce using rule 46 (add_operand -> .)
    <               reduce using rule 46 (add_operand -> .)
    DIFFERENT       reduce using rule 46 (add_operand -> .)
    EQUAL           reduce using rule 46 (add_operand -> .)
    AND             reduce using rule 46 (add_operand -> .)
    OR              reduce using rule 46 (add_operand -> .)
    ]               reduce using rule 46 (add_operand -> .)
    )               reduce using rule 46 (add_operand -> .)
    ;               reduce using rule 46 (add_operand -> .)
    ,               reduce using rule 46 (add_operand -> .)
    TO              reduce using rule 46 (add_operand -> .)
    FOR             reduce using rule 46 (add_operand -> .)
    ID              reduce using rule 46 (add_operand -> .)
    PRINT           reduce using rule 46 (add_operand -> .)
    IF              reduce using rule 46 (add_operand -> .)
    WHILE           reduce using rule 46 (add_operand -> .)
    TRUE            reduce using rule 46 (add_operand -> .)
    FALSE           reduce using rule 46 (add_operand -> .)
    (               reduce using rule 46 (add_operand -> .)
    I_CONST         reduce using rule 46 (add_operand -> .)
    F_CONST         reduce using rule 46 (add_operand -> .)
    C_CONST         reduce using rule 46 (add_operand -> .)
    }               reduce using rule 46 (add_operand -> .)
    RETURN          reduce using rule 46 (add_operand -> .)

    add_operand                    shift and go to state 99

state 64

    (110) VAR_CT -> C_CONST . add_operand
    (46) add_operand -> .

    *               reduce using rule 46 (add_operand -> .)
    /               reduce using rule 46 (add_operand -> .)
    +               reduce using rule 46 (add_operand -> .)
    -               reduce using rule 46 (add_operand -> .)
    >               reduce using rule 46 (add_operand -> .)
    <               reduce using rule 46 (add_operand -> .)
    DIFFERENT       reduce using rule 46 (add_operand -> .)
    EQUAL           reduce using rule 46 (add_operand -> .)
    AND             reduce using rule 46 (add_operand -> .)
    OR              reduce using rule 46 (add_operand -> .)
    ]               reduce using rule 46 (add_operand -> .)
    )               reduce using rule 46 (add_operand -> .)
    ;               reduce using rule 46 (add_operand -> .)
    ,               reduce using rule 46 (add_operand -> .)
    TO              reduce using rule 46 (add_operand -> .)
    FOR             reduce using rule 46 (add_operand -> .)
    ID              reduce using rule 46 (add_operand -> .)
    PRINT           reduce using rule 46 (add_operand -> .)
    IF              reduce using rule 46 (add_operand -> .)
    WHILE           reduce using rule 46 (add_operand -> .)
    TRUE            reduce using rule 46 (add_operand -> .)
    FALSE           reduce using rule 46 (add_operand -> .)
    (               reduce using rule 46 (add_operand -> .)
    I_CONST         reduce using rule 46 (add_operand -> .)
    F_CONST         reduce using rule 46 (add_operand -> .)
    C_CONST         reduce using rule 46 (add_operand -> .)
    }               reduce using rule 46 (add_operand -> .)
    RETURN          reduce using rule 46 (add_operand -> .)

    add_operand                    shift and go to state 100

state 65

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad . VARS_PRIME BLOCK }
    (7) VARS_PRIME -> . VARS VARS_PRIME
    (8) VARS_PRIME -> . empty
    (15) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (111) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)

    VARS_PRIME                     shift and go to state 101
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 66

    (31) PARAM -> TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 102


state 67

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN VAR_CT }

    )               shift and go to state 103


state 68

    (32) PARAM -> empty .

    )               reduce using rule 32 (PARAM -> empty .)


state 69

    (30) FUNCTION -> FUNC VOID ID ( PARAM . ) { VARS_PRIME BLOCK }

    )               shift and go to state 104


state 70

    (15) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (5) save_ids -> .

    VAR             reduce using rule 5 (save_ids -> .)
    FUNC            reduce using rule 5 (save_ids -> .)
    VOID            reduce using rule 5 (save_ids -> .)
    FOR             reduce using rule 5 (save_ids -> .)
    ID              reduce using rule 5 (save_ids -> .)
    PRINT           reduce using rule 5 (save_ids -> .)
    IF              reduce using rule 5 (save_ids -> .)
    WHILE           reduce using rule 5 (save_ids -> .)
    TRUE            reduce using rule 5 (save_ids -> .)
    FALSE           reduce using rule 5 (save_ids -> .)
    (               reduce using rule 5 (save_ids -> .)
    *               reduce using rule 5 (save_ids -> .)
    /               reduce using rule 5 (save_ids -> .)
    I_CONST         reduce using rule 5 (save_ids -> .)
    F_CONST         reduce using rule 5 (save_ids -> .)
    C_CONST         reduce using rule 5 (save_ids -> .)
    }               reduce using rule 5 (save_ids -> .)
    RETURN          reduce using rule 5 (save_ids -> .)

    save_ids                       shift and go to state 105

state 71

    (19) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (4) add_id -> .

    ,               reduce using rule 4 (add_id -> .)
    ;               reduce using rule 4 (add_id -> .)

    add_id                         shift and go to state 106

state 72

    (16) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (5) save_ids -> .

    VAR             reduce using rule 5 (save_ids -> .)
    FUNC            reduce using rule 5 (save_ids -> .)
    VOID            reduce using rule 5 (save_ids -> .)
    FOR             reduce using rule 5 (save_ids -> .)
    ID              reduce using rule 5 (save_ids -> .)
    PRINT           reduce using rule 5 (save_ids -> .)
    IF              reduce using rule 5 (save_ids -> .)
    WHILE           reduce using rule 5 (save_ids -> .)
    TRUE            reduce using rule 5 (save_ids -> .)
    FALSE           reduce using rule 5 (save_ids -> .)
    (               reduce using rule 5 (save_ids -> .)
    *               reduce using rule 5 (save_ids -> .)
    /               reduce using rule 5 (save_ids -> .)
    I_CONST         reduce using rule 5 (save_ids -> .)
    F_CONST         reduce using rule 5 (save_ids -> .)
    C_CONST         reduce using rule 5 (save_ids -> .)
    }               reduce using rule 5 (save_ids -> .)
    RETURN          reduce using rule 5 (save_ids -> .)

    save_ids                       shift and go to state 107

state 73

    (107) VAR_CT -> ID add_operand .

    *               reduce using rule 107 (VAR_CT -> ID add_operand .)
    /               reduce using rule 107 (VAR_CT -> ID add_operand .)
    +               reduce using rule 107 (VAR_CT -> ID add_operand .)
    -               reduce using rule 107 (VAR_CT -> ID add_operand .)
    >               reduce using rule 107 (VAR_CT -> ID add_operand .)
    <               reduce using rule 107 (VAR_CT -> ID add_operand .)
    DIFFERENT       reduce using rule 107 (VAR_CT -> ID add_operand .)
    EQUAL           reduce using rule 107 (VAR_CT -> ID add_operand .)
    AND             reduce using rule 107 (VAR_CT -> ID add_operand .)
    OR              reduce using rule 107 (VAR_CT -> ID add_operand .)
    ]               reduce using rule 107 (VAR_CT -> ID add_operand .)
    )               reduce using rule 107 (VAR_CT -> ID add_operand .)
    ;               reduce using rule 107 (VAR_CT -> ID add_operand .)
    ,               reduce using rule 107 (VAR_CT -> ID add_operand .)
    TO              reduce using rule 107 (VAR_CT -> ID add_operand .)
    FOR             reduce using rule 107 (VAR_CT -> ID add_operand .)
    ID              reduce using rule 107 (VAR_CT -> ID add_operand .)
    PRINT           reduce using rule 107 (VAR_CT -> ID add_operand .)
    IF              reduce using rule 107 (VAR_CT -> ID add_operand .)
    WHILE           reduce using rule 107 (VAR_CT -> ID add_operand .)
    TRUE            reduce using rule 107 (VAR_CT -> ID add_operand .)
    FALSE           reduce using rule 107 (VAR_CT -> ID add_operand .)
    (               reduce using rule 107 (VAR_CT -> ID add_operand .)
    I_CONST         reduce using rule 107 (VAR_CT -> ID add_operand .)
    F_CONST         reduce using rule 107 (VAR_CT -> ID add_operand .)
    C_CONST         reduce using rule 107 (VAR_CT -> ID add_operand .)
    }               reduce using rule 107 (VAR_CT -> ID add_operand .)
    RETURN          reduce using rule 107 (VAR_CT -> ID add_operand .)


state 74

    (17) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . ;
    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . [ EXPRESSION ] ;

    ;               shift and go to state 109
    [               shift and go to state 108


state 75

    (81) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 81 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 76

    (82) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    AND_EXP                        shift and go to state 110
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 77

    (83) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    FOR             reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    PRINT           reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    IF              reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    WHILE           reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 83 (EXPRESSION_PRIME -> empty .)
    RETURN          reduce using rule 83 (EXPRESSION_PRIME -> empty .)


state 78

    (84) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 84 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 79

    (85) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    B_EXP                          shift and go to state 111
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 80

    (86) AND_EXP_PRIME -> empty .

    OR              reduce using rule 86 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 86 (AND_EXP_PRIME -> empty .)
    FOR             reduce using rule 86 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 86 (AND_EXP_PRIME -> empty .)
    PRINT           reduce using rule 86 (AND_EXP_PRIME -> empty .)
    IF              reduce using rule 86 (AND_EXP_PRIME -> empty .)
    WHILE           reduce using rule 86 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 86 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 86 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 86 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 86 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 86 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 86 (AND_EXP_PRIME -> empty .)
    RETURN          reduce using rule 86 (AND_EXP_PRIME -> empty .)


state 81

    (89) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    FOR             reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    PRINT           reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    IF              reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    WHILE           reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)
    RETURN          reduce using rule 89 (B_EXP -> EXP B_EXP_PRIME .)


state 82

    (90) B_EXP_PRIME -> > . add_operator B_EXP aritmetics_operation
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 112

state 83

    (91) B_EXP_PRIME -> < . add_operator B_EXP aritmetics_operation
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 113

state 84

    (92) B_EXP_PRIME -> DIFFERENT . add_operator B_EXP aritmetics_operation
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 114

state 85

    (93) B_EXP_PRIME -> EQUAL . add_operator B_EXP aritmetics_operation
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 115

state 86

    (94) B_EXP_PRIME -> empty .

    AND             reduce using rule 94 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 94 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 94 (B_EXP_PRIME -> empty .)
    )               reduce using rule 94 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 94 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 94 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 94 (B_EXP_PRIME -> empty .)
    FOR             reduce using rule 94 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 94 (B_EXP_PRIME -> empty .)
    PRINT           reduce using rule 94 (B_EXP_PRIME -> empty .)
    IF              reduce using rule 94 (B_EXP_PRIME -> empty .)
    WHILE           reduce using rule 94 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 94 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 94 (B_EXP_PRIME -> empty .)
    (               reduce using rule 94 (B_EXP_PRIME -> empty .)
    *               reduce using rule 94 (B_EXP_PRIME -> empty .)
    /               reduce using rule 94 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 94 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 94 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 94 (B_EXP_PRIME -> empty .)
    }               reduce using rule 94 (B_EXP_PRIME -> empty .)
    RETURN          reduce using rule 94 (B_EXP_PRIME -> empty .)


state 87

    (95) EXP -> TERM EXP_PRIME .

    >               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    FOR             reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    PRINT           reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    IF              reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    WHILE           reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 95 (EXP -> TERM EXP_PRIME .)
    RETURN          reduce using rule 95 (EXP -> TERM EXP_PRIME .)


state 88

    (96) EXP_PRIME -> + . add_operator TERM EXP_PRIME aritmetics_operation
    (45) add_operator -> .

    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 116

state 89

    (97) EXP_PRIME -> - . add_operator TERM EXP_PRIME aritmetics_operation
    (45) add_operator -> .

    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 117

state 90

    (98) EXP_PRIME -> empty .

    >               reduce using rule 98 (EXP_PRIME -> empty .)
    <               reduce using rule 98 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 98 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 98 (EXP_PRIME -> empty .)
    AND             reduce using rule 98 (EXP_PRIME -> empty .)
    OR              reduce using rule 98 (EXP_PRIME -> empty .)
    ]               reduce using rule 98 (EXP_PRIME -> empty .)
    )               reduce using rule 98 (EXP_PRIME -> empty .)
    ;               reduce using rule 98 (EXP_PRIME -> empty .)
    ,               reduce using rule 98 (EXP_PRIME -> empty .)
    TO              reduce using rule 98 (EXP_PRIME -> empty .)
    FOR             reduce using rule 98 (EXP_PRIME -> empty .)
    ID              reduce using rule 98 (EXP_PRIME -> empty .)
    PRINT           reduce using rule 98 (EXP_PRIME -> empty .)
    IF              reduce using rule 98 (EXP_PRIME -> empty .)
    WHILE           reduce using rule 98 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 98 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 98 (EXP_PRIME -> empty .)
    (               reduce using rule 98 (EXP_PRIME -> empty .)
    *               reduce using rule 98 (EXP_PRIME -> empty .)
    /               reduce using rule 98 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 98 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 98 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 98 (EXP_PRIME -> empty .)
    }               reduce using rule 98 (EXP_PRIME -> empty .)
    RETURN          reduce using rule 98 (EXP_PRIME -> empty .)


state 91

    (99) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    FOR             reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    PRINT           reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    IF              reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    WHILE           reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)
    RETURN          reduce using rule 99 (TERM -> FACTOR TERM_PRIME .)


state 92

    (100) TERM_PRIME -> * . add_operator FACTOR aritmetics_operation TERM_PRIME
    (45) add_operator -> .

    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 118

state 93

    (101) TERM_PRIME -> / . add_operator FACTOR aritmetics_operation TERM_PRIME
    (45) add_operator -> .

    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 119

state 94

    (102) TERM_PRIME -> empty .

    +               reduce using rule 102 (TERM_PRIME -> empty .)
    -               reduce using rule 102 (TERM_PRIME -> empty .)
    >               reduce using rule 102 (TERM_PRIME -> empty .)
    <               reduce using rule 102 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 102 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 102 (TERM_PRIME -> empty .)
    AND             reduce using rule 102 (TERM_PRIME -> empty .)
    OR              reduce using rule 102 (TERM_PRIME -> empty .)
    ]               reduce using rule 102 (TERM_PRIME -> empty .)
    )               reduce using rule 102 (TERM_PRIME -> empty .)
    ;               reduce using rule 102 (TERM_PRIME -> empty .)
    ,               reduce using rule 102 (TERM_PRIME -> empty .)
    TO              reduce using rule 102 (TERM_PRIME -> empty .)
    FOR             reduce using rule 102 (TERM_PRIME -> empty .)
    ID              reduce using rule 102 (TERM_PRIME -> empty .)
    PRINT           reduce using rule 102 (TERM_PRIME -> empty .)
    IF              reduce using rule 102 (TERM_PRIME -> empty .)
    WHILE           reduce using rule 102 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 102 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 102 (TERM_PRIME -> empty .)
    (               reduce using rule 102 (TERM_PRIME -> empty .)
    *               reduce using rule 102 (TERM_PRIME -> empty .)
    /               reduce using rule 102 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 102 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 102 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 102 (TERM_PRIME -> empty .)
    }               reduce using rule 102 (TERM_PRIME -> empty .)
    RETURN          reduce using rule 102 (TERM_PRIME -> empty .)


state 95

    (103) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 120


state 96

    (104) FACTOR -> * VAR_CT .

    *               reduce using rule 104 (FACTOR -> * VAR_CT .)
    /               reduce using rule 104 (FACTOR -> * VAR_CT .)
    +               reduce using rule 104 (FACTOR -> * VAR_CT .)
    -               reduce using rule 104 (FACTOR -> * VAR_CT .)
    >               reduce using rule 104 (FACTOR -> * VAR_CT .)
    <               reduce using rule 104 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 104 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 104 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 104 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 104 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 104 (FACTOR -> * VAR_CT .)
    )               reduce using rule 104 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 104 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 104 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 104 (FACTOR -> * VAR_CT .)
    FOR             reduce using rule 104 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 104 (FACTOR -> * VAR_CT .)
    PRINT           reduce using rule 104 (FACTOR -> * VAR_CT .)
    IF              reduce using rule 104 (FACTOR -> * VAR_CT .)
    WHILE           reduce using rule 104 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 104 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 104 (FACTOR -> * VAR_CT .)
    (               reduce using rule 104 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 104 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 104 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 104 (FACTOR -> * VAR_CT .)
    }               reduce using rule 104 (FACTOR -> * VAR_CT .)
    RETURN          reduce using rule 104 (FACTOR -> * VAR_CT .)


state 97

    (105) FACTOR -> / VAR_CT .

    *               reduce using rule 105 (FACTOR -> / VAR_CT .)
    /               reduce using rule 105 (FACTOR -> / VAR_CT .)
    +               reduce using rule 105 (FACTOR -> / VAR_CT .)
    -               reduce using rule 105 (FACTOR -> / VAR_CT .)
    >               reduce using rule 105 (FACTOR -> / VAR_CT .)
    <               reduce using rule 105 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 105 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 105 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 105 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 105 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 105 (FACTOR -> / VAR_CT .)
    )               reduce using rule 105 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 105 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 105 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 105 (FACTOR -> / VAR_CT .)
    FOR             reduce using rule 105 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 105 (FACTOR -> / VAR_CT .)
    PRINT           reduce using rule 105 (FACTOR -> / VAR_CT .)
    IF              reduce using rule 105 (FACTOR -> / VAR_CT .)
    WHILE           reduce using rule 105 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 105 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 105 (FACTOR -> / VAR_CT .)
    (               reduce using rule 105 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 105 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 105 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 105 (FACTOR -> / VAR_CT .)
    }               reduce using rule 105 (FACTOR -> / VAR_CT .)
    RETURN          reduce using rule 105 (FACTOR -> / VAR_CT .)


state 98

    (108) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    FOR             reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    PRINT           reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    IF              reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    WHILE           reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 108 (VAR_CT -> I_CONST add_operand .)
    RETURN          reduce using rule 108 (VAR_CT -> I_CONST add_operand .)


state 99

    (109) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    FOR             reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    PRINT           reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    IF              reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    WHILE           reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 109 (VAR_CT -> F_CONST add_operand .)
    RETURN          reduce using rule 109 (VAR_CT -> F_CONST add_operand .)


state 100

    (110) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    FOR             reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    PRINT           reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    IF              reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    WHILE           reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 110 (VAR_CT -> C_CONST add_operand .)
    RETURN          reduce using rule 110 (VAR_CT -> C_CONST add_operand .)


state 101

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME . BLOCK }
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 122
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    EXPRESSION                     shift and go to state 127
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 102

    (31) PARAM -> TIPO_SIMPLE ID . PARAM_PRIME
    (33) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (34) PARAM_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 139
    )               reduce using rule 111 (empty -> .)

    PARAM_PRIME                    shift and go to state 138
    empty                          shift and go to state 140

state 103

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN VAR_CT }

    {               shift and go to state 141


state 104

    (30) FUNCTION -> FUNC VOID ID ( PARAM ) . { VARS_PRIME BLOCK }

    {               shift and go to state 142


state 105

    (15) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 15 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 106

    (19) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (14) add_current_type -> .

    ,               reduce using rule 14 (add_current_type -> .)
    ;               reduce using rule 14 (add_current_type -> .)

    add_current_type               shift and go to state 143

state 107

    (16) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 16 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 108

    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ . EXPRESSION ] ;
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 144
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 109

    (17) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .

    VAR             reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FUNC            reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    VOID            reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FOR             reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    ID              reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    PRINT           reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    IF              reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    WHILE           reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    TRUE            reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FALSE           reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    (               reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    *               reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    /               reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    }               reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    RETURN          reduce using rule 17 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)


state 110

    (82) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (82) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (83) EXPRESSION_PRIME -> . empty
    (111) empty -> .

    OR              shift and go to state 76
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 145
    empty                          shift and go to state 77

state 111

    (85) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (85) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (86) AND_EXP_PRIME -> . empty
    (111) empty -> .

    AND             shift and go to state 79
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 146
    empty                          shift and go to state 80

state 112

    (90) B_EXP_PRIME -> > add_operator . B_EXP aritmetics_operation
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    B_EXP                          shift and go to state 147
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 113

    (91) B_EXP_PRIME -> < add_operator . B_EXP aritmetics_operation
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    B_EXP                          shift and go to state 148
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 114

    (92) B_EXP_PRIME -> DIFFERENT add_operator . B_EXP aritmetics_operation
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    B_EXP                          shift and go to state 149
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 115

    (93) B_EXP_PRIME -> EQUAL add_operator . B_EXP aritmetics_operation
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    B_EXP                          shift and go to state 150
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 116

    (96) EXP_PRIME -> + add_operator . TERM EXP_PRIME aritmetics_operation
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    TERM                           shift and go to state 151
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 117

    (97) EXP_PRIME -> - add_operator . TERM EXP_PRIME aritmetics_operation
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    TERM                           shift and go to state 152
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 118

    (100) TERM_PRIME -> * add_operator . FACTOR aritmetics_operation TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    FACTOR                         shift and go to state 153
    VAR_CT                         shift and go to state 60

state 119

    (101) TERM_PRIME -> / add_operator . FACTOR aritmetics_operation TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    FACTOR                         shift and go to state 154
    VAR_CT                         shift and go to state 60

state 120

    (103) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    FOR             reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    PRINT           reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    IF              reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    WHILE           reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)
    RETURN          reduce using rule 103 (FACTOR -> ( EXPRESSION ) .)


state 121

    (51) FUNC_CALL -> ID . ( EXPRESSION FUNC_CALL_PRIME )
    (79) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (22) VARIABLE -> ID . get_variable
    (23) VARIABLE -> ID . [ EXPRESSION ]
    (107) VAR_CT -> ID . add_operand
    (21) get_variable -> .
    (46) add_operand -> .

    (               shift and go to state 155
    .               shift and go to state 156
    [               shift and go to state 158
    =               reduce using rule 21 (get_variable -> .)
    *               reduce using rule 46 (add_operand -> .)
    /               reduce using rule 46 (add_operand -> .)
    +               reduce using rule 46 (add_operand -> .)
    -               reduce using rule 46 (add_operand -> .)
    >               reduce using rule 46 (add_operand -> .)
    <               reduce using rule 46 (add_operand -> .)
    DIFFERENT       reduce using rule 46 (add_operand -> .)
    EQUAL           reduce using rule 46 (add_operand -> .)
    AND             reduce using rule 46 (add_operand -> .)
    OR              reduce using rule 46 (add_operand -> .)
    ;               reduce using rule 46 (add_operand -> .)

    get_variable                   shift and go to state 157
    add_operand                    shift and go to state 73

state 122

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK . }

    }               shift and go to state 159


state 123

    (35) BLOCK -> STATEMENT . BLOCK
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    STATEMENT                      shift and go to state 123
    BLOCK                          shift and go to state 160
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    EXPRESSION                     shift and go to state 127
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 124

    (36) BLOCK -> empty .

    }               reduce using rule 36 (BLOCK -> empty .)
    RETURN          reduce using rule 36 (BLOCK -> empty .)


state 125

    (37) STATEMENT -> ASSIGNATION .
    (78) FOR_STMT -> ASSIGNATION . check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) check_exact_type_for -> .

    FOR             reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    ID              reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    TRUE            reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    FALSE           reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    (               reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    *               reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    /               reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    I_CONST         reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    F_CONST         reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    C_CONST         reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 37 (STATEMENT -> ASSIGNATION .)
    TO              reduce using rule 73 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 161

state 126

    (38) STATEMENT -> FUNC_CALL .

    FOR             reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    ID              reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    TRUE            reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    FALSE           reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    (               reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    *               reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    /               reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    I_CONST         reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    F_CONST         reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    C_CONST         reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 38 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 38 (STATEMENT -> FUNC_CALL .)


state 127

    (39) STATEMENT -> EXPRESSION . ;

    ;               shift and go to state 162


state 128

    (40) STATEMENT -> WRITE . ;

    ;               shift and go to state 163


state 129

    (41) STATEMENT -> CONDITION .

    FOR             reduce using rule 41 (STATEMENT -> CONDITION .)
    ID              reduce using rule 41 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 41 (STATEMENT -> CONDITION .)
    IF              reduce using rule 41 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 41 (STATEMENT -> CONDITION .)
    TRUE            reduce using rule 41 (STATEMENT -> CONDITION .)
    FALSE           reduce using rule 41 (STATEMENT -> CONDITION .)
    (               reduce using rule 41 (STATEMENT -> CONDITION .)
    *               reduce using rule 41 (STATEMENT -> CONDITION .)
    /               reduce using rule 41 (STATEMENT -> CONDITION .)
    I_CONST         reduce using rule 41 (STATEMENT -> CONDITION .)
    F_CONST         reduce using rule 41 (STATEMENT -> CONDITION .)
    C_CONST         reduce using rule 41 (STATEMENT -> CONDITION .)
    }               reduce using rule 41 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 41 (STATEMENT -> CONDITION .)


state 130

    (42) STATEMENT -> WHILE_STMT .

    FOR             reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    ID              reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    TRUE            reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    FALSE           reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    (               reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    *               reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    /               reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    I_CONST         reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    F_CONST         reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    C_CONST         reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 42 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 42 (STATEMENT -> WHILE_STMT .)


state 131

    (43) STATEMENT -> FOR_STMT .

    FOR             reduce using rule 43 (STATEMENT -> FOR_STMT .)
    ID              reduce using rule 43 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 43 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 43 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 43 (STATEMENT -> FOR_STMT .)
    TRUE            reduce using rule 43 (STATEMENT -> FOR_STMT .)
    FALSE           reduce using rule 43 (STATEMENT -> FOR_STMT .)
    (               reduce using rule 43 (STATEMENT -> FOR_STMT .)
    *               reduce using rule 43 (STATEMENT -> FOR_STMT .)
    /               reduce using rule 43 (STATEMENT -> FOR_STMT .)
    I_CONST         reduce using rule 43 (STATEMENT -> FOR_STMT .)
    F_CONST         reduce using rule 43 (STATEMENT -> FOR_STMT .)
    C_CONST         reduce using rule 43 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 43 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 43 (STATEMENT -> FOR_STMT .)


state 132

    (44) STATEMENT -> DESCRIBE_STMT .

    FOR             reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    ID              reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    TRUE            reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    FALSE           reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    (               reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    *               reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    /               reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    I_CONST         reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    F_CONST         reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    C_CONST         reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 44 (STATEMENT -> DESCRIBE_STMT .)


state 133

    (49) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad

    =               shift and go to state 164


state 134

    (50) ASSIGNATION -> FOR . VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]

    ID              shift and go to state 166

    VARIABLE                       shift and go to state 165

state 135

    (56) WRITE -> PRINT . add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> PRINT . add_operator ( TITLE WRITE_PRIME )
    (45) add_operator -> .

    (               reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 167

state 136

    (69) CONDITION -> IF . ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    (               shift and go to state 168


state 137

    (72) WHILE_STMT -> WHILE . ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad

    (               shift and go to state 169


state 138

    (31) PARAM -> TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 31 (PARAM -> TIPO_SIMPLE ID PARAM_PRIME .)


state 139

    (33) PARAM_PRIME -> , . TIPO_SIMPLE ID PARAM_PRIME
    (24) TIPO_SIMPLE -> . INT add_type
    (25) TIPO_SIMPLE -> . FLOAT add_type
    (26) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 170

state 140

    (34) PARAM_PRIME -> empty .

    )               reduce using rule 34 (PARAM_PRIME -> empty .)


state 141

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN VAR_CT }
    (7) VARS_PRIME -> . VARS VARS_PRIME
    (8) VARS_PRIME -> . empty
    (15) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (111) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    VARS_PRIME                     shift and go to state 171
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 142

    (30) FUNCTION -> FUNC VOID ID ( PARAM ) { . VARS_PRIME BLOCK }
    (7) VARS_PRIME -> . VARS VARS_PRIME
    (8) VARS_PRIME -> . empty
    (15) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (16) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (17) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (18) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (111) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)

    VARS_PRIME                     shift and go to state 172
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 143

    (19) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (19) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (20) TIPO_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 46
    ;               reduce using rule 111 (empty -> .)

    TIPO_PRIME                     shift and go to state 173
    empty                          shift and go to state 47

state 144

    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION . ] ;

    ]               shift and go to state 174


state 145

    (82) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 82 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 146

    (85) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 85 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 147

    (90) B_EXP_PRIME -> > add_operator B_EXP . aritmetics_operation
    (80) aritmetics_operation -> .

    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 175

state 148

    (91) B_EXP_PRIME -> < add_operator B_EXP . aritmetics_operation
    (80) aritmetics_operation -> .

    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 176

state 149

    (92) B_EXP_PRIME -> DIFFERENT add_operator B_EXP . aritmetics_operation
    (80) aritmetics_operation -> .

    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 177

state 150

    (93) B_EXP_PRIME -> EQUAL add_operator B_EXP . aritmetics_operation
    (80) aritmetics_operation -> .

    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 178

state 151

    (96) EXP_PRIME -> + add_operator TERM . EXP_PRIME aritmetics_operation
    (96) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (97) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (98) EXP_PRIME -> . empty
    (111) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    EXP_PRIME                      shift and go to state 179
    empty                          shift and go to state 90

state 152

    (97) EXP_PRIME -> - add_operator TERM . EXP_PRIME aritmetics_operation
    (96) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (97) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (98) EXP_PRIME -> . empty
    (111) empty -> .

    +               shift and go to state 88
    -               shift and go to state 89
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    EXP_PRIME                      shift and go to state 180
    empty                          shift and go to state 90

state 153

    (100) TERM_PRIME -> * add_operator FACTOR . aritmetics_operation TERM_PRIME
    (80) aritmetics_operation -> .

    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    +               reduce using rule 80 (aritmetics_operation -> .)
    -               reduce using rule 80 (aritmetics_operation -> .)
    >               reduce using rule 80 (aritmetics_operation -> .)
    <               reduce using rule 80 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 80 (aritmetics_operation -> .)
    EQUAL           reduce using rule 80 (aritmetics_operation -> .)
    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 181

state 154

    (101) TERM_PRIME -> / add_operator FACTOR . aritmetics_operation TERM_PRIME
    (80) aritmetics_operation -> .

    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    +               reduce using rule 80 (aritmetics_operation -> .)
    -               reduce using rule 80 (aritmetics_operation -> .)
    >               reduce using rule 80 (aritmetics_operation -> .)
    <               reduce using rule 80 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 80 (aritmetics_operation -> .)
    EQUAL           reduce using rule 80 (aritmetics_operation -> .)
    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 182

state 155

    (51) FUNC_CALL -> ID ( . EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 183
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 156

    (79) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 184


state 157

    (22) VARIABLE -> ID get_variable .

    =               reduce using rule 22 (VARIABLE -> ID get_variable .)


state 158

    (23) VARIABLE -> ID [ . EXPRESSION ]
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 185
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 159

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } .)


state 160

    (35) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 35 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 35 (BLOCK -> STATEMENT BLOCK .)


state 161

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for . TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    TO              shift and go to state 186


state 162

    (39) STATEMENT -> EXPRESSION ; .

    FOR             reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    ID              reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    PRINT           reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    IF              reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    WHILE           reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    TRUE            reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    FALSE           reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    (               reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    *               reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    /               reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    I_CONST         reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    F_CONST         reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    C_CONST         reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    }               reduce using rule 39 (STATEMENT -> EXPRESSION ; .)
    RETURN          reduce using rule 39 (STATEMENT -> EXPRESSION ; .)


state 163

    (40) STATEMENT -> WRITE ; .

    FOR             reduce using rule 40 (STATEMENT -> WRITE ; .)
    ID              reduce using rule 40 (STATEMENT -> WRITE ; .)
    PRINT           reduce using rule 40 (STATEMENT -> WRITE ; .)
    IF              reduce using rule 40 (STATEMENT -> WRITE ; .)
    WHILE           reduce using rule 40 (STATEMENT -> WRITE ; .)
    TRUE            reduce using rule 40 (STATEMENT -> WRITE ; .)
    FALSE           reduce using rule 40 (STATEMENT -> WRITE ; .)
    (               reduce using rule 40 (STATEMENT -> WRITE ; .)
    *               reduce using rule 40 (STATEMENT -> WRITE ; .)
    /               reduce using rule 40 (STATEMENT -> WRITE ; .)
    I_CONST         reduce using rule 40 (STATEMENT -> WRITE ; .)
    F_CONST         reduce using rule 40 (STATEMENT -> WRITE ; .)
    C_CONST         reduce using rule 40 (STATEMENT -> WRITE ; .)
    }               reduce using rule 40 (STATEMENT -> WRITE ; .)
    RETURN          reduce using rule 40 (STATEMENT -> WRITE ; .)


state 164

    (49) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 187

state 165

    (50) ASSIGNATION -> FOR VARIABLE . = add_operator EXPRESSION add_assignation_for_quad

    =               shift and go to state 188


state 166

    (22) VARIABLE -> ID . get_variable
    (23) VARIABLE -> ID . [ EXPRESSION ]
    (21) get_variable -> .

    [               shift and go to state 158
    =               reduce using rule 21 (get_variable -> .)

    get_variable                   shift and go to state 157

state 167

    (56) WRITE -> PRINT add_operator . ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> PRINT add_operator . ( TITLE WRITE_PRIME )

    (               shift and go to state 189


state 168

    (69) CONDITION -> IF ( . EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 190
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 169

    (72) WHILE_STMT -> WHILE ( . append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (68) append_jump -> .

    TRUE            reduce using rule 68 (append_jump -> .)
    FALSE           reduce using rule 68 (append_jump -> .)
    (               reduce using rule 68 (append_jump -> .)
    *               reduce using rule 68 (append_jump -> .)
    /               reduce using rule 68 (append_jump -> .)
    ID              reduce using rule 68 (append_jump -> .)
    I_CONST         reduce using rule 68 (append_jump -> .)
    F_CONST         reduce using rule 68 (append_jump -> .)
    C_CONST         reduce using rule 68 (append_jump -> .)

    append_jump                    shift and go to state 191

state 170

    (33) PARAM_PRIME -> , TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 192


state 171

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN VAR_CT }
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    RETURN          reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 193
    EXPRESSION                     shift and go to state 127
    VAR_CT                         shift and go to state 60
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57

state 172

    (30) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME . BLOCK }
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 194
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    EXPRESSION                     shift and go to state 127
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 173

    (19) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 19 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 174

    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] . ;

    ;               shift and go to state 195


state 175

    (90) B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 90 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)


state 176

    (91) B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 91 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)


state 177

    (92) B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 92 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)


state 178

    (93) B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 93 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)


state 179

    (96) EXP_PRIME -> + add_operator TERM EXP_PRIME . aritmetics_operation
    (80) aritmetics_operation -> .

    >               reduce using rule 80 (aritmetics_operation -> .)
    <               reduce using rule 80 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 80 (aritmetics_operation -> .)
    EQUAL           reduce using rule 80 (aritmetics_operation -> .)
    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 196

state 180

    (97) EXP_PRIME -> - add_operator TERM EXP_PRIME . aritmetics_operation
    (80) aritmetics_operation -> .

    >               reduce using rule 80 (aritmetics_operation -> .)
    <               reduce using rule 80 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 80 (aritmetics_operation -> .)
    EQUAL           reduce using rule 80 (aritmetics_operation -> .)
    AND             reduce using rule 80 (aritmetics_operation -> .)
    OR              reduce using rule 80 (aritmetics_operation -> .)
    ]               reduce using rule 80 (aritmetics_operation -> .)
    )               reduce using rule 80 (aritmetics_operation -> .)
    ;               reduce using rule 80 (aritmetics_operation -> .)
    ,               reduce using rule 80 (aritmetics_operation -> .)
    TO              reduce using rule 80 (aritmetics_operation -> .)
    FOR             reduce using rule 80 (aritmetics_operation -> .)
    ID              reduce using rule 80 (aritmetics_operation -> .)
    PRINT           reduce using rule 80 (aritmetics_operation -> .)
    IF              reduce using rule 80 (aritmetics_operation -> .)
    WHILE           reduce using rule 80 (aritmetics_operation -> .)
    TRUE            reduce using rule 80 (aritmetics_operation -> .)
    FALSE           reduce using rule 80 (aritmetics_operation -> .)
    (               reduce using rule 80 (aritmetics_operation -> .)
    *               reduce using rule 80 (aritmetics_operation -> .)
    /               reduce using rule 80 (aritmetics_operation -> .)
    I_CONST         reduce using rule 80 (aritmetics_operation -> .)
    F_CONST         reduce using rule 80 (aritmetics_operation -> .)
    C_CONST         reduce using rule 80 (aritmetics_operation -> .)
    }               reduce using rule 80 (aritmetics_operation -> .)
    RETURN          reduce using rule 80 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 197

state 181

    (100) TERM_PRIME -> * add_operator FACTOR aritmetics_operation . TERM_PRIME
    (100) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (101) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (102) TERM_PRIME -> . empty
    (111) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 111 (empty -> .)
    -               reduce using rule 111 (empty -> .)
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

  ! *               [ reduce using rule 111 (empty -> .) ]
  ! /               [ reduce using rule 111 (empty -> .) ]

    TERM_PRIME                     shift and go to state 198
    empty                          shift and go to state 94

state 182

    (101) TERM_PRIME -> / add_operator FACTOR aritmetics_operation . TERM_PRIME
    (100) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (101) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (102) TERM_PRIME -> . empty
    (111) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 92
    /               shift and go to state 93
    +               reduce using rule 111 (empty -> .)
    -               reduce using rule 111 (empty -> .)
    >               reduce using rule 111 (empty -> .)
    <               reduce using rule 111 (empty -> .)
    DIFFERENT       reduce using rule 111 (empty -> .)
    EQUAL           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    ]               reduce using rule 111 (empty -> .)
    )               reduce using rule 111 (empty -> .)
    ;               reduce using rule 111 (empty -> .)
    ,               reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

  ! *               [ reduce using rule 111 (empty -> .) ]
  ! /               [ reduce using rule 111 (empty -> .) ]

    TERM_PRIME                     shift and go to state 199
    empty                          shift and go to state 94

state 183

    (51) FUNC_CALL -> ID ( EXPRESSION . FUNC_CALL_PRIME )
    (52) FUNC_CALL_PRIME -> . , EXPRESSION FUNC_CALL_PRIME
    (53) FUNC_CALL_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 201
    )               reduce using rule 111 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 200
    empty                          shift and go to state 202

state 184

    (79) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 203


state 185

    (23) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 204


state 186

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO . ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    (               shift and go to state 205


state 187

    (49) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 206
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 188

    (50) ASSIGNATION -> FOR VARIABLE = . add_operator EXPRESSION add_assignation_for_quad
    (45) add_operator -> .

    TRUE            reduce using rule 45 (add_operator -> .)
    FALSE           reduce using rule 45 (add_operator -> .)
    (               reduce using rule 45 (add_operator -> .)
    *               reduce using rule 45 (add_operator -> .)
    /               reduce using rule 45 (add_operator -> .)
    ID              reduce using rule 45 (add_operator -> .)
    I_CONST         reduce using rule 45 (add_operator -> .)
    F_CONST         reduce using rule 45 (add_operator -> .)
    C_CONST         reduce using rule 45 (add_operator -> .)

    add_operator                   shift and go to state 207

state 189

    (56) WRITE -> PRINT add_operator ( . EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> PRINT add_operator ( . TITLE WRITE_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 209
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 208
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 190

    (69) CONDITION -> IF ( EXPRESSION . pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (66) pop_operand -> .

    )               reduce using rule 66 (pop_operand -> .)

    pop_operand                    shift and go to state 210

state 191

    (72) WHILE_STMT -> WHILE ( append_jump . EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 211
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 192

    (33) PARAM_PRIME -> , TIPO_SIMPLE ID . PARAM_PRIME
    (33) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (34) PARAM_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 139
    )               reduce using rule 111 (empty -> .)

    PARAM_PRIME                    shift and go to state 212
    empty                          shift and go to state 140

state 193

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN VAR_CT }

    RETURN          shift and go to state 213


state 194

    (30) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK . }

    }               shift and go to state 214


state 195

    (18) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .

    VAR             reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FUNC            reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    VOID            reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FOR             reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    ID              reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    PRINT           reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    IF              reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    WHILE           reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    TRUE            reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FALSE           reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    (               reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    *               reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    /               reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    }               reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    RETURN          reduce using rule 18 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)


state 196

    (96) EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 96 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)


state 197

    (97) EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 97 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)


state 198

    (100) TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 100 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 199

    (101) TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 101 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 200

    (51) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME . )

    )               shift and go to state 215


state 201

    (52) FUNC_CALL_PRIME -> , . EXPRESSION FUNC_CALL_PRIME
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 216
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 202

    (53) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 53 (FUNC_CALL_PRIME -> empty .)


state 203

    (79) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 217


state 204

    (23) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 23 (VARIABLE -> ID [ EXPRESSION ] .)


state 205

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( . EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 218
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 206

    (49) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 219


state 207

    (50) ASSIGNATION -> FOR VARIABLE = add_operator . EXPRESSION add_assignation_for_quad
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 220
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 208

    (56) WRITE -> PRINT add_operator ( EXPRESSION . print_quad WRITE_PRIME )
    (54) print_quad -> .

    ,               reduce using rule 54 (print_quad -> .)
    )               reduce using rule 54 (print_quad -> .)

    print_quad                     shift and go to state 221

state 209

    (57) WRITE -> PRINT add_operator ( TITLE . WRITE_PRIME )
    (58) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (60) WRITE_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 223
    )               reduce using rule 111 (empty -> .)

    WRITE_PRIME                    shift and go to state 222
    empty                          shift and go to state 224

state 210

    (69) CONDITION -> IF ( EXPRESSION pop_operand . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (67) pop_type -> .

    )               reduce using rule 67 (pop_type -> .)

    pop_type                       shift and go to state 225

state 211

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION . pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (66) pop_operand -> .

    )               reduce using rule 66 (pop_operand -> .)

    pop_operand                    shift and go to state 226

state 212

    (33) PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 33 (PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .)


state 213

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . EXPRESSION }
    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . VAR_CT }
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT

    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61

    EXPRESSION                     shift and go to state 227
    VAR_CT                         shift and go to state 228
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57

state 214

    (30) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .

    FUNC            reduce using rule 30 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)
    VOID            reduce using rule 30 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)


state 215

    (51) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .

    FOR             reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    ID              reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    PRINT           reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    IF              reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    WHILE           reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    TRUE            reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FALSE           reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    (               reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    *               reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    /               reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    I_CONST         reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    F_CONST         reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    C_CONST         reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    }               reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    RETURN          reduce using rule 51 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)


state 216

    (52) FUNC_CALL_PRIME -> , EXPRESSION . FUNC_CALL_PRIME
    (52) FUNC_CALL_PRIME -> . , EXPRESSION FUNC_CALL_PRIME
    (53) FUNC_CALL_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 201
    )               reduce using rule 111 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 229
    empty                          shift and go to state 202

state 217

    (79) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    FOR             reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    ID              reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    TRUE            reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FALSE           reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    (               reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    *               reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    /               reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    I_CONST         reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    F_CONST         reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    C_CONST         reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 79 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 218

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION . check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) check_exact_type_for -> .

    )               reduce using rule 73 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 230

state 219

    (49) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (47) add_assignation_quad -> .

    TO              reduce using rule 47 (add_assignation_quad -> .)
    FOR             reduce using rule 47 (add_assignation_quad -> .)
    ID              reduce using rule 47 (add_assignation_quad -> .)
    PRINT           reduce using rule 47 (add_assignation_quad -> .)
    IF              reduce using rule 47 (add_assignation_quad -> .)
    WHILE           reduce using rule 47 (add_assignation_quad -> .)
    TRUE            reduce using rule 47 (add_assignation_quad -> .)
    FALSE           reduce using rule 47 (add_assignation_quad -> .)
    (               reduce using rule 47 (add_assignation_quad -> .)
    *               reduce using rule 47 (add_assignation_quad -> .)
    /               reduce using rule 47 (add_assignation_quad -> .)
    I_CONST         reduce using rule 47 (add_assignation_quad -> .)
    F_CONST         reduce using rule 47 (add_assignation_quad -> .)
    C_CONST         reduce using rule 47 (add_assignation_quad -> .)
    }               reduce using rule 47 (add_assignation_quad -> .)
    RETURN          reduce using rule 47 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 231

state 220

    (50) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION . add_assignation_for_quad
    (48) add_assignation_for_quad -> .

    TO              reduce using rule 48 (add_assignation_for_quad -> .)
    FOR             reduce using rule 48 (add_assignation_for_quad -> .)
    ID              reduce using rule 48 (add_assignation_for_quad -> .)
    PRINT           reduce using rule 48 (add_assignation_for_quad -> .)
    IF              reduce using rule 48 (add_assignation_for_quad -> .)
    WHILE           reduce using rule 48 (add_assignation_for_quad -> .)
    TRUE            reduce using rule 48 (add_assignation_for_quad -> .)
    FALSE           reduce using rule 48 (add_assignation_for_quad -> .)
    (               reduce using rule 48 (add_assignation_for_quad -> .)
    *               reduce using rule 48 (add_assignation_for_quad -> .)
    /               reduce using rule 48 (add_assignation_for_quad -> .)
    I_CONST         reduce using rule 48 (add_assignation_for_quad -> .)
    F_CONST         reduce using rule 48 (add_assignation_for_quad -> .)
    C_CONST         reduce using rule 48 (add_assignation_for_quad -> .)
    }               reduce using rule 48 (add_assignation_for_quad -> .)
    RETURN          reduce using rule 48 (add_assignation_for_quad -> .)

    add_assignation_for_quad       shift and go to state 232

state 221

    (56) WRITE -> PRINT add_operator ( EXPRESSION print_quad . WRITE_PRIME )
    (58) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (60) WRITE_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 223
    )               reduce using rule 111 (empty -> .)

    WRITE_PRIME                    shift and go to state 233
    empty                          shift and go to state 224

state 222

    (57) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME . )

    )               shift and go to state 234


state 223

    (58) WRITE_PRIME -> , . add_print_operator EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> , . add_print_operator TITLE print_quad WRITE_PRIME
    (55) add_print_operator -> .

    TITLE           reduce using rule 55 (add_print_operator -> .)
    TRUE            reduce using rule 55 (add_print_operator -> .)
    FALSE           reduce using rule 55 (add_print_operator -> .)
    (               reduce using rule 55 (add_print_operator -> .)
    *               reduce using rule 55 (add_print_operator -> .)
    /               reduce using rule 55 (add_print_operator -> .)
    ID              reduce using rule 55 (add_print_operator -> .)
    I_CONST         reduce using rule 55 (add_print_operator -> .)
    F_CONST         reduce using rule 55 (add_print_operator -> .)
    C_CONST         reduce using rule 55 (add_print_operator -> .)

    add_print_operator             shift and go to state 235

state 224

    (60) WRITE_PRIME -> empty .

    )               reduce using rule 60 (WRITE_PRIME -> empty .)


state 225

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    )               shift and go to state 236


state 226

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (67) pop_type -> .

    )               reduce using rule 67 (pop_type -> .)

    pop_type                       shift and go to state 237

state 227

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION . }

    }               shift and go to state 238


state 228

    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT . }
    (106) FACTOR -> VAR_CT .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 239
    *               reduce using rule 106 (FACTOR -> VAR_CT .)
    /               reduce using rule 106 (FACTOR -> VAR_CT .)
    +               reduce using rule 106 (FACTOR -> VAR_CT .)
    -               reduce using rule 106 (FACTOR -> VAR_CT .)
    >               reduce using rule 106 (FACTOR -> VAR_CT .)
    <               reduce using rule 106 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 106 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 106 (FACTOR -> VAR_CT .)
    AND             reduce using rule 106 (FACTOR -> VAR_CT .)
    OR              reduce using rule 106 (FACTOR -> VAR_CT .)

  ! }               [ reduce using rule 106 (FACTOR -> VAR_CT .) ]


state 229

    (52) FUNC_CALL_PRIME -> , EXPRESSION FUNC_CALL_PRIME .

    )               reduce using rule 52 (FUNC_CALL_PRIME -> , EXPRESSION FUNC_CALL_PRIME .)


state 230

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for . add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (74) add_final_counter_for -> .

    )               reduce using rule 74 (add_final_counter_for -> .)

    add_final_counter_for          shift and go to state 240

state 231

    (49) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    TO              reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    ID              reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    TRUE            reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FALSE           reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    (               reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    *               reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    /               reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    I_CONST         reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    F_CONST         reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    C_CONST         reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 49 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 232

    (50) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .

    TO              reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FOR             reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    ID              reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    PRINT           reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    IF              reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    WHILE           reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    TRUE            reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FALSE           reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    (               reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    *               reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    /               reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    I_CONST         reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    F_CONST         reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    C_CONST         reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    }               reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    RETURN          reduce using rule 50 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)


state 233

    (56) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME . )

    )               shift and go to state 241


state 234

    (57) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .

    ;               reduce using rule 57 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)


state 235

    (58) WRITE_PRIME -> , add_print_operator . EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> , add_print_operator . TITLE print_quad WRITE_PRIME
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 243
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    ID              shift and go to state 49
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 242
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 236

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    {               shift and go to state 244


state 237

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad

    )               shift and go to state 245


state 238

    (28) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .

    FUNC            reduce using rule 28 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)
    VOID            reduce using rule 28 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)


state 239

    (29) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .

    FUNC            reduce using rule 29 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)
    VOID            reduce using rule 29 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)


state 240

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for . check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (76) check_boolean_expression_for -> .

    )               reduce using rule 76 (check_boolean_expression_for -> .)

    check_boolean_expression_for   shift and go to state 246

state 241

    (56) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .

    ;               reduce using rule 56 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)


state 242

    (58) WRITE_PRIME -> , add_print_operator EXPRESSION . print_quad WRITE_PRIME
    (54) print_quad -> .

    ,               reduce using rule 54 (print_quad -> .)
    )               reduce using rule 54 (print_quad -> .)

    print_quad                     shift and go to state 247

state 243

    (59) WRITE_PRIME -> , add_print_operator TITLE . print_quad WRITE_PRIME
    (54) print_quad -> .

    ,               reduce using rule 54 (print_quad -> .)
    )               reduce using rule 54 (print_quad -> .)

    print_quad                     shift and go to state 248

state 244

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (61) go_to_false_quad -> .

    FOR             reduce using rule 61 (go_to_false_quad -> .)
    ID              reduce using rule 61 (go_to_false_quad -> .)
    PRINT           reduce using rule 61 (go_to_false_quad -> .)
    IF              reduce using rule 61 (go_to_false_quad -> .)
    WHILE           reduce using rule 61 (go_to_false_quad -> .)
    TRUE            reduce using rule 61 (go_to_false_quad -> .)
    FALSE           reduce using rule 61 (go_to_false_quad -> .)
    (               reduce using rule 61 (go_to_false_quad -> .)
    *               reduce using rule 61 (go_to_false_quad -> .)
    /               reduce using rule 61 (go_to_false_quad -> .)
    I_CONST         reduce using rule 61 (go_to_false_quad -> .)
    F_CONST         reduce using rule 61 (go_to_false_quad -> .)
    C_CONST         reduce using rule 61 (go_to_false_quad -> .)
    }               reduce using rule 61 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 249

state 245

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad

    {               shift and go to state 250


state 246

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for . ) generate_for_quad DO { BLOCK } end_for

    )               shift and go to state 251


state 247

    (58) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad . WRITE_PRIME
    (58) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (60) WRITE_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 223
    )               reduce using rule 111 (empty -> .)

    WRITE_PRIME                    shift and go to state 252
    empty                          shift and go to state 224

state 248

    (59) WRITE_PRIME -> , add_print_operator TITLE print_quad . WRITE_PRIME
    (58) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (59) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (60) WRITE_PRIME -> . empty
    (111) empty -> .

    ,               shift and go to state 223
    )               reduce using rule 111 (empty -> .)

    WRITE_PRIME                    shift and go to state 253
    empty                          shift and go to state 224

state 249

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad ELSE_STMT
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 127
    BLOCK                          shift and go to state 254
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 250

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (61) go_to_false_quad -> .

    FOR             reduce using rule 61 (go_to_false_quad -> .)
    ID              reduce using rule 61 (go_to_false_quad -> .)
    PRINT           reduce using rule 61 (go_to_false_quad -> .)
    IF              reduce using rule 61 (go_to_false_quad -> .)
    WHILE           reduce using rule 61 (go_to_false_quad -> .)
    TRUE            reduce using rule 61 (go_to_false_quad -> .)
    FALSE           reduce using rule 61 (go_to_false_quad -> .)
    (               reduce using rule 61 (go_to_false_quad -> .)
    *               reduce using rule 61 (go_to_false_quad -> .)
    /               reduce using rule 61 (go_to_false_quad -> .)
    I_CONST         reduce using rule 61 (go_to_false_quad -> .)
    F_CONST         reduce using rule 61 (go_to_false_quad -> .)
    C_CONST         reduce using rule 61 (go_to_false_quad -> .)
    }               reduce using rule 61 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 255

state 251

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) . generate_for_quad DO { BLOCK } end_for
    (75) generate_for_quad -> .

    DO              reduce using rule 75 (generate_for_quad -> .)

    generate_for_quad              shift and go to state 256

state 252

    (58) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .

    )               reduce using rule 58 (WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .)


state 253

    (59) WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .

    )               reduce using rule 59 (WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .)


state 254

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad ELSE_STMT

    }               shift and go to state 257


state 255

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad go_to_quad
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    EXPRESSION                     shift and go to state 127
    BLOCK                          shift and go to state 258
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 256

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad . DO { BLOCK } end_for

    DO              shift and go to state 259


state 257

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad ELSE_STMT
    (62) fill_go_to_false_quad -> .

    ELSE            reduce using rule 62 (fill_go_to_false_quad -> .)
    FOR             reduce using rule 62 (fill_go_to_false_quad -> .)
    ID              reduce using rule 62 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 62 (fill_go_to_false_quad -> .)
    IF              reduce using rule 62 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 62 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 62 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 62 (fill_go_to_false_quad -> .)
    (               reduce using rule 62 (fill_go_to_false_quad -> .)
    *               reduce using rule 62 (fill_go_to_false_quad -> .)
    /               reduce using rule 62 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    }               reduce using rule 62 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 62 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 260

state 258

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad go_to_quad

    }               shift and go to state 261


state 259

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO . { BLOCK } end_for

    {               shift and go to state 262


state 260

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad . ELSE_STMT
    (70) ELSE_STMT -> . ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
    (71) ELSE_STMT -> . empty
    (111) empty -> .

    ELSE            shift and go to state 264
    FOR             reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    (               reduce using rule 111 (empty -> .)
    *               reduce using rule 111 (empty -> .)
    /               reduce using rule 111 (empty -> .)
    I_CONST         reduce using rule 111 (empty -> .)
    F_CONST         reduce using rule 111 (empty -> .)
    C_CONST         reduce using rule 111 (empty -> .)
    }               reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)

    ELSE_STMT                      shift and go to state 263
    empty                          shift and go to state 265

state 261

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad go_to_quad
    (62) fill_go_to_false_quad -> .

    FOR             reduce using rule 62 (fill_go_to_false_quad -> .)
    ID              reduce using rule 62 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 62 (fill_go_to_false_quad -> .)
    IF              reduce using rule 62 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 62 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 62 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 62 (fill_go_to_false_quad -> .)
    (               reduce using rule 62 (fill_go_to_false_quad -> .)
    *               reduce using rule 62 (fill_go_to_false_quad -> .)
    /               reduce using rule 62 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 62 (fill_go_to_false_quad -> .)
    }               reduce using rule 62 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 62 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 266

state 262

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { . BLOCK } end_for
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    ASSIGNATION                    shift and go to state 125
    EXPRESSION                     shift and go to state 127
    BLOCK                          shift and go to state 267
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    FUNC_CALL                      shift and go to state 126
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 263

    (69) CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .

    FOR             reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    ID              reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    PRINT           reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    IF              reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    WHILE           reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    TRUE            reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    FALSE           reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    (               reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    *               reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    /               reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    I_CONST         reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    F_CONST         reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    C_CONST         reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    }               reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    RETURN          reduce using rule 69 (CONDITION -> IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)


state 264

    (70) ELSE_STMT -> ELSE . { go_to_true_quad BLOCK } fill_go_to_true_quad

    {               shift and go to state 268


state 265

    (71) ELSE_STMT -> empty .

    FOR             reduce using rule 71 (ELSE_STMT -> empty .)
    ID              reduce using rule 71 (ELSE_STMT -> empty .)
    PRINT           reduce using rule 71 (ELSE_STMT -> empty .)
    IF              reduce using rule 71 (ELSE_STMT -> empty .)
    WHILE           reduce using rule 71 (ELSE_STMT -> empty .)
    TRUE            reduce using rule 71 (ELSE_STMT -> empty .)
    FALSE           reduce using rule 71 (ELSE_STMT -> empty .)
    (               reduce using rule 71 (ELSE_STMT -> empty .)
    *               reduce using rule 71 (ELSE_STMT -> empty .)
    /               reduce using rule 71 (ELSE_STMT -> empty .)
    I_CONST         reduce using rule 71 (ELSE_STMT -> empty .)
    F_CONST         reduce using rule 71 (ELSE_STMT -> empty .)
    C_CONST         reduce using rule 71 (ELSE_STMT -> empty .)
    }               reduce using rule 71 (ELSE_STMT -> empty .)
    RETURN          reduce using rule 71 (ELSE_STMT -> empty .)


state 266

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad . go_to_quad
    (65) go_to_quad -> .

    FOR             reduce using rule 65 (go_to_quad -> .)
    ID              reduce using rule 65 (go_to_quad -> .)
    PRINT           reduce using rule 65 (go_to_quad -> .)
    IF              reduce using rule 65 (go_to_quad -> .)
    WHILE           reduce using rule 65 (go_to_quad -> .)
    TRUE            reduce using rule 65 (go_to_quad -> .)
    FALSE           reduce using rule 65 (go_to_quad -> .)
    (               reduce using rule 65 (go_to_quad -> .)
    *               reduce using rule 65 (go_to_quad -> .)
    /               reduce using rule 65 (go_to_quad -> .)
    I_CONST         reduce using rule 65 (go_to_quad -> .)
    F_CONST         reduce using rule 65 (go_to_quad -> .)
    C_CONST         reduce using rule 65 (go_to_quad -> .)
    }               reduce using rule 65 (go_to_quad -> .)
    RETURN          reduce using rule 65 (go_to_quad -> .)

    go_to_quad                     shift and go to state 269

state 267

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK . } end_for

    }               shift and go to state 270


state 268

    (70) ELSE_STMT -> ELSE { . go_to_true_quad BLOCK } fill_go_to_true_quad
    (63) go_to_true_quad -> .

    FOR             reduce using rule 63 (go_to_true_quad -> .)
    ID              reduce using rule 63 (go_to_true_quad -> .)
    PRINT           reduce using rule 63 (go_to_true_quad -> .)
    IF              reduce using rule 63 (go_to_true_quad -> .)
    WHILE           reduce using rule 63 (go_to_true_quad -> .)
    TRUE            reduce using rule 63 (go_to_true_quad -> .)
    FALSE           reduce using rule 63 (go_to_true_quad -> .)
    (               reduce using rule 63 (go_to_true_quad -> .)
    *               reduce using rule 63 (go_to_true_quad -> .)
    /               reduce using rule 63 (go_to_true_quad -> .)
    I_CONST         reduce using rule 63 (go_to_true_quad -> .)
    F_CONST         reduce using rule 63 (go_to_true_quad -> .)
    C_CONST         reduce using rule 63 (go_to_true_quad -> .)
    }               reduce using rule 63 (go_to_true_quad -> .)

    go_to_true_quad                shift and go to state 271

state 269

    (72) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .

    FOR             reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    ID              reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    PRINT           reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    IF              reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    WHILE           reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    TRUE            reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    FALSE           reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    (               reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    *               reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    /               reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    I_CONST         reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    F_CONST         reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    C_CONST         reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    }               reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)
    RETURN          reduce using rule 72 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad .)


state 270

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } . end_for
    (77) end_for -> .

    FOR             reduce using rule 77 (end_for -> .)
    ID              reduce using rule 77 (end_for -> .)
    PRINT           reduce using rule 77 (end_for -> .)
    IF              reduce using rule 77 (end_for -> .)
    WHILE           reduce using rule 77 (end_for -> .)
    TRUE            reduce using rule 77 (end_for -> .)
    FALSE           reduce using rule 77 (end_for -> .)
    (               reduce using rule 77 (end_for -> .)
    *               reduce using rule 77 (end_for -> .)
    /               reduce using rule 77 (end_for -> .)
    I_CONST         reduce using rule 77 (end_for -> .)
    F_CONST         reduce using rule 77 (end_for -> .)
    C_CONST         reduce using rule 77 (end_for -> .)
    }               reduce using rule 77 (end_for -> .)
    RETURN          reduce using rule 77 (end_for -> .)

    end_for                        shift and go to state 272

state 271

    (70) ELSE_STMT -> ELSE { go_to_true_quad . BLOCK } fill_go_to_true_quad
    (35) BLOCK -> . STATEMENT BLOCK
    (36) BLOCK -> . empty
    (37) STATEMENT -> . ASSIGNATION
    (38) STATEMENT -> . FUNC_CALL
    (39) STATEMENT -> . EXPRESSION ;
    (40) STATEMENT -> . WRITE ;
    (41) STATEMENT -> . CONDITION
    (42) STATEMENT -> . WHILE_STMT
    (43) STATEMENT -> . FOR_STMT
    (44) STATEMENT -> . DESCRIBE_STMT
    (111) empty -> .
    (49) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (50) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (51) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (81) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (57) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (69) CONDITION -> . IF ( EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (72) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_operand pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad
    (78) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (79) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (22) VARIABLE -> . ID get_variable
    (23) VARIABLE -> . ID [ EXPRESSION ]
    (84) AND_EXP -> . B_EXP AND_EXP_PRIME
    (87) B_EXP -> . TRUE
    (88) B_EXP -> . FALSE
    (89) B_EXP -> . EXP B_EXP_PRIME
    (95) EXP -> . TERM EXP_PRIME
    (99) TERM -> . FACTOR TERM_PRIME
    (103) FACTOR -> . ( EXPRESSION )
    (104) FACTOR -> . * VAR_CT
    (105) FACTOR -> . / VAR_CT
    (106) FACTOR -> . VAR_CT
    (107) VAR_CT -> . ID add_operand
    (108) VAR_CT -> . I_CONST add_operand
    (109) VAR_CT -> . F_CONST add_operand
    (110) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 111 (empty -> .)
    FOR             shift and go to state 134
    ID              shift and go to state 121
    PRINT           shift and go to state 135
    IF              shift and go to state 136
    WHILE           shift and go to state 137
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54
    (               shift and go to state 58
    *               shift and go to state 59
    /               shift and go to state 61
    I_CONST         shift and go to state 62
    F_CONST         shift and go to state 63
    C_CONST         shift and go to state 64

    BLOCK                          shift and go to state 273
    STATEMENT                      shift and go to state 123
    empty                          shift and go to state 124
    ASSIGNATION                    shift and go to state 125
    FUNC_CALL                      shift and go to state 126
    EXPRESSION                     shift and go to state 127
    WRITE                          shift and go to state 128
    CONDITION                      shift and go to state 129
    WHILE_STMT                     shift and go to state 130
    FOR_STMT                       shift and go to state 131
    DESCRIBE_STMT                  shift and go to state 132
    VARIABLE                       shift and go to state 133
    AND_EXP                        shift and go to state 51
    B_EXP                          shift and go to state 52
    EXP                            shift and go to state 55
    TERM                           shift and go to state 56
    FACTOR                         shift and go to state 57
    VAR_CT                         shift and go to state 60

state 272

    (78) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .

    FOR             reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    ID              reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    PRINT           reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    IF              reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    WHILE           reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    TRUE            reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FALSE           reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    (               reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    *               reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    /               reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    I_CONST         reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    F_CONST         reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    C_CONST         reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    }               reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    RETURN          reduce using rule 78 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)


state 273

    (70) ELSE_STMT -> ELSE { go_to_true_quad BLOCK . } fill_go_to_true_quad

    }               shift and go to state 274


state 274

    (70) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } . fill_go_to_true_quad
    (64) fill_go_to_true_quad -> .

    FOR             reduce using rule 64 (fill_go_to_true_quad -> .)
    ID              reduce using rule 64 (fill_go_to_true_quad -> .)
    PRINT           reduce using rule 64 (fill_go_to_true_quad -> .)
    IF              reduce using rule 64 (fill_go_to_true_quad -> .)
    WHILE           reduce using rule 64 (fill_go_to_true_quad -> .)
    TRUE            reduce using rule 64 (fill_go_to_true_quad -> .)
    FALSE           reduce using rule 64 (fill_go_to_true_quad -> .)
    (               reduce using rule 64 (fill_go_to_true_quad -> .)
    *               reduce using rule 64 (fill_go_to_true_quad -> .)
    /               reduce using rule 64 (fill_go_to_true_quad -> .)
    I_CONST         reduce using rule 64 (fill_go_to_true_quad -> .)
    F_CONST         reduce using rule 64 (fill_go_to_true_quad -> .)
    C_CONST         reduce using rule 64 (fill_go_to_true_quad -> .)
    }               reduce using rule 64 (fill_go_to_true_quad -> .)
    RETURN          reduce using rule 64 (fill_go_to_true_quad -> .)

    fill_go_to_true_quad           shift and go to state 275

state 275

    (70) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .

    FOR             reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    ID              reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    PRINT           reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    IF              reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    WHILE           reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    TRUE            reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FALSE           reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    (               reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    *               reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    /               reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    I_CONST         reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    F_CONST         reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    C_CONST         reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    }               reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    RETURN          reduce using rule 70 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 57 resolved as shift
WARNING: shift/reduce conflict for / in state 57 resolved as shift
WARNING: shift/reduce conflict for * in state 181 resolved as shift
WARNING: shift/reduce conflict for / in state 181 resolved as shift
WARNING: shift/reduce conflict for * in state 182 resolved as shift
WARNING: shift/reduce conflict for / in state 182 resolved as shift
WARNING: shift/reduce conflict for } in state 228 resolved as shift
