Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
Rule 2     go_to_main -> <empty>
Rule 3     empty_global_variables_table -> <empty>
Rule 4     empty_local_variables_table -> <empty>
Rule 5     fill_go_to_main_quad -> <empty>
Rule 6     add_id -> <empty>
Rule 7     save_ids -> <empty>
Rule 8     save_parameter -> <empty>
Rule 9     save_function -> <empty>
Rule 10    VARS_PRIME -> VARS VARS_PRIME
Rule 11    VARS_PRIME -> empty
Rule 12    FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 13    FUNCTION_PRIME -> empty
Rule 14    FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 15    FUNC_PRIME -> empty
Rule 16    add_type -> <empty>
Rule 17    add_current_type -> <empty>
Rule 18    check_for_array_length -> <empty>
Rule 19    save_array -> <empty>
Rule 20    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 21    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 22    VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
Rule 23    VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
Rule 24    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 25    TIPO_PRIME -> empty
Rule 26    get_variable -> <empty>
Rule 27    ver_quad_dimension_one -> <empty>
Rule 28    VARIABLE -> ID get_variable
Rule 29    VARIABLE -> ID add_id [ EXPRESSION ] ver_quad_dimension_one
Rule 30    TIPO_SIMPLE -> INT add_type
Rule 31    TIPO_SIMPLE -> FLOAT add_type
Rule 32    TIPO_SIMPLE -> CHAR add_type
Rule 33    TIPO_COMP -> DATAFRAME
Rule 34    add_function_type -> <empty>
Rule 35    save_function_as_variable -> <empty>
Rule 36    return_quad -> <empty>
Rule 37    FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
Rule 38    FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
Rule 39    add_parameters -> <empty>
Rule 40    PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
Rule 41    PARAM -> empty
Rule 42    PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
Rule 43    PARAM_PRIME -> empty
Rule 44    BLOCK -> STATEMENT BLOCK
Rule 45    BLOCK -> empty
Rule 46    STATEMENT -> ASSIGNATION
Rule 47    STATEMENT -> FUNC_CALL
Rule 48    STATEMENT -> EXPRESSION ;
Rule 49    STATEMENT -> WRITE ;
Rule 50    STATEMENT -> CONDITION
Rule 51    STATEMENT -> WHILE_STMT
Rule 52    STATEMENT -> FOR_STMT
Rule 53    STATEMENT -> DESCRIBE_STMT
Rule 54    add_operator -> <empty>
Rule 55    add_operand -> <empty>
Rule 56    add_assignation_quad -> <empty>
Rule 57    add_assignation_for_quad -> <empty>
Rule 58    functions_assignation -> <empty>
Rule 59    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 60    ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
Rule 61    ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
Rule 62    era_quad -> <empty>
Rule 63    param_quad -> <empty>
Rule 64    go_sub_quad -> <empty>
Rule 65    FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
Rule 66    FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME
Rule 67    FUNC_CALL_PRIME -> empty
Rule 68    print_quad -> <empty>
Rule 69    add_print_operator -> <empty>
Rule 70    WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
Rule 71    WRITE -> PRINT add_operator ( TITLE WRITE_PRIME )
Rule 72    WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME
Rule 73    WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME
Rule 74    WRITE_PRIME -> empty
Rule 75    go_to_false_quad -> <empty>
Rule 76    fill_go_to_false_quad -> <empty>
Rule 77    fill_go_to_false_quad_if -> <empty>
Rule 78    go_to_true_quad -> <empty>
Rule 79    fill_go_to_true_quad -> <empty>
Rule 80    go_to_quad -> <empty>
Rule 81    pop_operand -> <empty>
Rule 82    pop_type -> <empty>
Rule 83    append_jump -> <empty>
Rule 84    CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
Rule 85    ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
Rule 86    ELSE_STMT -> empty pop_operand
Rule 87    WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
Rule 88    check_exact_type_for -> <empty>
Rule 89    add_final_counter_for -> <empty>
Rule 90    generate_for_quad -> <empty>
Rule 91    check_boolean_expression_for -> <empty>
Rule 92    end_for -> <empty>
Rule 93    FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
Rule 94    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 95    aritmetics_operation -> <empty>
Rule 96    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 97    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 98    EXPRESSION_PRIME -> empty
Rule 99    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 100   AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 101   AND_EXP_PRIME -> empty
Rule 102   B_EXP -> TRUE
Rule 103   B_EXP -> FALSE
Rule 104   B_EXP -> EXP B_EXP_PRIME
Rule 105   B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation
Rule 106   B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation
Rule 107   B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation
Rule 108   B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation
Rule 109   B_EXP_PRIME -> empty
Rule 110   EXP -> TERM EXP_PRIME
Rule 111   EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation
Rule 112   EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation
Rule 113   EXP_PRIME -> empty
Rule 114   TERM -> FACTOR TERM_PRIME
Rule 115   TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 116   TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 117   TERM_PRIME -> empty
Rule 118   FACTOR -> ( EXPRESSION )
Rule 119   FACTOR -> * VAR_CT
Rule 120   FACTOR -> / VAR_CT
Rule 121   FACTOR -> VAR_CT
Rule 122   VAR_CT -> ID add_operand
Rule 123   VAR_CT -> I_CONST add_operand
Rule 124   VAR_CT -> F_CONST add_operand
Rule 125   VAR_CT -> C_CONST add_operand
Rule 126   VAR_CT -> FUNC_CALL
Rule 127   VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one
Rule 128   VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
Rule 129   empty -> <empty>

Terminals, with rules where they appear

(                    : 37 38 65 70 71 84 87 93 94 118
)                    : 37 38 65 70 71 84 87 93 94 118
*                    : 115 119
+                    : 111
,                    : 24 42 66 72 73
-                    : 112
.                    : 94
/                    : 116 120
;                    : 1 20 21 22 23 37 48 49 59
<                    : 106
=                    : 59 60 61
>                    : 105
AND                  : 100
CHAR                 : 32
C_CONST              : 125
DATAFRAME            : 33
DESCRIBE             : 94
DIFFERENT            : 107
DO                   : 93
ELSE                 : 85
EQUAL                : 108
FALSE                : 103
FLOAT                : 31
FOR                  : 60
FUNC                 : 37 38 65
F_CONST              : 124
ID                   : 1 20 21 22 23 24 28 29 37 38 40 42 65 94 122 127 128
IF                   : 84
INT                  : 30
I_CONST              : 123
MAIN                 : 1
OR                   : 97
PRINT                : 70 71
PROG                 : 1
RETURN               : 37
TITLE                : 71 73
TO                   : 93
TRUE                 : 102
VAR                  : 20 21 22 23
VOID                 : 1 38
WHILE                : 87
[                    : 22 23 23 29 127 128 128
]                    : 22 23 23 29 127 128 128
error                : 
{                    : 1 37 38 84 85 87 93
}                    : 1 37 38 84 85 87 93

Nonterminals, with rules where they appear

AND_EXP              : 96 97
AND_EXP_PRIME        : 99 100
ASSIGNATION          : 46 93
BLOCK                : 1 37 38 44 84 85 87 93
B_EXP                : 99 100 105 106 107 108
B_EXP_PRIME          : 104
CONDITION            : 50
DESCRIBE_STMT        : 53
ELSE_STMT            : 84
EXP                  : 104
EXPRESSION           : 22 23 23 29 37 48 59 60 65 66 70 72 84 87 93 118 127 128 128
EXPRESSION_PRIME     : 96 97
EXP_PRIME            : 110 111 112
FACTOR               : 114 115 116
FOR_STMT             : 52
FUNCTION             : 12 14
FUNCTION_PRIME       : 1
FUNC_CALL            : 47 61 126
FUNC_CALL_PRIME      : 65 66
FUNC_PRIME           : 12 14
PARAM                : 37 38
PARAM_PRIME          : 40 42
PROGRAM              : 0
STATEMENT            : 44
TERM                 : 110 111 112
TERM_PRIME           : 114 115 116
TIPO_COMP            : 20
TIPO_PRIME           : 20 21 24
TIPO_SIMPLE          : 21 22 23 37 40 42
VARIABLE             : 59 60 61
VARS                 : 10
VARS_PRIME           : 1 1 10 37 38
VAR_CT               : 119 120 121
WHILE_STMT           : 51
WRITE                : 49
WRITE_PRIME          : 70 71 72 73
add_assignation_for_quad : 60
add_assignation_quad : 59 61
add_current_type     : 24
add_final_counter_for : 93
add_function_type    : 37
add_id               : 1 20 21 22 23 24 29 37 38 40 42 127 128
add_operand          : 122 123 124 125
add_operator         : 59 60 61 70 71 105 106 107 108 111 112 115 116
add_parameters       : 37 38
add_print_operator   : 72 73
add_type             : 1 30 31 32 38
append_jump          : 87
aritmetics_operation : 105 106 107 108 111 112 115 116
check_boolean_expression_for : 93
check_exact_type_for : 93 93
check_for_array_length : 22 23 23
empty                : 11 13 15 25 41 43 45 67 74 86 98 101 109 113 117
empty_global_variables_table : 1
empty_local_variables_table : 37 38
end_for              : 93
era_quad             : 65
fill_go_to_false_quad : 87
fill_go_to_false_quad_if : 84
fill_go_to_main_quad : 1
fill_go_to_true_quad : 85
functions_assignation : 61
generate_for_quad    : 93
get_variable         : 28
go_sub_quad          : 65
go_to_false_quad     : 84 87
go_to_main           : 1
go_to_quad           : 87
go_to_true_quad      : 85
param_quad           : 65 66
pop_operand          : 86 87
pop_type             : 84 87
print_quad           : 70 72 73
return_quad          : 37
save_array           : 22
save_function        : 1 37 38
save_function_as_variable : 37
save_ids             : 20 21
save_parameter       : 40 42
ver_quad_dimension_one : 29 127 128

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (6) add_id -> .

    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (2) go_to_main -> .

    VAR             reduce using rule 2 (go_to_main -> .)
    FUNC            reduce using rule 2 (go_to_main -> .)
    VOID            reduce using rule 2 (go_to_main -> .)

    go_to_main                     shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main . save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (9) save_function -> .

    VAR             reduce using rule 9 (save_function -> .)
    FUNC            reduce using rule 9 (save_function -> .)
    VOID            reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 8

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function . VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (20) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (129) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 129 (empty -> .)
    VOID            reduce using rule 129 (empty -> .)

    VARS_PRIME                     shift and go to state 9
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 9

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME . FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (12) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (13) FUNCTION_PRIME -> . empty
    (37) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (38) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (129) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 129 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 13
    FUNCTION                       shift and go to state 14
    empty                          shift and go to state 15

state 10

    (10) VARS_PRIME -> VARS . VARS_PRIME
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (20) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (129) empty -> .

    VAR             shift and go to state 12
    FUNC            reduce using rule 129 (empty -> .)
    VOID            reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    VARS                           shift and go to state 10
    VARS_PRIME                     shift and go to state 17
    empty                          shift and go to state 11

state 11

    (11) VARS_PRIME -> empty .

    FUNC            reduce using rule 11 (VARS_PRIME -> empty .)
    VOID            reduce using rule 11 (VARS_PRIME -> empty .)
    FOR             reduce using rule 11 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 11 (VARS_PRIME -> empty .)
    IF              reduce using rule 11 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 11 (VARS_PRIME -> empty .)
    ID              reduce using rule 11 (VARS_PRIME -> empty .)
    TRUE            reduce using rule 11 (VARS_PRIME -> empty .)
    FALSE           reduce using rule 11 (VARS_PRIME -> empty .)
    (               reduce using rule 11 (VARS_PRIME -> empty .)
    *               reduce using rule 11 (VARS_PRIME -> empty .)
    /               reduce using rule 11 (VARS_PRIME -> empty .)
    I_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    F_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    C_CONST         reduce using rule 11 (VARS_PRIME -> empty .)
    }               reduce using rule 11 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 11 (VARS_PRIME -> empty .)


state 12

    (20) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> VAR . TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> VAR . TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (33) TIPO_COMP -> . DATAFRAME
    (30) TIPO_SIMPLE -> . INT add_type
    (31) TIPO_SIMPLE -> . FLOAT add_type
    (32) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 20
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_COMP                      shift and go to state 18
    TIPO_SIMPLE                    shift and go to state 19

state 13

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME . VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    VOID            shift and go to state 24


state 14

    (12) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (14) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (15) FUNC_PRIME -> . empty
    (37) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (38) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (129) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 129 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 26
    empty                          shift and go to state 27

state 15

    (13) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 13 (FUNCTION_PRIME -> empty .)


state 16

    (37) FUNCTION -> FUNC . TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (38) FUNCTION -> FUNC . VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (30) TIPO_SIMPLE -> . INT add_type
    (31) TIPO_SIMPLE -> . FLOAT add_type
    (32) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 29
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 28

state 17

    (10) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    TRUE            reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    FALSE           reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    (               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    *               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    /               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    I_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    F_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    C_CONST         reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 10 (VARS_PRIME -> VARS VARS_PRIME .)


state 18

    (20) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 30


state 19

    (21) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> VAR TIPO_SIMPLE . ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE . ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;

    ID              shift and go to state 31


state 20

    (33) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 33 (TIPO_COMP -> DATAFRAME .)


state 21

    (30) TIPO_SIMPLE -> INT . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (31) TIPO_SIMPLE -> FLOAT . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (32) TIPO_SIMPLE -> CHAR . add_type
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 34

state 24

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID . MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    MAIN            shift and go to state 35


state 25

    (14) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (14) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (15) FUNC_PRIME -> . empty
    (37) FUNCTION -> . FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (38) FUNCTION -> . FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (129) empty -> .

    FUNC            shift and go to state 16
    VOID            reduce using rule 129 (empty -> .)

    FUNCTION                       shift and go to state 25
    FUNC_PRIME                     shift and go to state 36
    empty                          shift and go to state 27

state 26

    (12) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 12 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 27

    (15) FUNC_PRIME -> empty .

    VOID            reduce using rule 15 (FUNC_PRIME -> empty .)


state 28

    (37) FUNCTION -> FUNC TIPO_SIMPLE . add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (34) add_function_type -> .

    ID              reduce using rule 34 (add_function_type -> .)

    add_function_type              shift and go to state 37

state 29

    (38) FUNCTION -> FUNC VOID . add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (16) add_type -> .

    ID              reduce using rule 16 (add_type -> .)

    add_type                       shift and go to state 38

state 30

    (20) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (21) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (22) VARS -> VAR TIPO_SIMPLE ID . add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID . add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (6) add_id -> .

    [               reduce using rule 6 (add_id -> .)
    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 40

state 32

    (30) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 30 (TIPO_SIMPLE -> INT add_type .)


state 33

    (31) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 31 (TIPO_SIMPLE -> FLOAT add_type .)


state 34

    (32) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 32 (TIPO_SIMPLE -> CHAR add_type .)


state 35

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN . { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table

    {               shift and go to state 41


state 36

    (14) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 14 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 37

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type . ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    ID              shift and go to state 42


state 38

    (38) FUNCTION -> FUNC VOID add_type . ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table

    ID              shift and go to state 43


state 39

    (20) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (24) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (25) TIPO_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 129 (empty -> .)

    TIPO_PRIME                     shift and go to state 44
    empty                          shift and go to state 46

state 40

    (21) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (22) VARS -> VAR TIPO_SIMPLE ID add_id . [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID add_id . [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (24) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (25) TIPO_PRIME -> . empty
    (129) empty -> .

    [               shift and go to state 48
    ,               shift and go to state 45
    ;               reduce using rule 129 (empty -> .)

    TIPO_PRIME                     shift and go to state 47
    empty                          shift and go to state 46

state 41

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { . fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table
    (5) fill_go_to_main_quad -> .

    VAR             reduce using rule 5 (fill_go_to_main_quad -> .)
    FOR             reduce using rule 5 (fill_go_to_main_quad -> .)
    FUNC            reduce using rule 5 (fill_go_to_main_quad -> .)
    PRINT           reduce using rule 5 (fill_go_to_main_quad -> .)
    IF              reduce using rule 5 (fill_go_to_main_quad -> .)
    WHILE           reduce using rule 5 (fill_go_to_main_quad -> .)
    ID              reduce using rule 5 (fill_go_to_main_quad -> .)
    TRUE            reduce using rule 5 (fill_go_to_main_quad -> .)
    FALSE           reduce using rule 5 (fill_go_to_main_quad -> .)
    (               reduce using rule 5 (fill_go_to_main_quad -> .)
    *               reduce using rule 5 (fill_go_to_main_quad -> .)
    /               reduce using rule 5 (fill_go_to_main_quad -> .)
    I_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    F_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    C_CONST         reduce using rule 5 (fill_go_to_main_quad -> .)
    }               reduce using rule 5 (fill_go_to_main_quad -> .)

    fill_go_to_main_quad           shift and go to state 49

state 42

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID . add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (6) add_id -> .

    (               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 50

state 43

    (38) FUNCTION -> FUNC VOID add_type ID . add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (6) add_id -> .

    (               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 51

state 44

    (20) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 52


state 45

    (24) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 53


state 46

    (25) TIPO_PRIME -> empty .

    ;               reduce using rule 25 (TIPO_PRIME -> empty .)


state 47

    (21) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 54


state 48

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ . EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ . EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 56
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 49

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad . VARS_PRIME BLOCK } empty_global_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (20) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (129) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)

    VARS_PRIME                     shift and go to state 73
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 50

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id . save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (9) save_function -> .

    (               reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 74

state 51

    (38) FUNCTION -> FUNC VOID add_type ID add_id . save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (9) save_function -> .

    (               reduce using rule 9 (save_function -> .)

    save_function                  shift and go to state 75

state 52

    (20) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (7) save_ids -> .

    VAR             reduce using rule 7 (save_ids -> .)
    FUNC            reduce using rule 7 (save_ids -> .)
    VOID            reduce using rule 7 (save_ids -> .)
    FOR             reduce using rule 7 (save_ids -> .)
    PRINT           reduce using rule 7 (save_ids -> .)
    IF              reduce using rule 7 (save_ids -> .)
    WHILE           reduce using rule 7 (save_ids -> .)
    ID              reduce using rule 7 (save_ids -> .)
    TRUE            reduce using rule 7 (save_ids -> .)
    FALSE           reduce using rule 7 (save_ids -> .)
    (               reduce using rule 7 (save_ids -> .)
    *               reduce using rule 7 (save_ids -> .)
    /               reduce using rule 7 (save_ids -> .)
    I_CONST         reduce using rule 7 (save_ids -> .)
    F_CONST         reduce using rule 7 (save_ids -> .)
    C_CONST         reduce using rule 7 (save_ids -> .)
    }               reduce using rule 7 (save_ids -> .)
    RETURN          reduce using rule 7 (save_ids -> .)

    save_ids                       shift and go to state 76

state 53

    (24) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    ;               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 77

state 54

    (21) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (7) save_ids -> .

    VAR             reduce using rule 7 (save_ids -> .)
    FUNC            reduce using rule 7 (save_ids -> .)
    VOID            reduce using rule 7 (save_ids -> .)
    FOR             reduce using rule 7 (save_ids -> .)
    PRINT           reduce using rule 7 (save_ids -> .)
    IF              reduce using rule 7 (save_ids -> .)
    WHILE           reduce using rule 7 (save_ids -> .)
    ID              reduce using rule 7 (save_ids -> .)
    TRUE            reduce using rule 7 (save_ids -> .)
    FALSE           reduce using rule 7 (save_ids -> .)
    (               reduce using rule 7 (save_ids -> .)
    *               reduce using rule 7 (save_ids -> .)
    /               reduce using rule 7 (save_ids -> .)
    I_CONST         reduce using rule 7 (save_ids -> .)
    F_CONST         reduce using rule 7 (save_ids -> .)
    C_CONST         reduce using rule 7 (save_ids -> .)
    }               reduce using rule 7 (save_ids -> .)
    RETURN          reduce using rule 7 (save_ids -> .)

    save_ids                       shift and go to state 78

state 55

    (122) VAR_CT -> ID . add_operand
    (127) VAR_CT -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (55) add_operand -> .
    (6) add_id -> .

    *               reduce using rule 55 (add_operand -> .)
    /               reduce using rule 55 (add_operand -> .)
    +               reduce using rule 55 (add_operand -> .)
    -               reduce using rule 55 (add_operand -> .)
    >               reduce using rule 55 (add_operand -> .)
    <               reduce using rule 55 (add_operand -> .)
    DIFFERENT       reduce using rule 55 (add_operand -> .)
    EQUAL           reduce using rule 55 (add_operand -> .)
    AND             reduce using rule 55 (add_operand -> .)
    OR              reduce using rule 55 (add_operand -> .)
    ]               reduce using rule 55 (add_operand -> .)
    )               reduce using rule 55 (add_operand -> .)
    ;               reduce using rule 55 (add_operand -> .)
    ,               reduce using rule 55 (add_operand -> .)
    TO              reduce using rule 55 (add_operand -> .)
    FOR             reduce using rule 55 (add_operand -> .)
    FUNC            reduce using rule 55 (add_operand -> .)
    PRINT           reduce using rule 55 (add_operand -> .)
    IF              reduce using rule 55 (add_operand -> .)
    WHILE           reduce using rule 55 (add_operand -> .)
    ID              reduce using rule 55 (add_operand -> .)
    TRUE            reduce using rule 55 (add_operand -> .)
    FALSE           reduce using rule 55 (add_operand -> .)
    (               reduce using rule 55 (add_operand -> .)
    I_CONST         reduce using rule 55 (add_operand -> .)
    F_CONST         reduce using rule 55 (add_operand -> .)
    C_CONST         reduce using rule 55 (add_operand -> .)
    }               reduce using rule 55 (add_operand -> .)
    RETURN          reduce using rule 55 (add_operand -> .)
    [               reduce using rule 6 (add_id -> .)

    add_operand                    shift and go to state 79
    add_id                         shift and go to state 80

state 56

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION . ] check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION . ] check_for_array_length [ EXPRESSION ] check_for_array_length ;

    ]               shift and go to state 81


state 57

    (96) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (97) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (98) EXPRESSION_PRIME -> . empty
    (129) empty -> .

    OR              shift and go to state 83
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 82
    empty                          shift and go to state 84

state 58

    (99) AND_EXP -> B_EXP . AND_EXP_PRIME
    (100) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (101) AND_EXP_PRIME -> . empty
    (129) empty -> .

    AND             shift and go to state 86
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 85
    empty                          shift and go to state 87

state 59

    (102) B_EXP -> TRUE .

    AND             reduce using rule 102 (B_EXP -> TRUE .)
    OR              reduce using rule 102 (B_EXP -> TRUE .)
    ]               reduce using rule 102 (B_EXP -> TRUE .)
    )               reduce using rule 102 (B_EXP -> TRUE .)
    ;               reduce using rule 102 (B_EXP -> TRUE .)
    ,               reduce using rule 102 (B_EXP -> TRUE .)
    TO              reduce using rule 102 (B_EXP -> TRUE .)
    FOR             reduce using rule 102 (B_EXP -> TRUE .)
    FUNC            reduce using rule 102 (B_EXP -> TRUE .)
    PRINT           reduce using rule 102 (B_EXP -> TRUE .)
    IF              reduce using rule 102 (B_EXP -> TRUE .)
    WHILE           reduce using rule 102 (B_EXP -> TRUE .)
    ID              reduce using rule 102 (B_EXP -> TRUE .)
    TRUE            reduce using rule 102 (B_EXP -> TRUE .)
    FALSE           reduce using rule 102 (B_EXP -> TRUE .)
    (               reduce using rule 102 (B_EXP -> TRUE .)
    *               reduce using rule 102 (B_EXP -> TRUE .)
    /               reduce using rule 102 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 102 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 102 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 102 (B_EXP -> TRUE .)
    }               reduce using rule 102 (B_EXP -> TRUE .)
    RETURN          reduce using rule 102 (B_EXP -> TRUE .)


state 60

    (103) B_EXP -> FALSE .

    AND             reduce using rule 103 (B_EXP -> FALSE .)
    OR              reduce using rule 103 (B_EXP -> FALSE .)
    ]               reduce using rule 103 (B_EXP -> FALSE .)
    )               reduce using rule 103 (B_EXP -> FALSE .)
    ;               reduce using rule 103 (B_EXP -> FALSE .)
    ,               reduce using rule 103 (B_EXP -> FALSE .)
    TO              reduce using rule 103 (B_EXP -> FALSE .)
    FOR             reduce using rule 103 (B_EXP -> FALSE .)
    FUNC            reduce using rule 103 (B_EXP -> FALSE .)
    PRINT           reduce using rule 103 (B_EXP -> FALSE .)
    IF              reduce using rule 103 (B_EXP -> FALSE .)
    WHILE           reduce using rule 103 (B_EXP -> FALSE .)
    ID              reduce using rule 103 (B_EXP -> FALSE .)
    TRUE            reduce using rule 103 (B_EXP -> FALSE .)
    FALSE           reduce using rule 103 (B_EXP -> FALSE .)
    (               reduce using rule 103 (B_EXP -> FALSE .)
    *               reduce using rule 103 (B_EXP -> FALSE .)
    /               reduce using rule 103 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 103 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 103 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 103 (B_EXP -> FALSE .)
    }               reduce using rule 103 (B_EXP -> FALSE .)
    RETURN          reduce using rule 103 (B_EXP -> FALSE .)


state 61

    (104) B_EXP -> EXP . B_EXP_PRIME
    (105) B_EXP_PRIME -> . > add_operator B_EXP aritmetics_operation
    (106) B_EXP_PRIME -> . < add_operator B_EXP aritmetics_operation
    (107) B_EXP_PRIME -> . DIFFERENT add_operator B_EXP aritmetics_operation
    (108) B_EXP_PRIME -> . EQUAL add_operator B_EXP aritmetics_operation
    (109) B_EXP_PRIME -> . empty
    (129) empty -> .

    >               shift and go to state 89
    <               shift and go to state 90
    DIFFERENT       shift and go to state 91
    EQUAL           shift and go to state 92
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    B_EXP_PRIME                    shift and go to state 88
    empty                          shift and go to state 93

state 62

    (110) EXP -> TERM . EXP_PRIME
    (111) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (112) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (113) EXP_PRIME -> . empty
    (129) empty -> .

    +               shift and go to state 95
    -               shift and go to state 96
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    EXP_PRIME                      shift and go to state 94
    empty                          shift and go to state 97

state 63

    (114) TERM -> FACTOR . TERM_PRIME
    (115) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (116) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (117) TERM_PRIME -> . empty
    (129) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 99
    /               shift and go to state 100
    +               reduce using rule 129 (empty -> .)
    -               reduce using rule 129 (empty -> .)
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

  ! *               [ reduce using rule 129 (empty -> .) ]
  ! /               [ reduce using rule 129 (empty -> .) ]

    TERM_PRIME                     shift and go to state 98
    empty                          shift and go to state 101

state 64

    (118) FACTOR -> ( . EXPRESSION )
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 102
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 65

    (119) FACTOR -> * . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    VAR_CT                         shift and go to state 103
    FUNC_CALL                      shift and go to state 71

state 66

    (121) FACTOR -> VAR_CT .

    *               reduce using rule 121 (FACTOR -> VAR_CT .)
    /               reduce using rule 121 (FACTOR -> VAR_CT .)
    +               reduce using rule 121 (FACTOR -> VAR_CT .)
    -               reduce using rule 121 (FACTOR -> VAR_CT .)
    >               reduce using rule 121 (FACTOR -> VAR_CT .)
    <               reduce using rule 121 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 121 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 121 (FACTOR -> VAR_CT .)
    AND             reduce using rule 121 (FACTOR -> VAR_CT .)
    OR              reduce using rule 121 (FACTOR -> VAR_CT .)
    ]               reduce using rule 121 (FACTOR -> VAR_CT .)
    )               reduce using rule 121 (FACTOR -> VAR_CT .)
    ;               reduce using rule 121 (FACTOR -> VAR_CT .)
    ,               reduce using rule 121 (FACTOR -> VAR_CT .)
    TO              reduce using rule 121 (FACTOR -> VAR_CT .)
    FOR             reduce using rule 121 (FACTOR -> VAR_CT .)
    FUNC            reduce using rule 121 (FACTOR -> VAR_CT .)
    PRINT           reduce using rule 121 (FACTOR -> VAR_CT .)
    IF              reduce using rule 121 (FACTOR -> VAR_CT .)
    WHILE           reduce using rule 121 (FACTOR -> VAR_CT .)
    ID              reduce using rule 121 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 121 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 121 (FACTOR -> VAR_CT .)
    (               reduce using rule 121 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 121 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 121 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 121 (FACTOR -> VAR_CT .)
    }               reduce using rule 121 (FACTOR -> VAR_CT .)
    RETURN          reduce using rule 121 (FACTOR -> VAR_CT .)


state 67

    (120) FACTOR -> / . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    VAR_CT                         shift and go to state 104
    FUNC_CALL                      shift and go to state 71

state 68

    (123) VAR_CT -> I_CONST . add_operand
    (55) add_operand -> .

    *               reduce using rule 55 (add_operand -> .)
    /               reduce using rule 55 (add_operand -> .)
    +               reduce using rule 55 (add_operand -> .)
    -               reduce using rule 55 (add_operand -> .)
    >               reduce using rule 55 (add_operand -> .)
    <               reduce using rule 55 (add_operand -> .)
    DIFFERENT       reduce using rule 55 (add_operand -> .)
    EQUAL           reduce using rule 55 (add_operand -> .)
    AND             reduce using rule 55 (add_operand -> .)
    OR              reduce using rule 55 (add_operand -> .)
    ]               reduce using rule 55 (add_operand -> .)
    )               reduce using rule 55 (add_operand -> .)
    ;               reduce using rule 55 (add_operand -> .)
    ,               reduce using rule 55 (add_operand -> .)
    TO              reduce using rule 55 (add_operand -> .)
    FOR             reduce using rule 55 (add_operand -> .)
    FUNC            reduce using rule 55 (add_operand -> .)
    PRINT           reduce using rule 55 (add_operand -> .)
    IF              reduce using rule 55 (add_operand -> .)
    WHILE           reduce using rule 55 (add_operand -> .)
    ID              reduce using rule 55 (add_operand -> .)
    TRUE            reduce using rule 55 (add_operand -> .)
    FALSE           reduce using rule 55 (add_operand -> .)
    (               reduce using rule 55 (add_operand -> .)
    I_CONST         reduce using rule 55 (add_operand -> .)
    F_CONST         reduce using rule 55 (add_operand -> .)
    C_CONST         reduce using rule 55 (add_operand -> .)
    }               reduce using rule 55 (add_operand -> .)
    RETURN          reduce using rule 55 (add_operand -> .)

    add_operand                    shift and go to state 105

state 69

    (124) VAR_CT -> F_CONST . add_operand
    (55) add_operand -> .

    *               reduce using rule 55 (add_operand -> .)
    /               reduce using rule 55 (add_operand -> .)
    +               reduce using rule 55 (add_operand -> .)
    -               reduce using rule 55 (add_operand -> .)
    >               reduce using rule 55 (add_operand -> .)
    <               reduce using rule 55 (add_operand -> .)
    DIFFERENT       reduce using rule 55 (add_operand -> .)
    EQUAL           reduce using rule 55 (add_operand -> .)
    AND             reduce using rule 55 (add_operand -> .)
    OR              reduce using rule 55 (add_operand -> .)
    ]               reduce using rule 55 (add_operand -> .)
    )               reduce using rule 55 (add_operand -> .)
    ;               reduce using rule 55 (add_operand -> .)
    ,               reduce using rule 55 (add_operand -> .)
    TO              reduce using rule 55 (add_operand -> .)
    FOR             reduce using rule 55 (add_operand -> .)
    FUNC            reduce using rule 55 (add_operand -> .)
    PRINT           reduce using rule 55 (add_operand -> .)
    IF              reduce using rule 55 (add_operand -> .)
    WHILE           reduce using rule 55 (add_operand -> .)
    ID              reduce using rule 55 (add_operand -> .)
    TRUE            reduce using rule 55 (add_operand -> .)
    FALSE           reduce using rule 55 (add_operand -> .)
    (               reduce using rule 55 (add_operand -> .)
    I_CONST         reduce using rule 55 (add_operand -> .)
    F_CONST         reduce using rule 55 (add_operand -> .)
    C_CONST         reduce using rule 55 (add_operand -> .)
    }               reduce using rule 55 (add_operand -> .)
    RETURN          reduce using rule 55 (add_operand -> .)

    add_operand                    shift and go to state 106

state 70

    (125) VAR_CT -> C_CONST . add_operand
    (55) add_operand -> .

    *               reduce using rule 55 (add_operand -> .)
    /               reduce using rule 55 (add_operand -> .)
    +               reduce using rule 55 (add_operand -> .)
    -               reduce using rule 55 (add_operand -> .)
    >               reduce using rule 55 (add_operand -> .)
    <               reduce using rule 55 (add_operand -> .)
    DIFFERENT       reduce using rule 55 (add_operand -> .)
    EQUAL           reduce using rule 55 (add_operand -> .)
    AND             reduce using rule 55 (add_operand -> .)
    OR              reduce using rule 55 (add_operand -> .)
    ]               reduce using rule 55 (add_operand -> .)
    )               reduce using rule 55 (add_operand -> .)
    ;               reduce using rule 55 (add_operand -> .)
    ,               reduce using rule 55 (add_operand -> .)
    TO              reduce using rule 55 (add_operand -> .)
    FOR             reduce using rule 55 (add_operand -> .)
    FUNC            reduce using rule 55 (add_operand -> .)
    PRINT           reduce using rule 55 (add_operand -> .)
    IF              reduce using rule 55 (add_operand -> .)
    WHILE           reduce using rule 55 (add_operand -> .)
    ID              reduce using rule 55 (add_operand -> .)
    TRUE            reduce using rule 55 (add_operand -> .)
    FALSE           reduce using rule 55 (add_operand -> .)
    (               reduce using rule 55 (add_operand -> .)
    I_CONST         reduce using rule 55 (add_operand -> .)
    F_CONST         reduce using rule 55 (add_operand -> .)
    C_CONST         reduce using rule 55 (add_operand -> .)
    }               reduce using rule 55 (add_operand -> .)
    RETURN          reduce using rule 55 (add_operand -> .)

    add_operand                    shift and go to state 107

state 71

    (126) VAR_CT -> FUNC_CALL .

    *               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    /               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    +               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ]               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    )               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ,               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    TO              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    FOR             reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    FUNC            reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    PRINT           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    IF              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    WHILE           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ID              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    TRUE            reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    FALSE           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    (               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    I_CONST         reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    F_CONST         reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    C_CONST         reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    }               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    RETURN          reduce using rule 126 (VAR_CT -> FUNC_CALL .)


state 72

    (65) FUNC_CALL -> FUNC . ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    ID              shift and go to state 108


state 73

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME . BLOCK } empty_global_variables_table
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    BLOCK                          shift and go to state 110
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    EXPRESSION                     shift and go to state 115
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 74

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function . ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    (               shift and go to state 126


state 75

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function . ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table

    (               shift and go to state 127


state 76

    (20) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 20 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 77

    (24) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (17) add_current_type -> .

    ,               reduce using rule 17 (add_current_type -> .)
    ;               reduce using rule 17 (add_current_type -> .)

    add_current_type               shift and go to state 128

state 78

    (21) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 21 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 79

    (122) VAR_CT -> ID add_operand .

    *               reduce using rule 122 (VAR_CT -> ID add_operand .)
    /               reduce using rule 122 (VAR_CT -> ID add_operand .)
    +               reduce using rule 122 (VAR_CT -> ID add_operand .)
    -               reduce using rule 122 (VAR_CT -> ID add_operand .)
    >               reduce using rule 122 (VAR_CT -> ID add_operand .)
    <               reduce using rule 122 (VAR_CT -> ID add_operand .)
    DIFFERENT       reduce using rule 122 (VAR_CT -> ID add_operand .)
    EQUAL           reduce using rule 122 (VAR_CT -> ID add_operand .)
    AND             reduce using rule 122 (VAR_CT -> ID add_operand .)
    OR              reduce using rule 122 (VAR_CT -> ID add_operand .)
    ]               reduce using rule 122 (VAR_CT -> ID add_operand .)
    )               reduce using rule 122 (VAR_CT -> ID add_operand .)
    ;               reduce using rule 122 (VAR_CT -> ID add_operand .)
    ,               reduce using rule 122 (VAR_CT -> ID add_operand .)
    TO              reduce using rule 122 (VAR_CT -> ID add_operand .)
    FOR             reduce using rule 122 (VAR_CT -> ID add_operand .)
    FUNC            reduce using rule 122 (VAR_CT -> ID add_operand .)
    PRINT           reduce using rule 122 (VAR_CT -> ID add_operand .)
    IF              reduce using rule 122 (VAR_CT -> ID add_operand .)
    WHILE           reduce using rule 122 (VAR_CT -> ID add_operand .)
    ID              reduce using rule 122 (VAR_CT -> ID add_operand .)
    TRUE            reduce using rule 122 (VAR_CT -> ID add_operand .)
    FALSE           reduce using rule 122 (VAR_CT -> ID add_operand .)
    (               reduce using rule 122 (VAR_CT -> ID add_operand .)
    I_CONST         reduce using rule 122 (VAR_CT -> ID add_operand .)
    F_CONST         reduce using rule 122 (VAR_CT -> ID add_operand .)
    C_CONST         reduce using rule 122 (VAR_CT -> ID add_operand .)
    }               reduce using rule 122 (VAR_CT -> ID add_operand .)
    RETURN          reduce using rule 122 (VAR_CT -> ID add_operand .)


state 80

    (127) VAR_CT -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    [               shift and go to state 129


state 81

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] . check_for_array_length ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] . check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (18) check_for_array_length -> .

    ;               reduce using rule 18 (check_for_array_length -> .)
    [               reduce using rule 18 (check_for_array_length -> .)

    check_for_array_length         shift and go to state 130

state 82

    (96) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FUNC            reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 96 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 83

    (97) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    AND_EXP                        shift and go to state 131
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 84

    (98) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    FOR             reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    FUNC            reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    PRINT           reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    IF              reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    WHILE           reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 98 (EXPRESSION_PRIME -> empty .)
    RETURN          reduce using rule 98 (EXPRESSION_PRIME -> empty .)


state 85

    (99) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FUNC            reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 99 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 86

    (100) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    B_EXP                          shift and go to state 132
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 87

    (101) AND_EXP_PRIME -> empty .

    OR              reduce using rule 101 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 101 (AND_EXP_PRIME -> empty .)
    FOR             reduce using rule 101 (AND_EXP_PRIME -> empty .)
    FUNC            reduce using rule 101 (AND_EXP_PRIME -> empty .)
    PRINT           reduce using rule 101 (AND_EXP_PRIME -> empty .)
    IF              reduce using rule 101 (AND_EXP_PRIME -> empty .)
    WHILE           reduce using rule 101 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 101 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 101 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 101 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 101 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 101 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 101 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 101 (AND_EXP_PRIME -> empty .)
    RETURN          reduce using rule 101 (AND_EXP_PRIME -> empty .)


state 88

    (104) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    FOR             reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    FUNC            reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    PRINT           reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    IF              reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    WHILE           reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)
    RETURN          reduce using rule 104 (B_EXP -> EXP B_EXP_PRIME .)


state 89

    (105) B_EXP_PRIME -> > . add_operator B_EXP aritmetics_operation
    (54) add_operator -> .

    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 133

state 90

    (106) B_EXP_PRIME -> < . add_operator B_EXP aritmetics_operation
    (54) add_operator -> .

    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 134

state 91

    (107) B_EXP_PRIME -> DIFFERENT . add_operator B_EXP aritmetics_operation
    (54) add_operator -> .

    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 135

state 92

    (108) B_EXP_PRIME -> EQUAL . add_operator B_EXP aritmetics_operation
    (54) add_operator -> .

    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 136

state 93

    (109) B_EXP_PRIME -> empty .

    AND             reduce using rule 109 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 109 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 109 (B_EXP_PRIME -> empty .)
    )               reduce using rule 109 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 109 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 109 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 109 (B_EXP_PRIME -> empty .)
    FOR             reduce using rule 109 (B_EXP_PRIME -> empty .)
    FUNC            reduce using rule 109 (B_EXP_PRIME -> empty .)
    PRINT           reduce using rule 109 (B_EXP_PRIME -> empty .)
    IF              reduce using rule 109 (B_EXP_PRIME -> empty .)
    WHILE           reduce using rule 109 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 109 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 109 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 109 (B_EXP_PRIME -> empty .)
    (               reduce using rule 109 (B_EXP_PRIME -> empty .)
    *               reduce using rule 109 (B_EXP_PRIME -> empty .)
    /               reduce using rule 109 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 109 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 109 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 109 (B_EXP_PRIME -> empty .)
    }               reduce using rule 109 (B_EXP_PRIME -> empty .)
    RETURN          reduce using rule 109 (B_EXP_PRIME -> empty .)


state 94

    (110) EXP -> TERM EXP_PRIME .

    >               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    FOR             reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    FUNC            reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    PRINT           reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    IF              reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    WHILE           reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 110 (EXP -> TERM EXP_PRIME .)
    RETURN          reduce using rule 110 (EXP -> TERM EXP_PRIME .)


state 95

    (111) EXP_PRIME -> + . add_operator TERM EXP_PRIME aritmetics_operation
    (54) add_operator -> .

    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 137

state 96

    (112) EXP_PRIME -> - . add_operator TERM EXP_PRIME aritmetics_operation
    (54) add_operator -> .

    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 138

state 97

    (113) EXP_PRIME -> empty .

    >               reduce using rule 113 (EXP_PRIME -> empty .)
    <               reduce using rule 113 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 113 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 113 (EXP_PRIME -> empty .)
    AND             reduce using rule 113 (EXP_PRIME -> empty .)
    OR              reduce using rule 113 (EXP_PRIME -> empty .)
    ]               reduce using rule 113 (EXP_PRIME -> empty .)
    )               reduce using rule 113 (EXP_PRIME -> empty .)
    ;               reduce using rule 113 (EXP_PRIME -> empty .)
    ,               reduce using rule 113 (EXP_PRIME -> empty .)
    TO              reduce using rule 113 (EXP_PRIME -> empty .)
    FOR             reduce using rule 113 (EXP_PRIME -> empty .)
    FUNC            reduce using rule 113 (EXP_PRIME -> empty .)
    PRINT           reduce using rule 113 (EXP_PRIME -> empty .)
    IF              reduce using rule 113 (EXP_PRIME -> empty .)
    WHILE           reduce using rule 113 (EXP_PRIME -> empty .)
    ID              reduce using rule 113 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 113 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 113 (EXP_PRIME -> empty .)
    (               reduce using rule 113 (EXP_PRIME -> empty .)
    *               reduce using rule 113 (EXP_PRIME -> empty .)
    /               reduce using rule 113 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 113 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 113 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 113 (EXP_PRIME -> empty .)
    }               reduce using rule 113 (EXP_PRIME -> empty .)
    RETURN          reduce using rule 113 (EXP_PRIME -> empty .)


state 98

    (114) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    FOR             reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    FUNC            reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    PRINT           reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    IF              reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    WHILE           reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)
    RETURN          reduce using rule 114 (TERM -> FACTOR TERM_PRIME .)


state 99

    (115) TERM_PRIME -> * . add_operator FACTOR aritmetics_operation TERM_PRIME
    (54) add_operator -> .

    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 139

state 100

    (116) TERM_PRIME -> / . add_operator FACTOR aritmetics_operation TERM_PRIME
    (54) add_operator -> .

    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 140

state 101

    (117) TERM_PRIME -> empty .

    +               reduce using rule 117 (TERM_PRIME -> empty .)
    -               reduce using rule 117 (TERM_PRIME -> empty .)
    >               reduce using rule 117 (TERM_PRIME -> empty .)
    <               reduce using rule 117 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 117 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 117 (TERM_PRIME -> empty .)
    AND             reduce using rule 117 (TERM_PRIME -> empty .)
    OR              reduce using rule 117 (TERM_PRIME -> empty .)
    ]               reduce using rule 117 (TERM_PRIME -> empty .)
    )               reduce using rule 117 (TERM_PRIME -> empty .)
    ;               reduce using rule 117 (TERM_PRIME -> empty .)
    ,               reduce using rule 117 (TERM_PRIME -> empty .)
    TO              reduce using rule 117 (TERM_PRIME -> empty .)
    FOR             reduce using rule 117 (TERM_PRIME -> empty .)
    FUNC            reduce using rule 117 (TERM_PRIME -> empty .)
    PRINT           reduce using rule 117 (TERM_PRIME -> empty .)
    IF              reduce using rule 117 (TERM_PRIME -> empty .)
    WHILE           reduce using rule 117 (TERM_PRIME -> empty .)
    ID              reduce using rule 117 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 117 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 117 (TERM_PRIME -> empty .)
    (               reduce using rule 117 (TERM_PRIME -> empty .)
    *               reduce using rule 117 (TERM_PRIME -> empty .)
    /               reduce using rule 117 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 117 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 117 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 117 (TERM_PRIME -> empty .)
    }               reduce using rule 117 (TERM_PRIME -> empty .)
    RETURN          reduce using rule 117 (TERM_PRIME -> empty .)


state 102

    (118) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 141


state 103

    (119) FACTOR -> * VAR_CT .

    *               reduce using rule 119 (FACTOR -> * VAR_CT .)
    /               reduce using rule 119 (FACTOR -> * VAR_CT .)
    +               reduce using rule 119 (FACTOR -> * VAR_CT .)
    -               reduce using rule 119 (FACTOR -> * VAR_CT .)
    >               reduce using rule 119 (FACTOR -> * VAR_CT .)
    <               reduce using rule 119 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 119 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 119 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 119 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 119 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 119 (FACTOR -> * VAR_CT .)
    )               reduce using rule 119 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 119 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 119 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 119 (FACTOR -> * VAR_CT .)
    FOR             reduce using rule 119 (FACTOR -> * VAR_CT .)
    FUNC            reduce using rule 119 (FACTOR -> * VAR_CT .)
    PRINT           reduce using rule 119 (FACTOR -> * VAR_CT .)
    IF              reduce using rule 119 (FACTOR -> * VAR_CT .)
    WHILE           reduce using rule 119 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 119 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 119 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 119 (FACTOR -> * VAR_CT .)
    (               reduce using rule 119 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 119 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 119 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 119 (FACTOR -> * VAR_CT .)
    }               reduce using rule 119 (FACTOR -> * VAR_CT .)
    RETURN          reduce using rule 119 (FACTOR -> * VAR_CT .)


state 104

    (120) FACTOR -> / VAR_CT .

    *               reduce using rule 120 (FACTOR -> / VAR_CT .)
    /               reduce using rule 120 (FACTOR -> / VAR_CT .)
    +               reduce using rule 120 (FACTOR -> / VAR_CT .)
    -               reduce using rule 120 (FACTOR -> / VAR_CT .)
    >               reduce using rule 120 (FACTOR -> / VAR_CT .)
    <               reduce using rule 120 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 120 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 120 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 120 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 120 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 120 (FACTOR -> / VAR_CT .)
    )               reduce using rule 120 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 120 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 120 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 120 (FACTOR -> / VAR_CT .)
    FOR             reduce using rule 120 (FACTOR -> / VAR_CT .)
    FUNC            reduce using rule 120 (FACTOR -> / VAR_CT .)
    PRINT           reduce using rule 120 (FACTOR -> / VAR_CT .)
    IF              reduce using rule 120 (FACTOR -> / VAR_CT .)
    WHILE           reduce using rule 120 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 120 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 120 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 120 (FACTOR -> / VAR_CT .)
    (               reduce using rule 120 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 120 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 120 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 120 (FACTOR -> / VAR_CT .)
    }               reduce using rule 120 (FACTOR -> / VAR_CT .)
    RETURN          reduce using rule 120 (FACTOR -> / VAR_CT .)


state 105

    (123) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    FOR             reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    FUNC            reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    PRINT           reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    IF              reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    WHILE           reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 123 (VAR_CT -> I_CONST add_operand .)
    RETURN          reduce using rule 123 (VAR_CT -> I_CONST add_operand .)


state 106

    (124) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    FOR             reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    FUNC            reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    PRINT           reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    IF              reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    WHILE           reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 124 (VAR_CT -> F_CONST add_operand .)
    RETURN          reduce using rule 124 (VAR_CT -> F_CONST add_operand .)


state 107

    (125) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    FOR             reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    FUNC            reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    PRINT           reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    IF              reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    WHILE           reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 125 (VAR_CT -> C_CONST add_operand .)
    RETURN          reduce using rule 125 (VAR_CT -> C_CONST add_operand .)


state 108

    (65) FUNC_CALL -> FUNC ID . era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (62) era_quad -> .

    (               reduce using rule 62 (era_quad -> .)

    era_quad                       shift and go to state 142

state 109

    (94) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (28) VARIABLE -> ID . get_variable
    (29) VARIABLE -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one
    (122) VAR_CT -> ID . add_operand
    (127) VAR_CT -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (26) get_variable -> .
    (6) add_id -> .
    (55) add_operand -> .

    .               shift and go to state 143
    =               reduce using rule 26 (get_variable -> .)
    [               reduce using rule 6 (add_id -> .)
    *               reduce using rule 55 (add_operand -> .)
    /               reduce using rule 55 (add_operand -> .)
    +               reduce using rule 55 (add_operand -> .)
    -               reduce using rule 55 (add_operand -> .)
    >               reduce using rule 55 (add_operand -> .)
    <               reduce using rule 55 (add_operand -> .)
    DIFFERENT       reduce using rule 55 (add_operand -> .)
    EQUAL           reduce using rule 55 (add_operand -> .)
    AND             reduce using rule 55 (add_operand -> .)
    OR              reduce using rule 55 (add_operand -> .)
    ;               reduce using rule 55 (add_operand -> .)

    get_variable                   shift and go to state 144
    add_id                         shift and go to state 145
    add_operand                    shift and go to state 79

state 110

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK . } empty_global_variables_table

    }               shift and go to state 146


state 111

    (44) BLOCK -> STATEMENT . BLOCK
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    STATEMENT                      shift and go to state 111
    BLOCK                          shift and go to state 147
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    EXPRESSION                     shift and go to state 115
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 112

    (45) BLOCK -> empty .

    }               reduce using rule 45 (BLOCK -> empty .)
    RETURN          reduce using rule 45 (BLOCK -> empty .)


state 113

    (46) STATEMENT -> ASSIGNATION .
    (93) FOR_STMT -> ASSIGNATION . check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (88) check_exact_type_for -> .

    FOR             reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    FUNC            reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    ID              reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    TRUE            reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    FALSE           reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    (               reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    *               reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    /               reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    I_CONST         reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    F_CONST         reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    C_CONST         reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 46 (STATEMENT -> ASSIGNATION .)
    TO              reduce using rule 88 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 148

state 114

    (47) STATEMENT -> FUNC_CALL .
    (126) VAR_CT -> FUNC_CALL .

  ! reduce/reduce conflict for * resolved using rule 47 (STATEMENT -> FUNC_CALL .)
  ! reduce/reduce conflict for / resolved using rule 47 (STATEMENT -> FUNC_CALL .)
    FOR             reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    FUNC            reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    ID              reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    TRUE            reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    FALSE           reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    (               reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    *               reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    /               reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    I_CONST         reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    F_CONST         reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    C_CONST         reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 47 (STATEMENT -> FUNC_CALL .)
    +               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 126 (VAR_CT -> FUNC_CALL .)

  ! *               [ reduce using rule 126 (VAR_CT -> FUNC_CALL .) ]
  ! /               [ reduce using rule 126 (VAR_CT -> FUNC_CALL .) ]


state 115

    (48) STATEMENT -> EXPRESSION . ;

    ;               shift and go to state 149


state 116

    (49) STATEMENT -> WRITE . ;

    ;               shift and go to state 150


state 117

    (50) STATEMENT -> CONDITION .

    FOR             reduce using rule 50 (STATEMENT -> CONDITION .)
    FUNC            reduce using rule 50 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 50 (STATEMENT -> CONDITION .)
    IF              reduce using rule 50 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 50 (STATEMENT -> CONDITION .)
    ID              reduce using rule 50 (STATEMENT -> CONDITION .)
    TRUE            reduce using rule 50 (STATEMENT -> CONDITION .)
    FALSE           reduce using rule 50 (STATEMENT -> CONDITION .)
    (               reduce using rule 50 (STATEMENT -> CONDITION .)
    *               reduce using rule 50 (STATEMENT -> CONDITION .)
    /               reduce using rule 50 (STATEMENT -> CONDITION .)
    I_CONST         reduce using rule 50 (STATEMENT -> CONDITION .)
    F_CONST         reduce using rule 50 (STATEMENT -> CONDITION .)
    C_CONST         reduce using rule 50 (STATEMENT -> CONDITION .)
    }               reduce using rule 50 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 50 (STATEMENT -> CONDITION .)


state 118

    (51) STATEMENT -> WHILE_STMT .

    FOR             reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    FUNC            reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    ID              reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    TRUE            reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    FALSE           reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    (               reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    *               reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    /               reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    I_CONST         reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    F_CONST         reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    C_CONST         reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 51 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 51 (STATEMENT -> WHILE_STMT .)


state 119

    (52) STATEMENT -> FOR_STMT .

    FOR             reduce using rule 52 (STATEMENT -> FOR_STMT .)
    FUNC            reduce using rule 52 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 52 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 52 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 52 (STATEMENT -> FOR_STMT .)
    ID              reduce using rule 52 (STATEMENT -> FOR_STMT .)
    TRUE            reduce using rule 52 (STATEMENT -> FOR_STMT .)
    FALSE           reduce using rule 52 (STATEMENT -> FOR_STMT .)
    (               reduce using rule 52 (STATEMENT -> FOR_STMT .)
    *               reduce using rule 52 (STATEMENT -> FOR_STMT .)
    /               reduce using rule 52 (STATEMENT -> FOR_STMT .)
    I_CONST         reduce using rule 52 (STATEMENT -> FOR_STMT .)
    F_CONST         reduce using rule 52 (STATEMENT -> FOR_STMT .)
    C_CONST         reduce using rule 52 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 52 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 52 (STATEMENT -> FOR_STMT .)


state 120

    (53) STATEMENT -> DESCRIBE_STMT .

    FOR             reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    FUNC            reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    ID              reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    TRUE            reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    FALSE           reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    (               reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    *               reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    /               reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    I_CONST         reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    F_CONST         reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    C_CONST         reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 53 (STATEMENT -> DESCRIBE_STMT .)


state 121

    (59) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad
    (61) ASSIGNATION -> VARIABLE . = add_operator FUNC_CALL functions_assignation add_assignation_quad

    =               shift and go to state 151


state 122

    (60) ASSIGNATION -> FOR . VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one

    ID              shift and go to state 153

    VARIABLE                       shift and go to state 152

state 123

    (70) WRITE -> PRINT . add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> PRINT . add_operator ( TITLE WRITE_PRIME )
    (54) add_operator -> .

    (               reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 154

state 124

    (84) CONDITION -> IF . ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT

    (               shift and go to state 155


state 125

    (87) WHILE_STMT -> WHILE . ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    (               shift and go to state 156


state 126

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( . PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (40) PARAM -> . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (41) PARAM -> . empty
    (30) TIPO_SIMPLE -> . INT add_type
    (31) TIPO_SIMPLE -> . FLOAT add_type
    (32) TIPO_SIMPLE -> . CHAR add_type
    (129) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 129 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 157
    PARAM                          shift and go to state 158
    empty                          shift and go to state 159

state 127

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( . PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (40) PARAM -> . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (41) PARAM -> . empty
    (30) TIPO_SIMPLE -> . INT add_type
    (31) TIPO_SIMPLE -> . FLOAT add_type
    (32) TIPO_SIMPLE -> . CHAR add_type
    (129) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    )               reduce using rule 129 (empty -> .)

    PARAM                          shift and go to state 160
    TIPO_SIMPLE                    shift and go to state 157
    empty                          shift and go to state 159

state 128

    (24) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (24) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (25) TIPO_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 129 (empty -> .)

    TIPO_PRIME                     shift and go to state 161
    empty                          shift and go to state 46

state 129

    (127) VAR_CT -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 162
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 130

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length . ; save_array
    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length . [ EXPRESSION ] check_for_array_length ;

    ;               shift and go to state 164
    [               shift and go to state 163


state 131

    (97) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (97) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (98) EXPRESSION_PRIME -> . empty
    (129) empty -> .

    OR              shift and go to state 83
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 165
    empty                          shift and go to state 84

state 132

    (100) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (100) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (101) AND_EXP_PRIME -> . empty
    (129) empty -> .

    AND             shift and go to state 86
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 166
    empty                          shift and go to state 87

state 133

    (105) B_EXP_PRIME -> > add_operator . B_EXP aritmetics_operation
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    B_EXP                          shift and go to state 167
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 134

    (106) B_EXP_PRIME -> < add_operator . B_EXP aritmetics_operation
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    B_EXP                          shift and go to state 168
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 135

    (107) B_EXP_PRIME -> DIFFERENT add_operator . B_EXP aritmetics_operation
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    B_EXP                          shift and go to state 169
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 136

    (108) B_EXP_PRIME -> EQUAL add_operator . B_EXP aritmetics_operation
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    B_EXP                          shift and go to state 170
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 137

    (111) EXP_PRIME -> + add_operator . TERM EXP_PRIME aritmetics_operation
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    TERM                           shift and go to state 171
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 138

    (112) EXP_PRIME -> - add_operator . TERM EXP_PRIME aritmetics_operation
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    TERM                           shift and go to state 172
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 139

    (115) TERM_PRIME -> * add_operator . FACTOR aritmetics_operation TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    FACTOR                         shift and go to state 173
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 140

    (116) TERM_PRIME -> / add_operator . FACTOR aritmetics_operation TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    FACTOR                         shift and go to state 174
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 141

    (118) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    FOR             reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    FUNC            reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    PRINT           reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    IF              reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    WHILE           reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)
    RETURN          reduce using rule 118 (FACTOR -> ( EXPRESSION ) .)


state 142

    (65) FUNC_CALL -> FUNC ID era_quad . ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    (               shift and go to state 175


state 143

    (94) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 176


state 144

    (28) VARIABLE -> ID get_variable .

    =               reduce using rule 28 (VARIABLE -> ID get_variable .)


state 145

    (29) VARIABLE -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one
    (127) VAR_CT -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    [               shift and go to state 177


state 146

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } . empty_global_variables_table
    (3) empty_global_variables_table -> .

    $end            reduce using rule 3 (empty_global_variables_table -> .)

    empty_global_variables_table   shift and go to state 178

state 147

    (44) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 44 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 44 (BLOCK -> STATEMENT BLOCK .)


state 148

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for . TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    TO              shift and go to state 179


state 149

    (48) STATEMENT -> EXPRESSION ; .

    FOR             reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    FUNC            reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    PRINT           reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    IF              reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    WHILE           reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    ID              reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    TRUE            reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    FALSE           reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    (               reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    *               reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    /               reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    I_CONST         reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    F_CONST         reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    C_CONST         reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    }               reduce using rule 48 (STATEMENT -> EXPRESSION ; .)
    RETURN          reduce using rule 48 (STATEMENT -> EXPRESSION ; .)


state 150

    (49) STATEMENT -> WRITE ; .

    FOR             reduce using rule 49 (STATEMENT -> WRITE ; .)
    FUNC            reduce using rule 49 (STATEMENT -> WRITE ; .)
    PRINT           reduce using rule 49 (STATEMENT -> WRITE ; .)
    IF              reduce using rule 49 (STATEMENT -> WRITE ; .)
    WHILE           reduce using rule 49 (STATEMENT -> WRITE ; .)
    ID              reduce using rule 49 (STATEMENT -> WRITE ; .)
    TRUE            reduce using rule 49 (STATEMENT -> WRITE ; .)
    FALSE           reduce using rule 49 (STATEMENT -> WRITE ; .)
    (               reduce using rule 49 (STATEMENT -> WRITE ; .)
    *               reduce using rule 49 (STATEMENT -> WRITE ; .)
    /               reduce using rule 49 (STATEMENT -> WRITE ; .)
    I_CONST         reduce using rule 49 (STATEMENT -> WRITE ; .)
    F_CONST         reduce using rule 49 (STATEMENT -> WRITE ; .)
    C_CONST         reduce using rule 49 (STATEMENT -> WRITE ; .)
    }               reduce using rule 49 (STATEMENT -> WRITE ; .)
    RETURN          reduce using rule 49 (STATEMENT -> WRITE ; .)


state 151

    (59) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (61) ASSIGNATION -> VARIABLE = . add_operator FUNC_CALL functions_assignation add_assignation_quad
    (54) add_operator -> .

    FUNC            reduce using rule 54 (add_operator -> .)
    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 180

state 152

    (60) ASSIGNATION -> FOR VARIABLE . = add_operator EXPRESSION add_assignation_for_quad

    =               shift and go to state 181


state 153

    (28) VARIABLE -> ID . get_variable
    (29) VARIABLE -> ID . add_id [ EXPRESSION ] ver_quad_dimension_one
    (26) get_variable -> .
    (6) add_id -> .

    =               reduce using rule 26 (get_variable -> .)
    [               reduce using rule 6 (add_id -> .)

    get_variable                   shift and go to state 144
    add_id                         shift and go to state 182

state 154

    (70) WRITE -> PRINT add_operator . ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> PRINT add_operator . ( TITLE WRITE_PRIME )

    (               shift and go to state 183


state 155

    (84) CONDITION -> IF ( . EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 184
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 156

    (87) WHILE_STMT -> WHILE ( . append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (83) append_jump -> .

    TRUE            reduce using rule 83 (append_jump -> .)
    FALSE           reduce using rule 83 (append_jump -> .)
    (               reduce using rule 83 (append_jump -> .)
    *               reduce using rule 83 (append_jump -> .)
    /               reduce using rule 83 (append_jump -> .)
    ID              reduce using rule 83 (append_jump -> .)
    I_CONST         reduce using rule 83 (append_jump -> .)
    F_CONST         reduce using rule 83 (append_jump -> .)
    C_CONST         reduce using rule 83 (append_jump -> .)
    FUNC            reduce using rule 83 (append_jump -> .)

    append_jump                    shift and go to state 185

state 157

    (40) PARAM -> TIPO_SIMPLE . ID add_id save_parameter PARAM_PRIME

    ID              shift and go to state 186


state 158

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM . add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (39) add_parameters -> .

    )               reduce using rule 39 (add_parameters -> .)

    add_parameters                 shift and go to state 187

state 159

    (41) PARAM -> empty .

    )               reduce using rule 41 (PARAM -> empty .)


state 160

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM . add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table
    (39) add_parameters -> .

    )               reduce using rule 39 (add_parameters -> .)

    add_parameters                 shift and go to state 188

state 161

    (24) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 24 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 162

    (127) VAR_CT -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one [ EXPRESSION ]

    ]               shift and go to state 189


state 163

    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ . EXPRESSION ] check_for_array_length ;
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 190
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 164

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; . save_array
    (19) save_array -> .

    VAR             reduce using rule 19 (save_array -> .)
    FUNC            reduce using rule 19 (save_array -> .)
    VOID            reduce using rule 19 (save_array -> .)
    FOR             reduce using rule 19 (save_array -> .)
    PRINT           reduce using rule 19 (save_array -> .)
    IF              reduce using rule 19 (save_array -> .)
    WHILE           reduce using rule 19 (save_array -> .)
    ID              reduce using rule 19 (save_array -> .)
    TRUE            reduce using rule 19 (save_array -> .)
    FALSE           reduce using rule 19 (save_array -> .)
    (               reduce using rule 19 (save_array -> .)
    *               reduce using rule 19 (save_array -> .)
    /               reduce using rule 19 (save_array -> .)
    I_CONST         reduce using rule 19 (save_array -> .)
    F_CONST         reduce using rule 19 (save_array -> .)
    C_CONST         reduce using rule 19 (save_array -> .)
    }               reduce using rule 19 (save_array -> .)
    RETURN          reduce using rule 19 (save_array -> .)

    save_array                     shift and go to state 191

state 165

    (97) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FUNC            reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 97 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 166

    (100) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FUNC            reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 100 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 167

    (105) B_EXP_PRIME -> > add_operator B_EXP . aritmetics_operation
    (95) aritmetics_operation -> .

    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 192

state 168

    (106) B_EXP_PRIME -> < add_operator B_EXP . aritmetics_operation
    (95) aritmetics_operation -> .

    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 193

state 169

    (107) B_EXP_PRIME -> DIFFERENT add_operator B_EXP . aritmetics_operation
    (95) aritmetics_operation -> .

    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 194

state 170

    (108) B_EXP_PRIME -> EQUAL add_operator B_EXP . aritmetics_operation
    (95) aritmetics_operation -> .

    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 195

state 171

    (111) EXP_PRIME -> + add_operator TERM . EXP_PRIME aritmetics_operation
    (111) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (112) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (113) EXP_PRIME -> . empty
    (129) empty -> .

    +               shift and go to state 95
    -               shift and go to state 96
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    EXP_PRIME                      shift and go to state 196
    empty                          shift and go to state 97

state 172

    (112) EXP_PRIME -> - add_operator TERM . EXP_PRIME aritmetics_operation
    (111) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (112) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (113) EXP_PRIME -> . empty
    (129) empty -> .

    +               shift and go to state 95
    -               shift and go to state 96
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    EXP_PRIME                      shift and go to state 197
    empty                          shift and go to state 97

state 173

    (115) TERM_PRIME -> * add_operator FACTOR . aritmetics_operation TERM_PRIME
    (95) aritmetics_operation -> .

    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    +               reduce using rule 95 (aritmetics_operation -> .)
    -               reduce using rule 95 (aritmetics_operation -> .)
    >               reduce using rule 95 (aritmetics_operation -> .)
    <               reduce using rule 95 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 95 (aritmetics_operation -> .)
    EQUAL           reduce using rule 95 (aritmetics_operation -> .)
    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 198

state 174

    (116) TERM_PRIME -> / add_operator FACTOR . aritmetics_operation TERM_PRIME
    (95) aritmetics_operation -> .

    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    +               reduce using rule 95 (aritmetics_operation -> .)
    -               reduce using rule 95 (aritmetics_operation -> .)
    >               reduce using rule 95 (aritmetics_operation -> .)
    <               reduce using rule 95 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 95 (aritmetics_operation -> .)
    EQUAL           reduce using rule 95 (aritmetics_operation -> .)
    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 199

state 175

    (65) FUNC_CALL -> FUNC ID era_quad ( . EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 200
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 176

    (94) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 201


state 177

    (29) VARIABLE -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one
    (127) VAR_CT -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 202
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 178

    (1) PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; go_to_main save_function VARS_PRIME FUNCTION_PRIME VOID MAIN { fill_go_to_main_quad VARS_PRIME BLOCK } empty_global_variables_table .)


state 179

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO . ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    (               shift and go to state 203


state 180

    (59) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (61) ASSIGNATION -> VARIABLE = add_operator . FUNC_CALL functions_assignation add_assignation_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    FUNC            shift and go to state 72
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    EXPRESSION                     shift and go to state 204
    FUNC_CALL                      shift and go to state 205
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 181

    (60) ASSIGNATION -> FOR VARIABLE = . add_operator EXPRESSION add_assignation_for_quad
    (54) add_operator -> .

    TRUE            reduce using rule 54 (add_operator -> .)
    FALSE           reduce using rule 54 (add_operator -> .)
    (               reduce using rule 54 (add_operator -> .)
    *               reduce using rule 54 (add_operator -> .)
    /               reduce using rule 54 (add_operator -> .)
    ID              reduce using rule 54 (add_operator -> .)
    I_CONST         reduce using rule 54 (add_operator -> .)
    F_CONST         reduce using rule 54 (add_operator -> .)
    C_CONST         reduce using rule 54 (add_operator -> .)
    FUNC            reduce using rule 54 (add_operator -> .)

    add_operator                   shift and go to state 206

state 182

    (29) VARIABLE -> ID add_id . [ EXPRESSION ] ver_quad_dimension_one

    [               shift and go to state 207


state 183

    (70) WRITE -> PRINT add_operator ( . EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> PRINT add_operator ( . TITLE WRITE_PRIME )
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TITLE           shift and go to state 209
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 208
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 184

    (84) CONDITION -> IF ( EXPRESSION . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (82) pop_type -> .

    )               reduce using rule 82 (pop_type -> .)

    pop_type                       shift and go to state 210

state 185

    (87) WHILE_STMT -> WHILE ( append_jump . EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 211
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 186

    (40) PARAM -> TIPO_SIMPLE ID . add_id save_parameter PARAM_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    )               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 212

state 187

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters . ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    )               shift and go to state 213


state 188

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters . ) { VARS_PRIME BLOCK } empty_local_variables_table

    )               shift and go to state 214


state 189

    (127) VAR_CT -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one [ EXPRESSION ]
    (27) ver_quad_dimension_one -> .

    [               reduce using rule 27 (ver_quad_dimension_one -> .)
    *               reduce using rule 27 (ver_quad_dimension_one -> .)
    /               reduce using rule 27 (ver_quad_dimension_one -> .)
    +               reduce using rule 27 (ver_quad_dimension_one -> .)
    -               reduce using rule 27 (ver_quad_dimension_one -> .)
    >               reduce using rule 27 (ver_quad_dimension_one -> .)
    <               reduce using rule 27 (ver_quad_dimension_one -> .)
    DIFFERENT       reduce using rule 27 (ver_quad_dimension_one -> .)
    EQUAL           reduce using rule 27 (ver_quad_dimension_one -> .)
    AND             reduce using rule 27 (ver_quad_dimension_one -> .)
    OR              reduce using rule 27 (ver_quad_dimension_one -> .)
    ]               reduce using rule 27 (ver_quad_dimension_one -> .)
    )               reduce using rule 27 (ver_quad_dimension_one -> .)
    ;               reduce using rule 27 (ver_quad_dimension_one -> .)
    ,               reduce using rule 27 (ver_quad_dimension_one -> .)
    TO              reduce using rule 27 (ver_quad_dimension_one -> .)
    FOR             reduce using rule 27 (ver_quad_dimension_one -> .)
    FUNC            reduce using rule 27 (ver_quad_dimension_one -> .)
    PRINT           reduce using rule 27 (ver_quad_dimension_one -> .)
    IF              reduce using rule 27 (ver_quad_dimension_one -> .)
    WHILE           reduce using rule 27 (ver_quad_dimension_one -> .)
    ID              reduce using rule 27 (ver_quad_dimension_one -> .)
    TRUE            reduce using rule 27 (ver_quad_dimension_one -> .)
    FALSE           reduce using rule 27 (ver_quad_dimension_one -> .)
    (               reduce using rule 27 (ver_quad_dimension_one -> .)
    I_CONST         reduce using rule 27 (ver_quad_dimension_one -> .)
    F_CONST         reduce using rule 27 (ver_quad_dimension_one -> .)
    C_CONST         reduce using rule 27 (ver_quad_dimension_one -> .)
    }               reduce using rule 27 (ver_quad_dimension_one -> .)
    RETURN          reduce using rule 27 (ver_quad_dimension_one -> .)

    ver_quad_dimension_one         shift and go to state 215

state 190

    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION . ] check_for_array_length ;

    ]               shift and go to state 216


state 191

    (22) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .

    VAR             reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    FUNC            reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    VOID            reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    FOR             reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    PRINT           reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    IF              reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    WHILE           reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    ID              reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    TRUE            reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    FALSE           reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    (               reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    *               reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    /               reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    I_CONST         reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    F_CONST         reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    C_CONST         reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    }               reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)
    RETURN          reduce using rule 22 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array .)


state 192

    (105) B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 105 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)


state 193

    (106) B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 106 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)


state 194

    (107) B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 107 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)


state 195

    (108) B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FUNC            reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 108 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)


state 196

    (111) EXP_PRIME -> + add_operator TERM EXP_PRIME . aritmetics_operation
    (95) aritmetics_operation -> .

    >               reduce using rule 95 (aritmetics_operation -> .)
    <               reduce using rule 95 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 95 (aritmetics_operation -> .)
    EQUAL           reduce using rule 95 (aritmetics_operation -> .)
    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 217

state 197

    (112) EXP_PRIME -> - add_operator TERM EXP_PRIME . aritmetics_operation
    (95) aritmetics_operation -> .

    >               reduce using rule 95 (aritmetics_operation -> .)
    <               reduce using rule 95 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 95 (aritmetics_operation -> .)
    EQUAL           reduce using rule 95 (aritmetics_operation -> .)
    AND             reduce using rule 95 (aritmetics_operation -> .)
    OR              reduce using rule 95 (aritmetics_operation -> .)
    ]               reduce using rule 95 (aritmetics_operation -> .)
    )               reduce using rule 95 (aritmetics_operation -> .)
    ;               reduce using rule 95 (aritmetics_operation -> .)
    ,               reduce using rule 95 (aritmetics_operation -> .)
    TO              reduce using rule 95 (aritmetics_operation -> .)
    FOR             reduce using rule 95 (aritmetics_operation -> .)
    FUNC            reduce using rule 95 (aritmetics_operation -> .)
    PRINT           reduce using rule 95 (aritmetics_operation -> .)
    IF              reduce using rule 95 (aritmetics_operation -> .)
    WHILE           reduce using rule 95 (aritmetics_operation -> .)
    ID              reduce using rule 95 (aritmetics_operation -> .)
    TRUE            reduce using rule 95 (aritmetics_operation -> .)
    FALSE           reduce using rule 95 (aritmetics_operation -> .)
    (               reduce using rule 95 (aritmetics_operation -> .)
    *               reduce using rule 95 (aritmetics_operation -> .)
    /               reduce using rule 95 (aritmetics_operation -> .)
    I_CONST         reduce using rule 95 (aritmetics_operation -> .)
    F_CONST         reduce using rule 95 (aritmetics_operation -> .)
    C_CONST         reduce using rule 95 (aritmetics_operation -> .)
    }               reduce using rule 95 (aritmetics_operation -> .)
    RETURN          reduce using rule 95 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 218

state 198

    (115) TERM_PRIME -> * add_operator FACTOR aritmetics_operation . TERM_PRIME
    (115) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (116) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (117) TERM_PRIME -> . empty
    (129) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 99
    /               shift and go to state 100
    +               reduce using rule 129 (empty -> .)
    -               reduce using rule 129 (empty -> .)
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

  ! *               [ reduce using rule 129 (empty -> .) ]
  ! /               [ reduce using rule 129 (empty -> .) ]

    TERM_PRIME                     shift and go to state 219
    empty                          shift and go to state 101

state 199

    (116) TERM_PRIME -> / add_operator FACTOR aritmetics_operation . TERM_PRIME
    (115) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (116) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (117) TERM_PRIME -> . empty
    (129) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 99
    /               shift and go to state 100
    +               reduce using rule 129 (empty -> .)
    -               reduce using rule 129 (empty -> .)
    >               reduce using rule 129 (empty -> .)
    <               reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    EQUAL           reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    ]               reduce using rule 129 (empty -> .)
    )               reduce using rule 129 (empty -> .)
    ;               reduce using rule 129 (empty -> .)
    ,               reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

  ! *               [ reduce using rule 129 (empty -> .) ]
  ! /               [ reduce using rule 129 (empty -> .) ]

    TERM_PRIME                     shift and go to state 220
    empty                          shift and go to state 101

state 200

    (65) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION . param_quad FUNC_CALL_PRIME ) go_sub_quad
    (63) param_quad -> .

    ,               reduce using rule 63 (param_quad -> .)
    )               reduce using rule 63 (param_quad -> .)

    param_quad                     shift and go to state 221

state 201

    (94) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 222


state 202

    (29) VARIABLE -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one
    (127) VAR_CT -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one [ EXPRESSION ]

    ]               shift and go to state 223


state 203

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( . EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 224
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 204

    (59) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 225


state 205

    (61) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL . functions_assignation add_assignation_quad
    (126) VAR_CT -> FUNC_CALL .
    (58) functions_assignation -> .

  ! reduce/reduce conflict for * resolved using rule 58 (functions_assignation -> .)
  ! reduce/reduce conflict for / resolved using rule 58 (functions_assignation -> .)
    +               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    -               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    >               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    <               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    DIFFERENT       reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    EQUAL           reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    AND             reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    OR              reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    ;               reduce using rule 126 (VAR_CT -> FUNC_CALL .)
    TO              reduce using rule 58 (functions_assignation -> .)
    FOR             reduce using rule 58 (functions_assignation -> .)
    FUNC            reduce using rule 58 (functions_assignation -> .)
    PRINT           reduce using rule 58 (functions_assignation -> .)
    IF              reduce using rule 58 (functions_assignation -> .)
    WHILE           reduce using rule 58 (functions_assignation -> .)
    ID              reduce using rule 58 (functions_assignation -> .)
    TRUE            reduce using rule 58 (functions_assignation -> .)
    FALSE           reduce using rule 58 (functions_assignation -> .)
    (               reduce using rule 58 (functions_assignation -> .)
    *               reduce using rule 58 (functions_assignation -> .)
    /               reduce using rule 58 (functions_assignation -> .)
    I_CONST         reduce using rule 58 (functions_assignation -> .)
    F_CONST         reduce using rule 58 (functions_assignation -> .)
    C_CONST         reduce using rule 58 (functions_assignation -> .)
    }               reduce using rule 58 (functions_assignation -> .)
    RETURN          reduce using rule 58 (functions_assignation -> .)

  ! *               [ reduce using rule 126 (VAR_CT -> FUNC_CALL .) ]
  ! /               [ reduce using rule 126 (VAR_CT -> FUNC_CALL .) ]

    functions_assignation          shift and go to state 226

state 206

    (60) ASSIGNATION -> FOR VARIABLE = add_operator . EXPRESSION add_assignation_for_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 227
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 207

    (29) VARIABLE -> ID add_id [ . EXPRESSION ] ver_quad_dimension_one
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 228
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 208

    (70) WRITE -> PRINT add_operator ( EXPRESSION . print_quad WRITE_PRIME )
    (68) print_quad -> .

    ,               reduce using rule 68 (print_quad -> .)
    )               reduce using rule 68 (print_quad -> .)

    print_quad                     shift and go to state 229

state 209

    (71) WRITE -> PRINT add_operator ( TITLE . WRITE_PRIME )
    (72) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (74) WRITE_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 231
    )               reduce using rule 129 (empty -> .)

    WRITE_PRIME                    shift and go to state 230
    empty                          shift and go to state 232

state 210

    (84) CONDITION -> IF ( EXPRESSION pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT

    )               shift and go to state 233


state 211

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION . pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (82) pop_type -> .

    )               reduce using rule 82 (pop_type -> .)

    pop_type                       shift and go to state 234

state 212

    (40) PARAM -> TIPO_SIMPLE ID add_id . save_parameter PARAM_PRIME
    (8) save_parameter -> .

    ,               reduce using rule 8 (save_parameter -> .)
    )               reduce using rule 8 (save_parameter -> .)

    save_parameter                 shift and go to state 235

state 213

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) . save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (35) save_function_as_variable -> .

    {               reduce using rule 35 (save_function_as_variable -> .)

    save_function_as_variable      shift and go to state 236

state 214

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) . { VARS_PRIME BLOCK } empty_local_variables_table

    {               shift and go to state 237


state 215

    (127) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .
    (128) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one . [ EXPRESSION ]

    *               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    /               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    +               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    -               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    >               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    <               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    DIFFERENT       reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    EQUAL           reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    AND             reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    OR              reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    ]               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    )               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    ;               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    ,               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    TO              reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    FOR             reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    FUNC            reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    PRINT           reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    IF              reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    WHILE           reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    ID              reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    TRUE            reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    FALSE           reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    (               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    I_CONST         reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    F_CONST         reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    C_CONST         reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    }               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    RETURN          reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    [               shift and go to state 238


state 216

    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] . check_for_array_length ;
    (18) check_for_array_length -> .

    ;               reduce using rule 18 (check_for_array_length -> .)

    check_for_array_length         shift and go to state 239

state 217

    (111) EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FUNC            reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 111 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)


state 218

    (112) EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FUNC            reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 112 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)


state 219

    (115) TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FUNC            reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 115 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 220

    (116) TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FUNC            reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 116 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 221

    (65) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad . FUNC_CALL_PRIME ) go_sub_quad
    (66) FUNC_CALL_PRIME -> . , EXPRESSION param_quad FUNC_CALL_PRIME
    (67) FUNC_CALL_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 241
    )               reduce using rule 129 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 240
    empty                          shift and go to state 242

state 222

    (94) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    FOR             reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FUNC            reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    ID              reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    TRUE            reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FALSE           reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    (               reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    *               reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    /               reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    I_CONST         reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    F_CONST         reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    C_CONST         reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 94 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 223

    (29) VARIABLE -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one
    (127) VAR_CT -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one
    (128) VAR_CT -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one [ EXPRESSION ]
    (27) ver_quad_dimension_one -> .

    [               reduce using rule 27 (ver_quad_dimension_one -> .)
    =               reduce using rule 27 (ver_quad_dimension_one -> .)
    *               reduce using rule 27 (ver_quad_dimension_one -> .)
    /               reduce using rule 27 (ver_quad_dimension_one -> .)
    +               reduce using rule 27 (ver_quad_dimension_one -> .)
    -               reduce using rule 27 (ver_quad_dimension_one -> .)
    >               reduce using rule 27 (ver_quad_dimension_one -> .)
    <               reduce using rule 27 (ver_quad_dimension_one -> .)
    DIFFERENT       reduce using rule 27 (ver_quad_dimension_one -> .)
    EQUAL           reduce using rule 27 (ver_quad_dimension_one -> .)
    AND             reduce using rule 27 (ver_quad_dimension_one -> .)
    OR              reduce using rule 27 (ver_quad_dimension_one -> .)
    ;               reduce using rule 27 (ver_quad_dimension_one -> .)
    ]               reduce using rule 27 (ver_quad_dimension_one -> .)

    ver_quad_dimension_one         shift and go to state 243

state 224

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION . check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (88) check_exact_type_for -> .

    )               reduce using rule 88 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 244

state 225

    (59) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (56) add_assignation_quad -> .

    TO              reduce using rule 56 (add_assignation_quad -> .)
    FOR             reduce using rule 56 (add_assignation_quad -> .)
    FUNC            reduce using rule 56 (add_assignation_quad -> .)
    PRINT           reduce using rule 56 (add_assignation_quad -> .)
    IF              reduce using rule 56 (add_assignation_quad -> .)
    WHILE           reduce using rule 56 (add_assignation_quad -> .)
    ID              reduce using rule 56 (add_assignation_quad -> .)
    TRUE            reduce using rule 56 (add_assignation_quad -> .)
    FALSE           reduce using rule 56 (add_assignation_quad -> .)
    (               reduce using rule 56 (add_assignation_quad -> .)
    *               reduce using rule 56 (add_assignation_quad -> .)
    /               reduce using rule 56 (add_assignation_quad -> .)
    I_CONST         reduce using rule 56 (add_assignation_quad -> .)
    F_CONST         reduce using rule 56 (add_assignation_quad -> .)
    C_CONST         reduce using rule 56 (add_assignation_quad -> .)
    }               reduce using rule 56 (add_assignation_quad -> .)
    RETURN          reduce using rule 56 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 245

state 226

    (61) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation . add_assignation_quad
    (56) add_assignation_quad -> .

    TO              reduce using rule 56 (add_assignation_quad -> .)
    FOR             reduce using rule 56 (add_assignation_quad -> .)
    FUNC            reduce using rule 56 (add_assignation_quad -> .)
    PRINT           reduce using rule 56 (add_assignation_quad -> .)
    IF              reduce using rule 56 (add_assignation_quad -> .)
    WHILE           reduce using rule 56 (add_assignation_quad -> .)
    ID              reduce using rule 56 (add_assignation_quad -> .)
    TRUE            reduce using rule 56 (add_assignation_quad -> .)
    FALSE           reduce using rule 56 (add_assignation_quad -> .)
    (               reduce using rule 56 (add_assignation_quad -> .)
    *               reduce using rule 56 (add_assignation_quad -> .)
    /               reduce using rule 56 (add_assignation_quad -> .)
    I_CONST         reduce using rule 56 (add_assignation_quad -> .)
    F_CONST         reduce using rule 56 (add_assignation_quad -> .)
    C_CONST         reduce using rule 56 (add_assignation_quad -> .)
    }               reduce using rule 56 (add_assignation_quad -> .)
    RETURN          reduce using rule 56 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 246

state 227

    (60) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION . add_assignation_for_quad
    (57) add_assignation_for_quad -> .

    TO              reduce using rule 57 (add_assignation_for_quad -> .)
    FOR             reduce using rule 57 (add_assignation_for_quad -> .)
    FUNC            reduce using rule 57 (add_assignation_for_quad -> .)
    PRINT           reduce using rule 57 (add_assignation_for_quad -> .)
    IF              reduce using rule 57 (add_assignation_for_quad -> .)
    WHILE           reduce using rule 57 (add_assignation_for_quad -> .)
    ID              reduce using rule 57 (add_assignation_for_quad -> .)
    TRUE            reduce using rule 57 (add_assignation_for_quad -> .)
    FALSE           reduce using rule 57 (add_assignation_for_quad -> .)
    (               reduce using rule 57 (add_assignation_for_quad -> .)
    *               reduce using rule 57 (add_assignation_for_quad -> .)
    /               reduce using rule 57 (add_assignation_for_quad -> .)
    I_CONST         reduce using rule 57 (add_assignation_for_quad -> .)
    F_CONST         reduce using rule 57 (add_assignation_for_quad -> .)
    C_CONST         reduce using rule 57 (add_assignation_for_quad -> .)
    }               reduce using rule 57 (add_assignation_for_quad -> .)
    RETURN          reduce using rule 57 (add_assignation_for_quad -> .)

    add_assignation_for_quad       shift and go to state 247

state 228

    (29) VARIABLE -> ID add_id [ EXPRESSION . ] ver_quad_dimension_one

    ]               shift and go to state 248


state 229

    (70) WRITE -> PRINT add_operator ( EXPRESSION print_quad . WRITE_PRIME )
    (72) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (74) WRITE_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 231
    )               reduce using rule 129 (empty -> .)

    WRITE_PRIME                    shift and go to state 249
    empty                          shift and go to state 232

state 230

    (71) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME . )

    )               shift and go to state 250


state 231

    (72) WRITE_PRIME -> , . add_print_operator EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> , . add_print_operator TITLE print_quad WRITE_PRIME
    (69) add_print_operator -> .

    TITLE           reduce using rule 69 (add_print_operator -> .)
    TRUE            reduce using rule 69 (add_print_operator -> .)
    FALSE           reduce using rule 69 (add_print_operator -> .)
    (               reduce using rule 69 (add_print_operator -> .)
    *               reduce using rule 69 (add_print_operator -> .)
    /               reduce using rule 69 (add_print_operator -> .)
    ID              reduce using rule 69 (add_print_operator -> .)
    I_CONST         reduce using rule 69 (add_print_operator -> .)
    F_CONST         reduce using rule 69 (add_print_operator -> .)
    C_CONST         reduce using rule 69 (add_print_operator -> .)
    FUNC            reduce using rule 69 (add_print_operator -> .)

    add_print_operator             shift and go to state 251

state 232

    (74) WRITE_PRIME -> empty .

    )               reduce using rule 74 (WRITE_PRIME -> empty .)


state 233

    (84) CONDITION -> IF ( EXPRESSION pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT

    {               shift and go to state 252


state 234

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type . ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    )               shift and go to state 253


state 235

    (40) PARAM -> TIPO_SIMPLE ID add_id save_parameter . PARAM_PRIME
    (42) PARAM_PRIME -> . , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (43) PARAM_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 255
    )               reduce using rule 129 (empty -> .)

    PARAM_PRIME                    shift and go to state 254
    empty                          shift and go to state 256

state 236

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable . { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table

    {               shift and go to state 257


state 237

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { . VARS_PRIME BLOCK } empty_local_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (20) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (129) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)

    VARS_PRIME                     shift and go to state 258
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 238

    (128) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ . EXPRESSION ]
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 259
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 239

    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length . ;

    ;               shift and go to state 260


state 240

    (65) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME . ) go_sub_quad

    )               shift and go to state 261


state 241

    (66) FUNC_CALL_PRIME -> , . EXPRESSION param_quad FUNC_CALL_PRIME
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 262
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 242

    (67) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 67 (FUNC_CALL_PRIME -> empty .)


state 243

    (29) VARIABLE -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .
    (127) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .
    (128) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one . [ EXPRESSION ]

    =               reduce using rule 29 (VARIABLE -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    *               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    /               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    +               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    -               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    >               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    <               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    DIFFERENT       reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    EQUAL           reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    AND             reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    OR              reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    ;               reduce using rule 127 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)
    [               shift and go to state 238


state 244

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for . add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (89) add_final_counter_for -> .

    )               reduce using rule 89 (add_final_counter_for -> .)

    add_final_counter_for          shift and go to state 263

state 245

    (59) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    TO              reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FUNC            reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    ID              reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    TRUE            reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FALSE           reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    (               reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    *               reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    /               reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    I_CONST         reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    F_CONST         reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    C_CONST         reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 59 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 246

    (61) ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .

    TO              reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FOR             reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FUNC            reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    PRINT           reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    IF              reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    WHILE           reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    ID              reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    TRUE            reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    FALSE           reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    (               reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    *               reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    /               reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    I_CONST         reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    F_CONST         reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    C_CONST         reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    }               reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)
    RETURN          reduce using rule 61 (ASSIGNATION -> VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad .)


state 247

    (60) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .

    TO              reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FOR             reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FUNC            reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    PRINT           reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    IF              reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    WHILE           reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    ID              reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    TRUE            reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FALSE           reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    (               reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    *               reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    /               reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    I_CONST         reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    F_CONST         reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    C_CONST         reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    }               reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    RETURN          reduce using rule 60 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)


state 248

    (29) VARIABLE -> ID add_id [ EXPRESSION ] . ver_quad_dimension_one
    (27) ver_quad_dimension_one -> .

    =               reduce using rule 27 (ver_quad_dimension_one -> .)

    ver_quad_dimension_one         shift and go to state 264

state 249

    (70) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME . )

    )               shift and go to state 265


state 250

    (71) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .

    ;               reduce using rule 71 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)


state 251

    (72) WRITE_PRIME -> , add_print_operator . EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> , add_print_operator . TITLE print_quad WRITE_PRIME
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TITLE           shift and go to state 267
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 266
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 252

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (75) go_to_false_quad -> .

    FOR             reduce using rule 75 (go_to_false_quad -> .)
    FUNC            reduce using rule 75 (go_to_false_quad -> .)
    PRINT           reduce using rule 75 (go_to_false_quad -> .)
    IF              reduce using rule 75 (go_to_false_quad -> .)
    WHILE           reduce using rule 75 (go_to_false_quad -> .)
    ID              reduce using rule 75 (go_to_false_quad -> .)
    TRUE            reduce using rule 75 (go_to_false_quad -> .)
    FALSE           reduce using rule 75 (go_to_false_quad -> .)
    (               reduce using rule 75 (go_to_false_quad -> .)
    *               reduce using rule 75 (go_to_false_quad -> .)
    /               reduce using rule 75 (go_to_false_quad -> .)
    I_CONST         reduce using rule 75 (go_to_false_quad -> .)
    F_CONST         reduce using rule 75 (go_to_false_quad -> .)
    C_CONST         reduce using rule 75 (go_to_false_quad -> .)
    }               reduce using rule 75 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 268

state 253

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) . { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand

    {               shift and go to state 269


state 254

    (40) PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .

    )               reduce using rule 40 (PARAM -> TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .)


state 255

    (42) PARAM_PRIME -> , . TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (30) TIPO_SIMPLE -> . INT add_type
    (31) TIPO_SIMPLE -> . FLOAT add_type
    (32) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    TIPO_SIMPLE                    shift and go to state 270

state 256

    (43) PARAM_PRIME -> empty .

    )               reduce using rule 43 (PARAM_PRIME -> empty .)


state 257

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { . VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (10) VARS_PRIME -> . VARS VARS_PRIME
    (11) VARS_PRIME -> . empty
    (20) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (21) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (22) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length ; save_array
    (23) VARS -> . VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ;
    (129) empty -> .

    VAR             shift and go to state 12
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    VARS_PRIME                     shift and go to state 271
    VARS                           shift and go to state 10
    empty                          shift and go to state 11

state 258

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME . BLOCK } empty_local_variables_table
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    BLOCK                          shift and go to state 272
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    EXPRESSION                     shift and go to state 115
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 259

    (128) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION . ]

    ]               shift and go to state 273


state 260

    (23) VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .

    VAR             reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    FUNC            reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    VOID            reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    FOR             reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    PRINT           reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    IF              reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    WHILE           reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    ID              reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    TRUE            reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    FALSE           reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    (               reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    *               reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    /               reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    I_CONST         reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    F_CONST         reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    C_CONST         reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    }               reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)
    RETURN          reduce using rule 23 (VARS -> VAR TIPO_SIMPLE ID add_id [ EXPRESSION ] check_for_array_length [ EXPRESSION ] check_for_array_length ; .)


state 261

    (65) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) . go_sub_quad
    (64) go_sub_quad -> .

    *               reduce using rule 64 (go_sub_quad -> .)
    /               reduce using rule 64 (go_sub_quad -> .)
    +               reduce using rule 64 (go_sub_quad -> .)
    -               reduce using rule 64 (go_sub_quad -> .)
    >               reduce using rule 64 (go_sub_quad -> .)
    <               reduce using rule 64 (go_sub_quad -> .)
    DIFFERENT       reduce using rule 64 (go_sub_quad -> .)
    EQUAL           reduce using rule 64 (go_sub_quad -> .)
    AND             reduce using rule 64 (go_sub_quad -> .)
    OR              reduce using rule 64 (go_sub_quad -> .)
    ]               reduce using rule 64 (go_sub_quad -> .)
    )               reduce using rule 64 (go_sub_quad -> .)
    ;               reduce using rule 64 (go_sub_quad -> .)
    ,               reduce using rule 64 (go_sub_quad -> .)
    TO              reduce using rule 64 (go_sub_quad -> .)
    FOR             reduce using rule 64 (go_sub_quad -> .)
    FUNC            reduce using rule 64 (go_sub_quad -> .)
    PRINT           reduce using rule 64 (go_sub_quad -> .)
    IF              reduce using rule 64 (go_sub_quad -> .)
    WHILE           reduce using rule 64 (go_sub_quad -> .)
    ID              reduce using rule 64 (go_sub_quad -> .)
    TRUE            reduce using rule 64 (go_sub_quad -> .)
    FALSE           reduce using rule 64 (go_sub_quad -> .)
    (               reduce using rule 64 (go_sub_quad -> .)
    I_CONST         reduce using rule 64 (go_sub_quad -> .)
    F_CONST         reduce using rule 64 (go_sub_quad -> .)
    C_CONST         reduce using rule 64 (go_sub_quad -> .)
    }               reduce using rule 64 (go_sub_quad -> .)
    RETURN          reduce using rule 64 (go_sub_quad -> .)

    go_sub_quad                    shift and go to state 274

state 262

    (66) FUNC_CALL_PRIME -> , EXPRESSION . param_quad FUNC_CALL_PRIME
    (63) param_quad -> .

    ,               reduce using rule 63 (param_quad -> .)
    )               reduce using rule 63 (param_quad -> .)

    param_quad                     shift and go to state 275

state 263

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for . check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (91) check_boolean_expression_for -> .

    )               reduce using rule 91 (check_boolean_expression_for -> .)

    check_boolean_expression_for   shift and go to state 276

state 264

    (29) VARIABLE -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .

    =               reduce using rule 29 (VARIABLE -> ID add_id [ EXPRESSION ] ver_quad_dimension_one .)


state 265

    (70) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .

    ;               reduce using rule 70 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)


state 266

    (72) WRITE_PRIME -> , add_print_operator EXPRESSION . print_quad WRITE_PRIME
    (68) print_quad -> .

    ,               reduce using rule 68 (print_quad -> .)
    )               reduce using rule 68 (print_quad -> .)

    print_quad                     shift and go to state 277

state 267

    (73) WRITE_PRIME -> , add_print_operator TITLE . print_quad WRITE_PRIME
    (68) print_quad -> .

    ,               reduce using rule 68 (print_quad -> .)
    )               reduce using rule 68 (print_quad -> .)

    print_quad                     shift and go to state 278

state 268

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    EXPRESSION                     shift and go to state 115
    BLOCK                          shift and go to state 279
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 269

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { . go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (75) go_to_false_quad -> .

    FOR             reduce using rule 75 (go_to_false_quad -> .)
    FUNC            reduce using rule 75 (go_to_false_quad -> .)
    PRINT           reduce using rule 75 (go_to_false_quad -> .)
    IF              reduce using rule 75 (go_to_false_quad -> .)
    WHILE           reduce using rule 75 (go_to_false_quad -> .)
    ID              reduce using rule 75 (go_to_false_quad -> .)
    TRUE            reduce using rule 75 (go_to_false_quad -> .)
    FALSE           reduce using rule 75 (go_to_false_quad -> .)
    (               reduce using rule 75 (go_to_false_quad -> .)
    *               reduce using rule 75 (go_to_false_quad -> .)
    /               reduce using rule 75 (go_to_false_quad -> .)
    I_CONST         reduce using rule 75 (go_to_false_quad -> .)
    F_CONST         reduce using rule 75 (go_to_false_quad -> .)
    C_CONST         reduce using rule 75 (go_to_false_quad -> .)
    }               reduce using rule 75 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 280

state 270

    (42) PARAM_PRIME -> , TIPO_SIMPLE . ID add_id save_parameter PARAM_PRIME

    ID              shift and go to state 281


state 271

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME . BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    RETURN          reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    BLOCK                          shift and go to state 282
    EXPRESSION                     shift and go to state 115
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 272

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK . } empty_local_variables_table

    }               shift and go to state 283


state 273

    (128) VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .

    *               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    /               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    +               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    -               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    >               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    <               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    DIFFERENT       reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    EQUAL           reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    AND             reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    OR              reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    ]               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    )               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    ;               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    ,               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    TO              reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    FOR             reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    FUNC            reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    PRINT           reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    IF              reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    WHILE           reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    ID              reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    TRUE            reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    FALSE           reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    (               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    I_CONST         reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    F_CONST         reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    C_CONST         reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    }               reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)
    RETURN          reduce using rule 128 (VAR_CT -> ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ] .)


state 274

    (65) FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .

    *               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    /               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    +               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    -               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    >               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    <               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    DIFFERENT       reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    EQUAL           reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    AND             reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    OR              reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ]               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    )               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ;               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ,               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    TO              reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FOR             reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FUNC            reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    PRINT           reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    IF              reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    WHILE           reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    ID              reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    TRUE            reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    FALSE           reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    (               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    I_CONST         reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    F_CONST         reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    C_CONST         reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    }               reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)
    RETURN          reduce using rule 65 (FUNC_CALL -> FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad .)


state 275

    (66) FUNC_CALL_PRIME -> , EXPRESSION param_quad . FUNC_CALL_PRIME
    (66) FUNC_CALL_PRIME -> . , EXPRESSION param_quad FUNC_CALL_PRIME
    (67) FUNC_CALL_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 241
    )               reduce using rule 129 (empty -> .)

    FUNC_CALL_PRIME                shift and go to state 284
    empty                          shift and go to state 242

state 276

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for . ) generate_for_quad DO { BLOCK } end_for

    )               shift and go to state 285


state 277

    (72) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad . WRITE_PRIME
    (72) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (74) WRITE_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 231
    )               reduce using rule 129 (empty -> .)

    WRITE_PRIME                    shift and go to state 286
    empty                          shift and go to state 232

state 278

    (73) WRITE_PRIME -> , add_print_operator TITLE print_quad . WRITE_PRIME
    (72) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (73) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (74) WRITE_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 231
    )               reduce using rule 129 (empty -> .)

    WRITE_PRIME                    shift and go to state 287
    empty                          shift and go to state 232

state 279

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad_if ELSE_STMT

    }               shift and go to state 288


state 280

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad . BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    EXPRESSION                     shift and go to state 115
    BLOCK                          shift and go to state 289
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 281

    (42) PARAM_PRIME -> , TIPO_SIMPLE ID . add_id save_parameter PARAM_PRIME
    (6) add_id -> .

    ,               reduce using rule 6 (add_id -> .)
    )               reduce using rule 6 (add_id -> .)

    add_id                         shift and go to state 290

state 282

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK . RETURN EXPRESSION ; return_quad } empty_local_variables_table

    RETURN          shift and go to state 291


state 283

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } . empty_local_variables_table
    (4) empty_local_variables_table -> .

    FUNC            reduce using rule 4 (empty_local_variables_table -> .)
    VOID            reduce using rule 4 (empty_local_variables_table -> .)

    empty_local_variables_table    shift and go to state 292

state 284

    (66) FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME .

    )               reduce using rule 66 (FUNC_CALL_PRIME -> , EXPRESSION param_quad FUNC_CALL_PRIME .)


state 285

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) . generate_for_quad DO { BLOCK } end_for
    (90) generate_for_quad -> .

    DO              reduce using rule 90 (generate_for_quad -> .)

    generate_for_quad              shift and go to state 293

state 286

    (72) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .

    )               reduce using rule 72 (WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .)


state 287

    (73) WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .

    )               reduce using rule 73 (WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .)


state 288

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad_if ELSE_STMT
    (77) fill_go_to_false_quad_if -> .

    ELSE            reduce using rule 77 (fill_go_to_false_quad_if -> .)
    FOR             reduce using rule 77 (fill_go_to_false_quad_if -> .)
    FUNC            reduce using rule 77 (fill_go_to_false_quad_if -> .)
    PRINT           reduce using rule 77 (fill_go_to_false_quad_if -> .)
    IF              reduce using rule 77 (fill_go_to_false_quad_if -> .)
    WHILE           reduce using rule 77 (fill_go_to_false_quad_if -> .)
    ID              reduce using rule 77 (fill_go_to_false_quad_if -> .)
    TRUE            reduce using rule 77 (fill_go_to_false_quad_if -> .)
    FALSE           reduce using rule 77 (fill_go_to_false_quad_if -> .)
    (               reduce using rule 77 (fill_go_to_false_quad_if -> .)
    *               reduce using rule 77 (fill_go_to_false_quad_if -> .)
    /               reduce using rule 77 (fill_go_to_false_quad_if -> .)
    I_CONST         reduce using rule 77 (fill_go_to_false_quad_if -> .)
    F_CONST         reduce using rule 77 (fill_go_to_false_quad_if -> .)
    C_CONST         reduce using rule 77 (fill_go_to_false_quad_if -> .)
    }               reduce using rule 77 (fill_go_to_false_quad_if -> .)
    RETURN          reduce using rule 77 (fill_go_to_false_quad_if -> .)

    fill_go_to_false_quad_if       shift and go to state 294

state 289

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK . } fill_go_to_false_quad go_to_quad pop_operand

    }               shift and go to state 295


state 290

    (42) PARAM_PRIME -> , TIPO_SIMPLE ID add_id . save_parameter PARAM_PRIME
    (8) save_parameter -> .

    ,               reduce using rule 8 (save_parameter -> .)
    )               reduce using rule 8 (save_parameter -> .)

    save_parameter                 shift and go to state 296

state 291

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN . EXPRESSION ; return_quad } empty_local_variables_table
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    ID              shift and go to state 55
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70
    FUNC            shift and go to state 72

    EXPRESSION                     shift and go to state 297
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66
    FUNC_CALL                      shift and go to state 71

state 292

    (38) FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .

    FUNC            reduce using rule 38 (FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .)
    VOID            reduce using rule 38 (FUNCTION -> FUNC VOID add_type ID add_id save_function ( PARAM add_parameters ) { VARS_PRIME BLOCK } empty_local_variables_table .)


state 293

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad . DO { BLOCK } end_for

    DO              shift and go to state 298


state 294

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if . ELSE_STMT
    (85) ELSE_STMT -> . ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
    (86) ELSE_STMT -> . empty pop_operand
    (129) empty -> .

    ELSE            shift and go to state 300
    FOR             reduce using rule 129 (empty -> .)
    FUNC            reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    IF              reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    TRUE            reduce using rule 129 (empty -> .)
    FALSE           reduce using rule 129 (empty -> .)
    (               reduce using rule 129 (empty -> .)
    *               reduce using rule 129 (empty -> .)
    /               reduce using rule 129 (empty -> .)
    I_CONST         reduce using rule 129 (empty -> .)
    F_CONST         reduce using rule 129 (empty -> .)
    C_CONST         reduce using rule 129 (empty -> .)
    }               reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)

    ELSE_STMT                      shift and go to state 299
    empty                          shift and go to state 301

state 295

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } . fill_go_to_false_quad go_to_quad pop_operand
    (76) fill_go_to_false_quad -> .

    FOR             reduce using rule 76 (fill_go_to_false_quad -> .)
    FUNC            reduce using rule 76 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 76 (fill_go_to_false_quad -> .)
    IF              reduce using rule 76 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 76 (fill_go_to_false_quad -> .)
    ID              reduce using rule 76 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 76 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 76 (fill_go_to_false_quad -> .)
    (               reduce using rule 76 (fill_go_to_false_quad -> .)
    *               reduce using rule 76 (fill_go_to_false_quad -> .)
    /               reduce using rule 76 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 76 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 76 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 76 (fill_go_to_false_quad -> .)
    }               reduce using rule 76 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 76 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 302

state 296

    (42) PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter . PARAM_PRIME
    (42) PARAM_PRIME -> . , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME
    (43) PARAM_PRIME -> . empty
    (129) empty -> .

    ,               shift and go to state 255
    )               reduce using rule 129 (empty -> .)

    PARAM_PRIME                    shift and go to state 303
    empty                          shift and go to state 256

state 297

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION . ; return_quad } empty_local_variables_table

    ;               shift and go to state 304


state 298

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO . { BLOCK } end_for

    {               shift and go to state 305


state 299

    (84) CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .

    FOR             reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    FUNC            reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    PRINT           reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    IF              reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    WHILE           reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    ID              reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    TRUE            reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    FALSE           reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    (               reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    *               reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    /               reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    I_CONST         reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    F_CONST         reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    C_CONST         reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    }               reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)
    RETURN          reduce using rule 84 (CONDITION -> IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT .)


state 300

    (85) ELSE_STMT -> ELSE . { go_to_true_quad BLOCK } fill_go_to_true_quad

    {               shift and go to state 306


state 301

    (86) ELSE_STMT -> empty . pop_operand
    (81) pop_operand -> .

    FOR             reduce using rule 81 (pop_operand -> .)
    FUNC            reduce using rule 81 (pop_operand -> .)
    PRINT           reduce using rule 81 (pop_operand -> .)
    IF              reduce using rule 81 (pop_operand -> .)
    WHILE           reduce using rule 81 (pop_operand -> .)
    ID              reduce using rule 81 (pop_operand -> .)
    TRUE            reduce using rule 81 (pop_operand -> .)
    FALSE           reduce using rule 81 (pop_operand -> .)
    (               reduce using rule 81 (pop_operand -> .)
    *               reduce using rule 81 (pop_operand -> .)
    /               reduce using rule 81 (pop_operand -> .)
    I_CONST         reduce using rule 81 (pop_operand -> .)
    F_CONST         reduce using rule 81 (pop_operand -> .)
    C_CONST         reduce using rule 81 (pop_operand -> .)
    }               reduce using rule 81 (pop_operand -> .)
    RETURN          reduce using rule 81 (pop_operand -> .)

    pop_operand                    shift and go to state 307

state 302

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad . go_to_quad pop_operand
    (80) go_to_quad -> .

    FOR             reduce using rule 80 (go_to_quad -> .)
    FUNC            reduce using rule 80 (go_to_quad -> .)
    PRINT           reduce using rule 80 (go_to_quad -> .)
    IF              reduce using rule 80 (go_to_quad -> .)
    WHILE           reduce using rule 80 (go_to_quad -> .)
    ID              reduce using rule 80 (go_to_quad -> .)
    TRUE            reduce using rule 80 (go_to_quad -> .)
    FALSE           reduce using rule 80 (go_to_quad -> .)
    (               reduce using rule 80 (go_to_quad -> .)
    *               reduce using rule 80 (go_to_quad -> .)
    /               reduce using rule 80 (go_to_quad -> .)
    I_CONST         reduce using rule 80 (go_to_quad -> .)
    F_CONST         reduce using rule 80 (go_to_quad -> .)
    C_CONST         reduce using rule 80 (go_to_quad -> .)
    }               reduce using rule 80 (go_to_quad -> .)
    RETURN          reduce using rule 80 (go_to_quad -> .)

    go_to_quad                     shift and go to state 308

state 303

    (42) PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .

    )               reduce using rule 42 (PARAM_PRIME -> , TIPO_SIMPLE ID add_id save_parameter PARAM_PRIME .)


state 304

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; . return_quad } empty_local_variables_table
    (36) return_quad -> .

    }               reduce using rule 36 (return_quad -> .)

    return_quad                    shift and go to state 309

state 305

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { . BLOCK } end_for
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    ASSIGNATION                    shift and go to state 113
    EXPRESSION                     shift and go to state 115
    BLOCK                          shift and go to state 310
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    FUNC_CALL                      shift and go to state 114
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 306

    (85) ELSE_STMT -> ELSE { . go_to_true_quad BLOCK } fill_go_to_true_quad
    (78) go_to_true_quad -> .

    FOR             reduce using rule 78 (go_to_true_quad -> .)
    FUNC            reduce using rule 78 (go_to_true_quad -> .)
    PRINT           reduce using rule 78 (go_to_true_quad -> .)
    IF              reduce using rule 78 (go_to_true_quad -> .)
    WHILE           reduce using rule 78 (go_to_true_quad -> .)
    ID              reduce using rule 78 (go_to_true_quad -> .)
    TRUE            reduce using rule 78 (go_to_true_quad -> .)
    FALSE           reduce using rule 78 (go_to_true_quad -> .)
    (               reduce using rule 78 (go_to_true_quad -> .)
    *               reduce using rule 78 (go_to_true_quad -> .)
    /               reduce using rule 78 (go_to_true_quad -> .)
    I_CONST         reduce using rule 78 (go_to_true_quad -> .)
    F_CONST         reduce using rule 78 (go_to_true_quad -> .)
    C_CONST         reduce using rule 78 (go_to_true_quad -> .)
    }               reduce using rule 78 (go_to_true_quad -> .)

    go_to_true_quad                shift and go to state 311

state 307

    (86) ELSE_STMT -> empty pop_operand .

    FOR             reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    FUNC            reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    PRINT           reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    IF              reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    WHILE           reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    ID              reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    TRUE            reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    FALSE           reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    (               reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    *               reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    /               reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    I_CONST         reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    F_CONST         reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    C_CONST         reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    }               reduce using rule 86 (ELSE_STMT -> empty pop_operand .)
    RETURN          reduce using rule 86 (ELSE_STMT -> empty pop_operand .)


state 308

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad . pop_operand
    (81) pop_operand -> .

    FOR             reduce using rule 81 (pop_operand -> .)
    FUNC            reduce using rule 81 (pop_operand -> .)
    PRINT           reduce using rule 81 (pop_operand -> .)
    IF              reduce using rule 81 (pop_operand -> .)
    WHILE           reduce using rule 81 (pop_operand -> .)
    ID              reduce using rule 81 (pop_operand -> .)
    TRUE            reduce using rule 81 (pop_operand -> .)
    FALSE           reduce using rule 81 (pop_operand -> .)
    (               reduce using rule 81 (pop_operand -> .)
    *               reduce using rule 81 (pop_operand -> .)
    /               reduce using rule 81 (pop_operand -> .)
    I_CONST         reduce using rule 81 (pop_operand -> .)
    F_CONST         reduce using rule 81 (pop_operand -> .)
    C_CONST         reduce using rule 81 (pop_operand -> .)
    }               reduce using rule 81 (pop_operand -> .)
    RETURN          reduce using rule 81 (pop_operand -> .)

    pop_operand                    shift and go to state 312

state 309

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad . } empty_local_variables_table

    }               shift and go to state 313


state 310

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK . } end_for

    }               shift and go to state 314


state 311

    (85) ELSE_STMT -> ELSE { go_to_true_quad . BLOCK } fill_go_to_true_quad
    (44) BLOCK -> . STATEMENT BLOCK
    (45) BLOCK -> . empty
    (46) STATEMENT -> . ASSIGNATION
    (47) STATEMENT -> . FUNC_CALL
    (48) STATEMENT -> . EXPRESSION ;
    (49) STATEMENT -> . WRITE ;
    (50) STATEMENT -> . CONDITION
    (51) STATEMENT -> . WHILE_STMT
    (52) STATEMENT -> . FOR_STMT
    (53) STATEMENT -> . DESCRIBE_STMT
    (129) empty -> .
    (59) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (60) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (61) ASSIGNATION -> . VARIABLE = add_operator FUNC_CALL functions_assignation add_assignation_quad
    (65) FUNC_CALL -> . FUNC ID era_quad ( EXPRESSION param_quad FUNC_CALL_PRIME ) go_sub_quad
    (96) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (70) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (71) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (84) CONDITION -> . IF ( EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad_if ELSE_STMT
    (87) WHILE_STMT -> . WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand
    (93) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (94) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (28) VARIABLE -> . ID get_variable
    (29) VARIABLE -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (99) AND_EXP -> . B_EXP AND_EXP_PRIME
    (102) B_EXP -> . TRUE
    (103) B_EXP -> . FALSE
    (104) B_EXP -> . EXP B_EXP_PRIME
    (110) EXP -> . TERM EXP_PRIME
    (114) TERM -> . FACTOR TERM_PRIME
    (118) FACTOR -> . ( EXPRESSION )
    (119) FACTOR -> . * VAR_CT
    (120) FACTOR -> . / VAR_CT
    (121) FACTOR -> . VAR_CT
    (122) VAR_CT -> . ID add_operand
    (123) VAR_CT -> . I_CONST add_operand
    (124) VAR_CT -> . F_CONST add_operand
    (125) VAR_CT -> . C_CONST add_operand
    (126) VAR_CT -> . FUNC_CALL
    (127) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one
    (128) VAR_CT -> . ID add_id [ EXPRESSION ] ver_quad_dimension_one [ EXPRESSION ]

    }               reduce using rule 129 (empty -> .)
    FOR             shift and go to state 122
    FUNC            shift and go to state 72
    PRINT           shift and go to state 123
    IF              shift and go to state 124
    WHILE           shift and go to state 125
    ID              shift and go to state 109
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    (               shift and go to state 64
    *               shift and go to state 65
    /               shift and go to state 67
    I_CONST         shift and go to state 68
    F_CONST         shift and go to state 69
    C_CONST         shift and go to state 70

    BLOCK                          shift and go to state 315
    STATEMENT                      shift and go to state 111
    empty                          shift and go to state 112
    ASSIGNATION                    shift and go to state 113
    FUNC_CALL                      shift and go to state 114
    EXPRESSION                     shift and go to state 115
    WRITE                          shift and go to state 116
    CONDITION                      shift and go to state 117
    WHILE_STMT                     shift and go to state 118
    FOR_STMT                       shift and go to state 119
    DESCRIBE_STMT                  shift and go to state 120
    VARIABLE                       shift and go to state 121
    AND_EXP                        shift and go to state 57
    B_EXP                          shift and go to state 58
    EXP                            shift and go to state 61
    TERM                           shift and go to state 62
    FACTOR                         shift and go to state 63
    VAR_CT                         shift and go to state 66

state 312

    (87) WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .

    FOR             reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    FUNC            reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    PRINT           reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    IF              reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    WHILE           reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    ID              reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    TRUE            reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    FALSE           reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    (               reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    *               reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    /               reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    I_CONST         reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    F_CONST         reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    C_CONST         reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    }               reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)
    RETURN          reduce using rule 87 (WHILE_STMT -> WHILE ( append_jump EXPRESSION pop_type ) { go_to_false_quad BLOCK } fill_go_to_false_quad go_to_quad pop_operand .)


state 313

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } . empty_local_variables_table
    (4) empty_local_variables_table -> .

    FUNC            reduce using rule 4 (empty_local_variables_table -> .)
    VOID            reduce using rule 4 (empty_local_variables_table -> .)

    empty_local_variables_table    shift and go to state 316

state 314

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } . end_for
    (92) end_for -> .

    FOR             reduce using rule 92 (end_for -> .)
    FUNC            reduce using rule 92 (end_for -> .)
    PRINT           reduce using rule 92 (end_for -> .)
    IF              reduce using rule 92 (end_for -> .)
    WHILE           reduce using rule 92 (end_for -> .)
    ID              reduce using rule 92 (end_for -> .)
    TRUE            reduce using rule 92 (end_for -> .)
    FALSE           reduce using rule 92 (end_for -> .)
    (               reduce using rule 92 (end_for -> .)
    *               reduce using rule 92 (end_for -> .)
    /               reduce using rule 92 (end_for -> .)
    I_CONST         reduce using rule 92 (end_for -> .)
    F_CONST         reduce using rule 92 (end_for -> .)
    C_CONST         reduce using rule 92 (end_for -> .)
    }               reduce using rule 92 (end_for -> .)
    RETURN          reduce using rule 92 (end_for -> .)

    end_for                        shift and go to state 317

state 315

    (85) ELSE_STMT -> ELSE { go_to_true_quad BLOCK . } fill_go_to_true_quad

    }               shift and go to state 318


state 316

    (37) FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .

    FUNC            reduce using rule 37 (FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .)
    VOID            reduce using rule 37 (FUNCTION -> FUNC TIPO_SIMPLE add_function_type ID add_id save_function ( PARAM add_parameters ) save_function_as_variable { VARS_PRIME BLOCK RETURN EXPRESSION ; return_quad } empty_local_variables_table .)


state 317

    (93) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .

    FOR             reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FUNC            reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    PRINT           reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    IF              reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    WHILE           reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    ID              reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    TRUE            reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FALSE           reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    (               reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    *               reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    /               reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    I_CONST         reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    F_CONST         reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    C_CONST         reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    }               reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    RETURN          reduce using rule 93 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)


state 318

    (85) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } . fill_go_to_true_quad
    (79) fill_go_to_true_quad -> .

    FOR             reduce using rule 79 (fill_go_to_true_quad -> .)
    FUNC            reduce using rule 79 (fill_go_to_true_quad -> .)
    PRINT           reduce using rule 79 (fill_go_to_true_quad -> .)
    IF              reduce using rule 79 (fill_go_to_true_quad -> .)
    WHILE           reduce using rule 79 (fill_go_to_true_quad -> .)
    ID              reduce using rule 79 (fill_go_to_true_quad -> .)
    TRUE            reduce using rule 79 (fill_go_to_true_quad -> .)
    FALSE           reduce using rule 79 (fill_go_to_true_quad -> .)
    (               reduce using rule 79 (fill_go_to_true_quad -> .)
    *               reduce using rule 79 (fill_go_to_true_quad -> .)
    /               reduce using rule 79 (fill_go_to_true_quad -> .)
    I_CONST         reduce using rule 79 (fill_go_to_true_quad -> .)
    F_CONST         reduce using rule 79 (fill_go_to_true_quad -> .)
    C_CONST         reduce using rule 79 (fill_go_to_true_quad -> .)
    }               reduce using rule 79 (fill_go_to_true_quad -> .)
    RETURN          reduce using rule 79 (fill_go_to_true_quad -> .)

    fill_go_to_true_quad           shift and go to state 319

state 319

    (85) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .

    FOR             reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FUNC            reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    PRINT           reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    IF              reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    WHILE           reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    ID              reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    TRUE            reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FALSE           reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    (               reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    *               reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    /               reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    I_CONST         reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    F_CONST         reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    C_CONST         reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    }               reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    RETURN          reduce using rule 85 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 63 resolved as shift
WARNING: shift/reduce conflict for / in state 63 resolved as shift
WARNING: shift/reduce conflict for * in state 198 resolved as shift
WARNING: shift/reduce conflict for / in state 198 resolved as shift
WARNING: shift/reduce conflict for * in state 199 resolved as shift
WARNING: shift/reduce conflict for / in state 199 resolved as shift
WARNING: reduce/reduce conflict in state 114 resolved using rule (STATEMENT -> FUNC_CALL)
WARNING: rejected rule (VAR_CT -> FUNC_CALL) in state 114
WARNING: reduce/reduce conflict in state 205 resolved using rule (functions_assignation -> <empty>)
WARNING: rejected rule (VAR_CT -> FUNC_CALL) in state 205
