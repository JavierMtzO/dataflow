Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
Rule 2     add_id -> <empty>
Rule 3     save_ids -> <empty>
Rule 4     VARS_PRIME -> VARS VARS_PRIME
Rule 5     VARS_PRIME -> empty
Rule 6     FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 7     FUNCTION_PRIME -> empty
Rule 8     FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 9     FUNC_PRIME -> empty
Rule 10    add_type -> <empty>
Rule 11    add_current_type -> <empty>
Rule 12    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 13    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 14    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
Rule 15    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
Rule 16    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 17    TIPO_PRIME -> empty
Rule 18    get_variable -> <empty>
Rule 19    VARIABLE -> ID get_variable
Rule 20    VARIABLE -> ID [ EXPRESSION ]
Rule 21    TIPO_SIMPLE -> INT add_type
Rule 22    TIPO_SIMPLE -> FLOAT add_type
Rule 23    TIPO_SIMPLE -> CHAR add_type
Rule 24    TIPO_COMP -> DATAFRAME
Rule 25    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
Rule 26    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
Rule 27    FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
Rule 28    PARAM -> TIPO_SIMPLE ID PARAM_PRIME
Rule 29    PARAM -> empty
Rule 30    PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME
Rule 31    PARAM_PRIME -> empty
Rule 32    BLOCK -> STATEMENT BLOCK
Rule 33    BLOCK -> empty
Rule 34    STATEMENT -> ASSIGNATION
Rule 35    STATEMENT -> FUNC_CALL
Rule 36    STATEMENT -> WRITE
Rule 37    STATEMENT -> CONDITION
Rule 38    STATEMENT -> WHILE_STMT
Rule 39    STATEMENT -> FOR_STMT
Rule 40    STATEMENT -> DESCRIBE_STMT
Rule 41    add_operator -> <empty>
Rule 42    add_operand -> <empty>
Rule 43    add_assignation_quad -> <empty>
Rule 44    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 45    FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME )
Rule 46    FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME
Rule 47    FUNC_CALL_PRIME -> empty
Rule 48    WRITE -> PRINT ( EXPRESSION WRITE_PRIME )
Rule 49    WRITE -> PRINT ( TITLE WRITE_PRIME )
Rule 50    WRITE_PRIME -> , EXPRESSION WRITE_PRIME
Rule 51    WRITE_PRIME -> , TITLE WRITE_PRIME
Rule 52    WRITE_PRIME -> empty
Rule 53    CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT
Rule 54    ELSE_STMT -> ELSE { BLOCK }
Rule 55    ELSE_STMT -> empty
Rule 56    WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK }
Rule 57    FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
Rule 58    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 59    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 60    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 61    EXPRESSION_PRIME -> empty
Rule 62    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 63    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 64    AND_EXP_PRIME -> empty
Rule 65    B_EXP -> TRUE
Rule 66    B_EXP -> FALSE
Rule 67    B_EXP -> EXP B_EXP_PRIME
Rule 68    B_EXP_PRIME -> >
Rule 69    B_EXP_PRIME -> <
Rule 70    B_EXP_PRIME -> DIFFERENT
Rule 71    B_EXP_PRIME -> EQUAL
Rule 72    B_EXP_PRIME -> empty
Rule 73    EXP -> TERM EXP_PRIME
Rule 74    EXP_PRIME -> + TERM EXP_PRIME
Rule 75    EXP_PRIME -> - TERM EXP_PRIME
Rule 76    EXP_PRIME -> empty
Rule 77    TERM -> FACTOR TERM_PRIME
Rule 78    TERM_PRIME -> * FACTOR TERM_PRIME
Rule 79    TERM_PRIME -> / FACTOR TERM_PRIME
Rule 80    TERM_PRIME -> empty
Rule 81    FACTOR -> ( EXPRESSION )
Rule 82    FACTOR -> * VAR_CT
Rule 83    FACTOR -> / VAR_CT
Rule 84    FACTOR -> VAR_CT
Rule 85    VAR_CT -> ID
Rule 86    VAR_CT -> I_CONST add_operand
Rule 87    VAR_CT -> F_CONST add_operand
Rule 88    VAR_CT -> C_CONST add_operand
Rule 89    empty -> <empty>

Terminals, with rules where they appear

(                    : 25 26 27 45 48 49 53 56 58 81
)                    : 25 26 27 45 48 49 53 56 58 81
*                    : 78 82
+                    : 74
,                    : 16 30 50 51
-                    : 75
.                    : 58
/                    : 79 83
;                    : 1 12 13 14 15 44
<                    : 69
=                    : 44 57
>                    : 68
AND                  : 63
CHAR                 : 23
C_CONST              : 88
DATAFRAME            : 24
DESCRIBE             : 58
DIFFERENT            : 70
DO                   : 57
ELSE                 : 54
EQUAL                : 71
FALSE                : 66
FLOAT                : 22
FOR                  : 57
FUNC                 : 25 26 27
F_CONST              : 87
ID                   : 1 12 13 14 15 16 19 20 25 26 27 28 30 45 57 58 85
IF                   : 53
INT                  : 21
I_CONST              : 86
MAIN                 : 1
OR                   : 60
PRINT                : 48 49
PROG                 : 1
RETURN               : 25 26
TITLE                : 49 51
TO                   : 57
TRUE                 : 65
VAR                  : 12 13 14 15
VOID                 : 1 27
WHILE                : 56
[                    : 14 15 15 20
]                    : 14 15 15 20
error                : 
{                    : 1 25 26 27 53 54 56 57
}                    : 1 25 26 27 53 54 56 57

Nonterminals, with rules where they appear

AND_EXP              : 59 60
AND_EXP_PRIME        : 62 63
ASSIGNATION          : 34
BLOCK                : 1 25 26 27 32 53 54 56 57
B_EXP                : 62 63
B_EXP_PRIME          : 67
CONDITION            : 37
DESCRIBE_STMT        : 40
ELSE_STMT            : 53
EXP                  : 67
EXPRESSION           : 14 15 15 20 25 44 45 46 48 50 53 56 57 57 81
EXPRESSION_PRIME     : 59 60
EXP_PRIME            : 73 74 75
FACTOR               : 77 78 79
FOR_STMT             : 39
FUNCTION             : 6 8
FUNCTION_PRIME       : 1
FUNC_CALL            : 35
FUNC_CALL_PRIME      : 45 46
FUNC_PRIME           : 6 8
PARAM                : 25 26 27
PARAM_PRIME          : 28 30
PROGRAM              : 0
STATEMENT            : 32
TERM                 : 73 74 75
TERM_PRIME           : 77 78 79
TIPO_COMP            : 12
TIPO_PRIME           : 12 13 16
TIPO_SIMPLE          : 13 14 15 25 26 28 30
VARIABLE             : 44
VARS                 : 4
VARS_PRIME           : 1 1 4 25 26 27
VAR_CT               : 26 82 83 84
WHILE_STMT           : 38
WRITE                : 36
WRITE_PRIME          : 48 49 50 51
add_assignation_quad : 44
add_current_type     : 16
add_id               : 1 12 13 16
add_operand          : 86 87 88
add_operator         : 44
add_type             : 1 21 22 23
empty                : 5 7 9 17 29 31 33 47 52 55 61 64 72 76 80
get_variable         : 19
save_ids             : 1 12 13

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (2) add_id -> .

    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids . VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (89) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)

    VARS_PRIME                     shift and go to state 8
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME . FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (6) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (7) FUNCTION_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (89) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 89 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 12
    FUNCTION                       shift and go to state 13
    empty                          shift and go to state 14

state 9

    (4) VARS_PRIME -> VARS . VARS_PRIME
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (89) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    PRINT           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)

    VARS                           shift and go to state 9
    VARS_PRIME                     shift and go to state 16
    empty                          shift and go to state 10

state 10

    (5) VARS_PRIME -> empty .

    FUNC            reduce using rule 5 (VARS_PRIME -> empty .)
    VOID            reduce using rule 5 (VARS_PRIME -> empty .)
    ID              reduce using rule 5 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 5 (VARS_PRIME -> empty .)
    IF              reduce using rule 5 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 5 (VARS_PRIME -> empty .)
    FOR             reduce using rule 5 (VARS_PRIME -> empty .)
    }               reduce using rule 5 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 5 (VARS_PRIME -> empty .)


state 11

    (12) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (24) TIPO_COMP -> . DATAFRAME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 19
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_COMP                      shift and go to state 17
    TIPO_SIMPLE                    shift and go to state 18

state 12

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME . VOID MAIN { VARS_PRIME BLOCK }

    VOID            shift and go to state 23


state 13

    (6) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (89) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 89 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 25
    empty                          shift and go to state 26

state 14

    (7) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 7 (FUNCTION_PRIME -> empty .)


state 15

    (25) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> FUNC . VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 28
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 27

state 16

    (4) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)


state 17

    (12) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 29


state 18

    (13) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] [ EXPRESSION ] ;

    ID              shift and go to state 30


state 19

    (24) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 24 (TIPO_COMP -> DATAFRAME .)


state 20

    (21) TIPO_SIMPLE -> INT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 31

state 21

    (22) TIPO_SIMPLE -> FLOAT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (23) TIPO_SIMPLE -> CHAR . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID . MAIN { VARS_PRIME BLOCK }

    MAIN            shift and go to state 34


state 24

    (8) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (89) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 89 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 35
    empty                          shift and go to state 26

state 25

    (6) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 6 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 26

    (9) FUNC_PRIME -> empty .

    VOID            reduce using rule 9 (FUNC_PRIME -> empty .)


state 27

    (25) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    ID              shift and go to state 36


state 28

    (27) FUNCTION -> FUNC VOID . ID ( PARAM ) { VARS_PRIME BLOCK }

    ID              shift and go to state 37


state 29

    (12) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 38

state 30

    (13) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] [ EXPRESSION ] ;
    (2) add_id -> .

    [               shift and go to state 40
    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (21) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 21 (TIPO_SIMPLE -> INT add_type .)


state 32

    (22) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 22 (TIPO_SIMPLE -> FLOAT add_type .)


state 33

    (23) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 23 (TIPO_SIMPLE -> CHAR add_type .)


state 34

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN . { VARS_PRIME BLOCK }

    {               shift and go to state 41


state 35

    (8) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 8 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 36

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    (               shift and go to state 42


state 37

    (27) FUNCTION -> FUNC VOID ID . ( PARAM ) { VARS_PRIME BLOCK }

    (               shift and go to state 43


state 38

    (12) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 89 (empty -> .)

    TIPO_PRIME                     shift and go to state 44
    empty                          shift and go to state 46

state 39

    (13) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 89 (empty -> .)

    TIPO_PRIME                     shift and go to state 47
    empty                          shift and go to state 46

state 40

    (14) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] [ EXPRESSION ] ;
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 49
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 41

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (89) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 89 (empty -> .)
    PRINT           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    VARS_PRIME                     shift and go to state 64
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 42

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (89) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 89 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 65
    PARAM                          shift and go to state 66
    empty                          shift and go to state 67

state 43

    (27) FUNCTION -> FUNC VOID ID ( . PARAM ) { VARS_PRIME BLOCK }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (89) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 89 (empty -> .)

    PARAM                          shift and go to state 68
    TIPO_SIMPLE                    shift and go to state 65
    empty                          shift and go to state 67

state 44

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 69


state 45

    (16) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 70


state 46

    (17) TIPO_PRIME -> empty .

    ;               reduce using rule 17 (TIPO_PRIME -> empty .)


state 47

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 71


state 48

    (85) VAR_CT -> ID .

    *               reduce using rule 85 (VAR_CT -> ID .)
    /               reduce using rule 85 (VAR_CT -> ID .)
    +               reduce using rule 85 (VAR_CT -> ID .)
    -               reduce using rule 85 (VAR_CT -> ID .)
    >               reduce using rule 85 (VAR_CT -> ID .)
    <               reduce using rule 85 (VAR_CT -> ID .)
    DIFFERENT       reduce using rule 85 (VAR_CT -> ID .)
    EQUAL           reduce using rule 85 (VAR_CT -> ID .)
    AND             reduce using rule 85 (VAR_CT -> ID .)
    OR              reduce using rule 85 (VAR_CT -> ID .)
    ]               reduce using rule 85 (VAR_CT -> ID .)
    )               reduce using rule 85 (VAR_CT -> ID .)
    TRUE            reduce using rule 85 (VAR_CT -> ID .)
    FALSE           reduce using rule 85 (VAR_CT -> ID .)
    (               reduce using rule 85 (VAR_CT -> ID .)
    ID              reduce using rule 85 (VAR_CT -> ID .)
    I_CONST         reduce using rule 85 (VAR_CT -> ID .)
    F_CONST         reduce using rule 85 (VAR_CT -> ID .)
    C_CONST         reduce using rule 85 (VAR_CT -> ID .)
    ,               reduce using rule 85 (VAR_CT -> ID .)
    ;               reduce using rule 85 (VAR_CT -> ID .)
    TO              reduce using rule 85 (VAR_CT -> ID .)
    DO              reduce using rule 85 (VAR_CT -> ID .)
    }               reduce using rule 85 (VAR_CT -> ID .)


state 49

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] [ EXPRESSION ] ;

    ]               shift and go to state 72


state 50

    (59) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (60) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (61) EXPRESSION_PRIME -> . empty
    (89) empty -> .

    OR              shift and go to state 74
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 73
    empty                          shift and go to state 75

state 51

    (62) AND_EXP -> B_EXP . AND_EXP_PRIME
    (63) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (64) AND_EXP_PRIME -> . empty
    (89) empty -> .

    AND             shift and go to state 77
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 76
    empty                          shift and go to state 78

state 52

    (65) B_EXP -> TRUE .

    AND             reduce using rule 65 (B_EXP -> TRUE .)
    OR              reduce using rule 65 (B_EXP -> TRUE .)
    ]               reduce using rule 65 (B_EXP -> TRUE .)
    )               reduce using rule 65 (B_EXP -> TRUE .)
    TRUE            reduce using rule 65 (B_EXP -> TRUE .)
    FALSE           reduce using rule 65 (B_EXP -> TRUE .)
    (               reduce using rule 65 (B_EXP -> TRUE .)
    *               reduce using rule 65 (B_EXP -> TRUE .)
    /               reduce using rule 65 (B_EXP -> TRUE .)
    ID              reduce using rule 65 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 65 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 65 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 65 (B_EXP -> TRUE .)
    ,               reduce using rule 65 (B_EXP -> TRUE .)
    ;               reduce using rule 65 (B_EXP -> TRUE .)
    TO              reduce using rule 65 (B_EXP -> TRUE .)
    DO              reduce using rule 65 (B_EXP -> TRUE .)
    }               reduce using rule 65 (B_EXP -> TRUE .)


state 53

    (66) B_EXP -> FALSE .

    AND             reduce using rule 66 (B_EXP -> FALSE .)
    OR              reduce using rule 66 (B_EXP -> FALSE .)
    ]               reduce using rule 66 (B_EXP -> FALSE .)
    )               reduce using rule 66 (B_EXP -> FALSE .)
    TRUE            reduce using rule 66 (B_EXP -> FALSE .)
    FALSE           reduce using rule 66 (B_EXP -> FALSE .)
    (               reduce using rule 66 (B_EXP -> FALSE .)
    *               reduce using rule 66 (B_EXP -> FALSE .)
    /               reduce using rule 66 (B_EXP -> FALSE .)
    ID              reduce using rule 66 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 66 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 66 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 66 (B_EXP -> FALSE .)
    ,               reduce using rule 66 (B_EXP -> FALSE .)
    ;               reduce using rule 66 (B_EXP -> FALSE .)
    TO              reduce using rule 66 (B_EXP -> FALSE .)
    DO              reduce using rule 66 (B_EXP -> FALSE .)
    }               reduce using rule 66 (B_EXP -> FALSE .)


state 54

    (67) B_EXP -> EXP . B_EXP_PRIME
    (68) B_EXP_PRIME -> . >
    (69) B_EXP_PRIME -> . <
    (70) B_EXP_PRIME -> . DIFFERENT
    (71) B_EXP_PRIME -> . EQUAL
    (72) B_EXP_PRIME -> . empty
    (89) empty -> .

    >               shift and go to state 80
    <               shift and go to state 81
    DIFFERENT       shift and go to state 82
    EQUAL           shift and go to state 83
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    B_EXP_PRIME                    shift and go to state 79
    empty                          shift and go to state 84

state 55

    (73) EXP -> TERM . EXP_PRIME
    (74) EXP_PRIME -> . + TERM EXP_PRIME
    (75) EXP_PRIME -> . - TERM EXP_PRIME
    (76) EXP_PRIME -> . empty
    (89) empty -> .

    +               shift and go to state 86
    -               shift and go to state 87
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    EXP_PRIME                      shift and go to state 85
    empty                          shift and go to state 88

state 56

    (77) TERM -> FACTOR . TERM_PRIME
    (78) TERM_PRIME -> . * FACTOR TERM_PRIME
    (79) TERM_PRIME -> . / FACTOR TERM_PRIME
    (80) TERM_PRIME -> . empty
    (89) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 89 (empty -> .)
    -               reduce using rule 89 (empty -> .)
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

  ! *               [ reduce using rule 89 (empty -> .) ]
  ! /               [ reduce using rule 89 (empty -> .) ]

    TERM_PRIME                     shift and go to state 89
    empty                          shift and go to state 92

state 57

    (81) FACTOR -> ( . EXPRESSION )
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 93
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 58

    (82) FACTOR -> * . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 94

state 59

    (84) FACTOR -> VAR_CT .

    *               reduce using rule 84 (FACTOR -> VAR_CT .)
    /               reduce using rule 84 (FACTOR -> VAR_CT .)
    +               reduce using rule 84 (FACTOR -> VAR_CT .)
    -               reduce using rule 84 (FACTOR -> VAR_CT .)
    >               reduce using rule 84 (FACTOR -> VAR_CT .)
    <               reduce using rule 84 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 84 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 84 (FACTOR -> VAR_CT .)
    AND             reduce using rule 84 (FACTOR -> VAR_CT .)
    OR              reduce using rule 84 (FACTOR -> VAR_CT .)
    ]               reduce using rule 84 (FACTOR -> VAR_CT .)
    )               reduce using rule 84 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 84 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 84 (FACTOR -> VAR_CT .)
    (               reduce using rule 84 (FACTOR -> VAR_CT .)
    ID              reduce using rule 84 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 84 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 84 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 84 (FACTOR -> VAR_CT .)
    ,               reduce using rule 84 (FACTOR -> VAR_CT .)
    ;               reduce using rule 84 (FACTOR -> VAR_CT .)
    TO              reduce using rule 84 (FACTOR -> VAR_CT .)
    DO              reduce using rule 84 (FACTOR -> VAR_CT .)
    }               reduce using rule 84 (FACTOR -> VAR_CT .)


state 60

    (83) FACTOR -> / . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 95

state 61

    (86) VAR_CT -> I_CONST . add_operand
    (42) add_operand -> .

    *               reduce using rule 42 (add_operand -> .)
    /               reduce using rule 42 (add_operand -> .)
    +               reduce using rule 42 (add_operand -> .)
    -               reduce using rule 42 (add_operand -> .)
    >               reduce using rule 42 (add_operand -> .)
    <               reduce using rule 42 (add_operand -> .)
    DIFFERENT       reduce using rule 42 (add_operand -> .)
    EQUAL           reduce using rule 42 (add_operand -> .)
    AND             reduce using rule 42 (add_operand -> .)
    OR              reduce using rule 42 (add_operand -> .)
    ]               reduce using rule 42 (add_operand -> .)
    )               reduce using rule 42 (add_operand -> .)
    TRUE            reduce using rule 42 (add_operand -> .)
    FALSE           reduce using rule 42 (add_operand -> .)
    (               reduce using rule 42 (add_operand -> .)
    ID              reduce using rule 42 (add_operand -> .)
    I_CONST         reduce using rule 42 (add_operand -> .)
    F_CONST         reduce using rule 42 (add_operand -> .)
    C_CONST         reduce using rule 42 (add_operand -> .)
    ,               reduce using rule 42 (add_operand -> .)
    ;               reduce using rule 42 (add_operand -> .)
    TO              reduce using rule 42 (add_operand -> .)
    DO              reduce using rule 42 (add_operand -> .)
    }               reduce using rule 42 (add_operand -> .)

    add_operand                    shift and go to state 96

state 62

    (87) VAR_CT -> F_CONST . add_operand
    (42) add_operand -> .

    *               reduce using rule 42 (add_operand -> .)
    /               reduce using rule 42 (add_operand -> .)
    +               reduce using rule 42 (add_operand -> .)
    -               reduce using rule 42 (add_operand -> .)
    >               reduce using rule 42 (add_operand -> .)
    <               reduce using rule 42 (add_operand -> .)
    DIFFERENT       reduce using rule 42 (add_operand -> .)
    EQUAL           reduce using rule 42 (add_operand -> .)
    AND             reduce using rule 42 (add_operand -> .)
    OR              reduce using rule 42 (add_operand -> .)
    ]               reduce using rule 42 (add_operand -> .)
    )               reduce using rule 42 (add_operand -> .)
    TRUE            reduce using rule 42 (add_operand -> .)
    FALSE           reduce using rule 42 (add_operand -> .)
    (               reduce using rule 42 (add_operand -> .)
    ID              reduce using rule 42 (add_operand -> .)
    I_CONST         reduce using rule 42 (add_operand -> .)
    F_CONST         reduce using rule 42 (add_operand -> .)
    C_CONST         reduce using rule 42 (add_operand -> .)
    ,               reduce using rule 42 (add_operand -> .)
    ;               reduce using rule 42 (add_operand -> .)
    TO              reduce using rule 42 (add_operand -> .)
    DO              reduce using rule 42 (add_operand -> .)
    }               reduce using rule 42 (add_operand -> .)

    add_operand                    shift and go to state 97

state 63

    (88) VAR_CT -> C_CONST . add_operand
    (42) add_operand -> .

    *               reduce using rule 42 (add_operand -> .)
    /               reduce using rule 42 (add_operand -> .)
    +               reduce using rule 42 (add_operand -> .)
    -               reduce using rule 42 (add_operand -> .)
    >               reduce using rule 42 (add_operand -> .)
    <               reduce using rule 42 (add_operand -> .)
    DIFFERENT       reduce using rule 42 (add_operand -> .)
    EQUAL           reduce using rule 42 (add_operand -> .)
    AND             reduce using rule 42 (add_operand -> .)
    OR              reduce using rule 42 (add_operand -> .)
    ]               reduce using rule 42 (add_operand -> .)
    )               reduce using rule 42 (add_operand -> .)
    TRUE            reduce using rule 42 (add_operand -> .)
    FALSE           reduce using rule 42 (add_operand -> .)
    (               reduce using rule 42 (add_operand -> .)
    ID              reduce using rule 42 (add_operand -> .)
    I_CONST         reduce using rule 42 (add_operand -> .)
    F_CONST         reduce using rule 42 (add_operand -> .)
    C_CONST         reduce using rule 42 (add_operand -> .)
    ,               reduce using rule 42 (add_operand -> .)
    ;               reduce using rule 42 (add_operand -> .)
    TO              reduce using rule 42 (add_operand -> .)
    DO              reduce using rule 42 (add_operand -> .)
    }               reduce using rule 42 (add_operand -> .)

    add_operand                    shift and go to state 98

state 64

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 100
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 65

    (28) PARAM -> TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 115


state 66

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN VAR_CT }

    )               shift and go to state 116


state 67

    (29) PARAM -> empty .

    )               reduce using rule 29 (PARAM -> empty .)


state 68

    (27) FUNCTION -> FUNC VOID ID ( PARAM . ) { VARS_PRIME BLOCK }

    )               shift and go to state 117


state 69

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 118

state 70

    (16) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 119

state 71

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 120

state 72

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . [ EXPRESSION ] ;

    ;               shift and go to state 122
    [               shift and go to state 121


state 73

    (59) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 59 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 74

    (60) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    AND_EXP                        shift and go to state 123
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 75

    (61) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    DO              reduce using rule 61 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 61 (EXPRESSION_PRIME -> empty .)


state 76

    (62) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 62 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 77

    (63) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 124
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 78

    (64) AND_EXP_PRIME -> empty .

    OR              reduce using rule 64 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 64 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 64 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 64 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 64 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 64 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 64 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 64 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 64 (AND_EXP_PRIME -> empty .)
    DO              reduce using rule 64 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 64 (AND_EXP_PRIME -> empty .)


state 79

    (67) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    DO              reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 67 (B_EXP -> EXP B_EXP_PRIME .)


state 80

    (68) B_EXP_PRIME -> > .

    AND             reduce using rule 68 (B_EXP_PRIME -> > .)
    OR              reduce using rule 68 (B_EXP_PRIME -> > .)
    ]               reduce using rule 68 (B_EXP_PRIME -> > .)
    )               reduce using rule 68 (B_EXP_PRIME -> > .)
    TRUE            reduce using rule 68 (B_EXP_PRIME -> > .)
    FALSE           reduce using rule 68 (B_EXP_PRIME -> > .)
    (               reduce using rule 68 (B_EXP_PRIME -> > .)
    *               reduce using rule 68 (B_EXP_PRIME -> > .)
    /               reduce using rule 68 (B_EXP_PRIME -> > .)
    ID              reduce using rule 68 (B_EXP_PRIME -> > .)
    I_CONST         reduce using rule 68 (B_EXP_PRIME -> > .)
    F_CONST         reduce using rule 68 (B_EXP_PRIME -> > .)
    C_CONST         reduce using rule 68 (B_EXP_PRIME -> > .)
    ,               reduce using rule 68 (B_EXP_PRIME -> > .)
    ;               reduce using rule 68 (B_EXP_PRIME -> > .)
    TO              reduce using rule 68 (B_EXP_PRIME -> > .)
    DO              reduce using rule 68 (B_EXP_PRIME -> > .)
    }               reduce using rule 68 (B_EXP_PRIME -> > .)


state 81

    (69) B_EXP_PRIME -> < .

    AND             reduce using rule 69 (B_EXP_PRIME -> < .)
    OR              reduce using rule 69 (B_EXP_PRIME -> < .)
    ]               reduce using rule 69 (B_EXP_PRIME -> < .)
    )               reduce using rule 69 (B_EXP_PRIME -> < .)
    TRUE            reduce using rule 69 (B_EXP_PRIME -> < .)
    FALSE           reduce using rule 69 (B_EXP_PRIME -> < .)
    (               reduce using rule 69 (B_EXP_PRIME -> < .)
    *               reduce using rule 69 (B_EXP_PRIME -> < .)
    /               reduce using rule 69 (B_EXP_PRIME -> < .)
    ID              reduce using rule 69 (B_EXP_PRIME -> < .)
    I_CONST         reduce using rule 69 (B_EXP_PRIME -> < .)
    F_CONST         reduce using rule 69 (B_EXP_PRIME -> < .)
    C_CONST         reduce using rule 69 (B_EXP_PRIME -> < .)
    ,               reduce using rule 69 (B_EXP_PRIME -> < .)
    ;               reduce using rule 69 (B_EXP_PRIME -> < .)
    TO              reduce using rule 69 (B_EXP_PRIME -> < .)
    DO              reduce using rule 69 (B_EXP_PRIME -> < .)
    }               reduce using rule 69 (B_EXP_PRIME -> < .)


state 82

    (70) B_EXP_PRIME -> DIFFERENT .

    AND             reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    OR              reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    ]               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    )               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    TRUE            reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    FALSE           reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    (               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    *               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    /               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    ID              reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    I_CONST         reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    F_CONST         reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    C_CONST         reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    ,               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    ;               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    TO              reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    DO              reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)
    }               reduce using rule 70 (B_EXP_PRIME -> DIFFERENT .)


state 83

    (71) B_EXP_PRIME -> EQUAL .

    AND             reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    OR              reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    ]               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    )               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    TRUE            reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    FALSE           reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    (               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    *               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    /               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    ID              reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    I_CONST         reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    F_CONST         reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    C_CONST         reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    ,               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    ;               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    TO              reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    DO              reduce using rule 71 (B_EXP_PRIME -> EQUAL .)
    }               reduce using rule 71 (B_EXP_PRIME -> EQUAL .)


state 84

    (72) B_EXP_PRIME -> empty .

    AND             reduce using rule 72 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 72 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 72 (B_EXP_PRIME -> empty .)
    )               reduce using rule 72 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 72 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 72 (B_EXP_PRIME -> empty .)
    (               reduce using rule 72 (B_EXP_PRIME -> empty .)
    *               reduce using rule 72 (B_EXP_PRIME -> empty .)
    /               reduce using rule 72 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 72 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 72 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 72 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 72 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 72 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 72 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 72 (B_EXP_PRIME -> empty .)
    DO              reduce using rule 72 (B_EXP_PRIME -> empty .)
    }               reduce using rule 72 (B_EXP_PRIME -> empty .)


state 85

    (73) EXP -> TERM EXP_PRIME .

    >               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    DO              reduce using rule 73 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 73 (EXP -> TERM EXP_PRIME .)


state 86

    (74) EXP_PRIME -> + . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 125
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 87

    (75) EXP_PRIME -> - . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 126
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 88

    (76) EXP_PRIME -> empty .

    >               reduce using rule 76 (EXP_PRIME -> empty .)
    <               reduce using rule 76 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 76 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 76 (EXP_PRIME -> empty .)
    AND             reduce using rule 76 (EXP_PRIME -> empty .)
    OR              reduce using rule 76 (EXP_PRIME -> empty .)
    ]               reduce using rule 76 (EXP_PRIME -> empty .)
    )               reduce using rule 76 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 76 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 76 (EXP_PRIME -> empty .)
    (               reduce using rule 76 (EXP_PRIME -> empty .)
    *               reduce using rule 76 (EXP_PRIME -> empty .)
    /               reduce using rule 76 (EXP_PRIME -> empty .)
    ID              reduce using rule 76 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 76 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 76 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 76 (EXP_PRIME -> empty .)
    ,               reduce using rule 76 (EXP_PRIME -> empty .)
    ;               reduce using rule 76 (EXP_PRIME -> empty .)
    TO              reduce using rule 76 (EXP_PRIME -> empty .)
    DO              reduce using rule 76 (EXP_PRIME -> empty .)
    }               reduce using rule 76 (EXP_PRIME -> empty .)


state 89

    (77) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    DO              reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 77 (TERM -> FACTOR TERM_PRIME .)


state 90

    (78) TERM_PRIME -> * . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 127
    VAR_CT                         shift and go to state 59

state 91

    (79) TERM_PRIME -> / . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 128
    VAR_CT                         shift and go to state 59

state 92

    (80) TERM_PRIME -> empty .

    +               reduce using rule 80 (TERM_PRIME -> empty .)
    -               reduce using rule 80 (TERM_PRIME -> empty .)
    >               reduce using rule 80 (TERM_PRIME -> empty .)
    <               reduce using rule 80 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 80 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 80 (TERM_PRIME -> empty .)
    AND             reduce using rule 80 (TERM_PRIME -> empty .)
    OR              reduce using rule 80 (TERM_PRIME -> empty .)
    ]               reduce using rule 80 (TERM_PRIME -> empty .)
    )               reduce using rule 80 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 80 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 80 (TERM_PRIME -> empty .)
    (               reduce using rule 80 (TERM_PRIME -> empty .)
    *               reduce using rule 80 (TERM_PRIME -> empty .)
    /               reduce using rule 80 (TERM_PRIME -> empty .)
    ID              reduce using rule 80 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 80 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 80 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 80 (TERM_PRIME -> empty .)
    ,               reduce using rule 80 (TERM_PRIME -> empty .)
    ;               reduce using rule 80 (TERM_PRIME -> empty .)
    TO              reduce using rule 80 (TERM_PRIME -> empty .)
    DO              reduce using rule 80 (TERM_PRIME -> empty .)
    }               reduce using rule 80 (TERM_PRIME -> empty .)


state 93

    (81) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 129


state 94

    (82) FACTOR -> * VAR_CT .

    *               reduce using rule 82 (FACTOR -> * VAR_CT .)
    /               reduce using rule 82 (FACTOR -> * VAR_CT .)
    +               reduce using rule 82 (FACTOR -> * VAR_CT .)
    -               reduce using rule 82 (FACTOR -> * VAR_CT .)
    >               reduce using rule 82 (FACTOR -> * VAR_CT .)
    <               reduce using rule 82 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 82 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 82 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 82 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 82 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 82 (FACTOR -> * VAR_CT .)
    )               reduce using rule 82 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 82 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 82 (FACTOR -> * VAR_CT .)
    (               reduce using rule 82 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 82 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 82 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 82 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 82 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 82 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 82 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 82 (FACTOR -> * VAR_CT .)
    DO              reduce using rule 82 (FACTOR -> * VAR_CT .)
    }               reduce using rule 82 (FACTOR -> * VAR_CT .)


state 95

    (83) FACTOR -> / VAR_CT .

    *               reduce using rule 83 (FACTOR -> / VAR_CT .)
    /               reduce using rule 83 (FACTOR -> / VAR_CT .)
    +               reduce using rule 83 (FACTOR -> / VAR_CT .)
    -               reduce using rule 83 (FACTOR -> / VAR_CT .)
    >               reduce using rule 83 (FACTOR -> / VAR_CT .)
    <               reduce using rule 83 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 83 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 83 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 83 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 83 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 83 (FACTOR -> / VAR_CT .)
    )               reduce using rule 83 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 83 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 83 (FACTOR -> / VAR_CT .)
    (               reduce using rule 83 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 83 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 83 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 83 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 83 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 83 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 83 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 83 (FACTOR -> / VAR_CT .)
    DO              reduce using rule 83 (FACTOR -> / VAR_CT .)
    }               reduce using rule 83 (FACTOR -> / VAR_CT .)


state 96

    (86) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    DO              reduce using rule 86 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 86 (VAR_CT -> I_CONST add_operand .)


state 97

    (87) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    DO              reduce using rule 87 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 87 (VAR_CT -> F_CONST add_operand .)


state 98

    (88) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    DO              reduce using rule 88 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 88 (VAR_CT -> C_CONST add_operand .)


state 99

    (45) FUNC_CALL -> ID . ( EXPRESSION FUNC_CALL_PRIME )
    (58) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (19) VARIABLE -> ID . get_variable
    (20) VARIABLE -> ID . [ EXPRESSION ]
    (18) get_variable -> .

    (               shift and go to state 130
    .               shift and go to state 131
    [               shift and go to state 133
    =               reduce using rule 18 (get_variable -> .)

    get_variable                   shift and go to state 132

state 100

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK . }

    }               shift and go to state 134


state 101

    (32) BLOCK -> STATEMENT . BLOCK
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    STATEMENT                      shift and go to state 101
    BLOCK                          shift and go to state 135
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 102

    (33) BLOCK -> empty .

    }               reduce using rule 33 (BLOCK -> empty .)
    RETURN          reduce using rule 33 (BLOCK -> empty .)


state 103

    (34) STATEMENT -> ASSIGNATION .

    ID              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    FOR             reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 34 (STATEMENT -> ASSIGNATION .)


state 104

    (35) STATEMENT -> FUNC_CALL .

    ID              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    FOR             reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 35 (STATEMENT -> FUNC_CALL .)


state 105

    (36) STATEMENT -> WRITE .

    ID              reduce using rule 36 (STATEMENT -> WRITE .)
    PRINT           reduce using rule 36 (STATEMENT -> WRITE .)
    IF              reduce using rule 36 (STATEMENT -> WRITE .)
    WHILE           reduce using rule 36 (STATEMENT -> WRITE .)
    FOR             reduce using rule 36 (STATEMENT -> WRITE .)
    }               reduce using rule 36 (STATEMENT -> WRITE .)
    RETURN          reduce using rule 36 (STATEMENT -> WRITE .)


state 106

    (37) STATEMENT -> CONDITION .

    ID              reduce using rule 37 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 37 (STATEMENT -> CONDITION .)
    IF              reduce using rule 37 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 37 (STATEMENT -> CONDITION .)
    FOR             reduce using rule 37 (STATEMENT -> CONDITION .)
    }               reduce using rule 37 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 37 (STATEMENT -> CONDITION .)


state 107

    (38) STATEMENT -> WHILE_STMT .

    ID              reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    FOR             reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 38 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 38 (STATEMENT -> WHILE_STMT .)


state 108

    (39) STATEMENT -> FOR_STMT .

    ID              reduce using rule 39 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 39 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 39 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 39 (STATEMENT -> FOR_STMT .)
    FOR             reduce using rule 39 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 39 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 39 (STATEMENT -> FOR_STMT .)


state 109

    (40) STATEMENT -> DESCRIBE_STMT .

    ID              reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    FOR             reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 40 (STATEMENT -> DESCRIBE_STMT .)


state 110

    (44) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad

    =               shift and go to state 136


state 111

    (48) WRITE -> PRINT . ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> PRINT . ( TITLE WRITE_PRIME )

    (               shift and go to state 137


state 112

    (53) CONDITION -> IF . ( EXPRESSION ) { BLOCK } ELSE_STMT

    (               shift and go to state 138


state 113

    (56) WHILE_STMT -> WHILE . ( EXPRESSION ) { BLOCK }

    (               shift and go to state 139


state 114

    (57) FOR_STMT -> FOR . ID = EXPRESSION TO EXPRESSION DO { BLOCK }

    ID              shift and go to state 140


state 115

    (28) PARAM -> TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 142
    )               reduce using rule 89 (empty -> .)

    PARAM_PRIME                    shift and go to state 141
    empty                          shift and go to state 143

state 116

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN VAR_CT }

    {               shift and go to state 144


state 117

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) . { VARS_PRIME BLOCK }

    {               shift and go to state 145


state 118

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 119

    (16) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (11) add_current_type -> .

    ,               reduce using rule 11 (add_current_type -> .)
    ;               reduce using rule 11 (add_current_type -> .)

    add_current_type               shift and go to state 146

state 120

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 121

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ . EXPRESSION ] ;
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 147
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 122

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .

    VAR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FUNC            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    VOID            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    ID              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    PRINT           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    IF              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    WHILE           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FOR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    }               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    RETURN          reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)


state 123

    (60) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (60) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (61) EXPRESSION_PRIME -> . empty
    (89) empty -> .

    OR              shift and go to state 74
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 148
    empty                          shift and go to state 75

state 124

    (63) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (63) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (64) AND_EXP_PRIME -> . empty
    (89) empty -> .

    AND             shift and go to state 77
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 149
    empty                          shift and go to state 78

state 125

    (74) EXP_PRIME -> + TERM . EXP_PRIME
    (74) EXP_PRIME -> . + TERM EXP_PRIME
    (75) EXP_PRIME -> . - TERM EXP_PRIME
    (76) EXP_PRIME -> . empty
    (89) empty -> .

    +               shift and go to state 86
    -               shift and go to state 87
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    EXP_PRIME                      shift and go to state 150
    empty                          shift and go to state 88

state 126

    (75) EXP_PRIME -> - TERM . EXP_PRIME
    (74) EXP_PRIME -> . + TERM EXP_PRIME
    (75) EXP_PRIME -> . - TERM EXP_PRIME
    (76) EXP_PRIME -> . empty
    (89) empty -> .

    +               shift and go to state 86
    -               shift and go to state 87
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    *               reduce using rule 89 (empty -> .)
    /               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    EXP_PRIME                      shift and go to state 151
    empty                          shift and go to state 88

state 127

    (78) TERM_PRIME -> * FACTOR . TERM_PRIME
    (78) TERM_PRIME -> . * FACTOR TERM_PRIME
    (79) TERM_PRIME -> . / FACTOR TERM_PRIME
    (80) TERM_PRIME -> . empty
    (89) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 89 (empty -> .)
    -               reduce using rule 89 (empty -> .)
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

  ! *               [ reduce using rule 89 (empty -> .) ]
  ! /               [ reduce using rule 89 (empty -> .) ]

    TERM_PRIME                     shift and go to state 152
    empty                          shift and go to state 92

state 128

    (79) TERM_PRIME -> / FACTOR . TERM_PRIME
    (78) TERM_PRIME -> . * FACTOR TERM_PRIME
    (79) TERM_PRIME -> . / FACTOR TERM_PRIME
    (80) TERM_PRIME -> . empty
    (89) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 89 (empty -> .)
    -               reduce using rule 89 (empty -> .)
    >               reduce using rule 89 (empty -> .)
    <               reduce using rule 89 (empty -> .)
    DIFFERENT       reduce using rule 89 (empty -> .)
    EQUAL           reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    ]               reduce using rule 89 (empty -> .)
    )               reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    I_CONST         reduce using rule 89 (empty -> .)
    F_CONST         reduce using rule 89 (empty -> .)
    C_CONST         reduce using rule 89 (empty -> .)
    ,               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    TO              reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

  ! *               [ reduce using rule 89 (empty -> .) ]
  ! /               [ reduce using rule 89 (empty -> .) ]

    TERM_PRIME                     shift and go to state 153
    empty                          shift and go to state 92

state 129

    (81) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    DO              reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 81 (FACTOR -> ( EXPRESSION ) .)


state 130

    (45) FUNC_CALL -> ID ( . EXPRESSION FUNC_CALL_PRIME )
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 154
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 131

    (58) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 155


state 132

    (19) VARIABLE -> ID get_variable .

    =               reduce using rule 19 (VARIABLE -> ID get_variable .)


state 133

    (20) VARIABLE -> ID [ . EXPRESSION ]
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 156
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 134

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .)


state 135

    (32) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)


state 136

    (44) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (41) add_operator -> .

    TRUE            reduce using rule 41 (add_operator -> .)
    FALSE           reduce using rule 41 (add_operator -> .)
    (               reduce using rule 41 (add_operator -> .)
    *               reduce using rule 41 (add_operator -> .)
    /               reduce using rule 41 (add_operator -> .)
    ID              reduce using rule 41 (add_operator -> .)
    I_CONST         reduce using rule 41 (add_operator -> .)
    F_CONST         reduce using rule 41 (add_operator -> .)
    C_CONST         reduce using rule 41 (add_operator -> .)

    add_operator                   shift and go to state 157

state 137

    (48) WRITE -> PRINT ( . EXPRESSION WRITE_PRIME )
    (49) WRITE -> PRINT ( . TITLE WRITE_PRIME )
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 159
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 158
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 138

    (53) CONDITION -> IF ( . EXPRESSION ) { BLOCK } ELSE_STMT
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 160
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 139

    (56) WHILE_STMT -> WHILE ( . EXPRESSION ) { BLOCK }
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 161
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 140

    (57) FOR_STMT -> FOR ID . = EXPRESSION TO EXPRESSION DO { BLOCK }

    =               shift and go to state 162


state 141

    (28) PARAM -> TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 28 (PARAM -> TIPO_SIMPLE ID PARAM_PRIME .)


state 142

    (30) PARAM_PRIME -> , . TIPO_SIMPLE ID PARAM_PRIME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 163

state 143

    (31) PARAM_PRIME -> empty .

    )               reduce using rule 31 (PARAM_PRIME -> empty .)


state 144

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN VAR_CT }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (89) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 89 (empty -> .)
    PRINT           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)

    VARS_PRIME                     shift and go to state 164
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 145

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (89) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 89 (empty -> .)
    PRINT           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)

    VARS_PRIME                     shift and go to state 165
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 146

    (16) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 89 (empty -> .)

    TIPO_PRIME                     shift and go to state 166
    empty                          shift and go to state 46

state 147

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION . ] ;

    ]               shift and go to state 167


state 148

    (60) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 60 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 149

    (63) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 63 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 150

    (74) EXP_PRIME -> + TERM EXP_PRIME .

    >               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    <               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    EQUAL           reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    AND             reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    OR              reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    ]               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    )               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    TRUE            reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    FALSE           reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    (               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    *               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    /               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    ID              reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    I_CONST         reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    F_CONST         reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    C_CONST         reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    ,               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    ;               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    TO              reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    DO              reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)
    }               reduce using rule 74 (EXP_PRIME -> + TERM EXP_PRIME .)


state 151

    (75) EXP_PRIME -> - TERM EXP_PRIME .

    >               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    <               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    EQUAL           reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    AND             reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    OR              reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    ]               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    )               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    TRUE            reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    FALSE           reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    (               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    *               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    /               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    ID              reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    I_CONST         reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    F_CONST         reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    C_CONST         reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    ,               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    ;               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    TO              reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    DO              reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)
    }               reduce using rule 75 (EXP_PRIME -> - TERM EXP_PRIME .)


state 152

    (78) TERM_PRIME -> * FACTOR TERM_PRIME .

    +               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    -               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    >               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    <               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    AND             reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    OR              reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ]               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    )               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    TRUE            reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    FALSE           reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    (               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    *               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    /               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ID              reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ,               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ;               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    TO              reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    DO              reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    }               reduce using rule 78 (TERM_PRIME -> * FACTOR TERM_PRIME .)


state 153

    (79) TERM_PRIME -> / FACTOR TERM_PRIME .

    +               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    -               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    >               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    <               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    AND             reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    OR              reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ]               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    )               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    TRUE            reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    FALSE           reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    (               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    *               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    /               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ID              reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ,               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ;               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    TO              reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    DO              reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    }               reduce using rule 79 (TERM_PRIME -> / FACTOR TERM_PRIME .)


state 154

    (45) FUNC_CALL -> ID ( EXPRESSION . FUNC_CALL_PRIME )
    (46) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (47) FUNC_CALL_PRIME -> . empty
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (89) empty -> .
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 89 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 168
    FUNC_CALL_PRIME                shift and go to state 169
    empty                          shift and go to state 170
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 155

    (58) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 171


state 156

    (20) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 172


state 157

    (44) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 173
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 158

    (48) WRITE -> PRINT ( EXPRESSION . WRITE_PRIME )
    (50) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (51) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (52) WRITE_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 175
    )               reduce using rule 89 (empty -> .)

    WRITE_PRIME                    shift and go to state 174
    empty                          shift and go to state 176

state 159

    (49) WRITE -> PRINT ( TITLE . WRITE_PRIME )
    (50) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (51) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (52) WRITE_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 175
    )               reduce using rule 89 (empty -> .)

    WRITE_PRIME                    shift and go to state 177
    empty                          shift and go to state 176

state 160

    (53) CONDITION -> IF ( EXPRESSION . ) { BLOCK } ELSE_STMT

    )               shift and go to state 178


state 161

    (56) WHILE_STMT -> WHILE ( EXPRESSION . ) { BLOCK }

    )               shift and go to state 179


state 162

    (57) FOR_STMT -> FOR ID = . EXPRESSION TO EXPRESSION DO { BLOCK }
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 180
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 163

    (30) PARAM_PRIME -> , TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 181


state 164

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN VAR_CT }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    RETURN          reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 182
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 165

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 183
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 166

    (16) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 16 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 167

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] . ;

    ;               shift and go to state 184


state 168

    (46) FUNC_CALL_PRIME -> EXPRESSION . FUNC_CALL_PRIME
    (46) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (47) FUNC_CALL_PRIME -> . empty
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (89) empty -> .
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 89 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 168
    FUNC_CALL_PRIME                shift and go to state 185
    empty                          shift and go to state 170
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 169

    (45) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME . )

    )               shift and go to state 186


state 170

    (47) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 47 (FUNC_CALL_PRIME -> empty .)


state 171

    (58) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 187


state 172

    (20) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 20 (VARIABLE -> ID [ EXPRESSION ] .)


state 173

    (44) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 188


state 174

    (48) WRITE -> PRINT ( EXPRESSION WRITE_PRIME . )

    )               shift and go to state 189


state 175

    (50) WRITE_PRIME -> , . EXPRESSION WRITE_PRIME
    (51) WRITE_PRIME -> , . TITLE WRITE_PRIME
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 191
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 190
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 176

    (52) WRITE_PRIME -> empty .

    )               reduce using rule 52 (WRITE_PRIME -> empty .)


state 177

    (49) WRITE -> PRINT ( TITLE WRITE_PRIME . )

    )               shift and go to state 192


state 178

    (53) CONDITION -> IF ( EXPRESSION ) . { BLOCK } ELSE_STMT

    {               shift and go to state 193


state 179

    (56) WHILE_STMT -> WHILE ( EXPRESSION ) . { BLOCK }

    {               shift and go to state 194


state 180

    (57) FOR_STMT -> FOR ID = EXPRESSION . TO EXPRESSION DO { BLOCK }

    TO              shift and go to state 195


state 181

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 142
    )               reduce using rule 89 (empty -> .)

    PARAM_PRIME                    shift and go to state 196
    empty                          shift and go to state 143

state 182

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN VAR_CT }

    RETURN          shift and go to state 197


state 183

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK . }

    }               shift and go to state 198


state 184

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .

    VAR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FUNC            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    VOID            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    ID              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    PRINT           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    IF              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    WHILE           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FOR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    }               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    RETURN          reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)


state 185

    (46) FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .

    )               reduce using rule 46 (FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .)


state 186

    (45) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .

    ID              reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    PRINT           reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    IF              reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    WHILE           reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FOR             reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    }               reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    RETURN          reduce using rule 45 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)


state 187

    (58) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    ID              reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FOR             reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 58 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 188

    (44) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (43) add_assignation_quad -> .

    ID              reduce using rule 43 (add_assignation_quad -> .)
    PRINT           reduce using rule 43 (add_assignation_quad -> .)
    IF              reduce using rule 43 (add_assignation_quad -> .)
    WHILE           reduce using rule 43 (add_assignation_quad -> .)
    FOR             reduce using rule 43 (add_assignation_quad -> .)
    }               reduce using rule 43 (add_assignation_quad -> .)
    RETURN          reduce using rule 43 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 199

state 189

    (48) WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .

    ID              reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    PRINT           reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    IF              reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    WHILE           reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    FOR             reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    }               reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    RETURN          reduce using rule 48 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)


state 190

    (50) WRITE_PRIME -> , EXPRESSION . WRITE_PRIME
    (50) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (51) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (52) WRITE_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 175
    )               reduce using rule 89 (empty -> .)

    WRITE_PRIME                    shift and go to state 200
    empty                          shift and go to state 176

state 191

    (51) WRITE_PRIME -> , TITLE . WRITE_PRIME
    (50) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (51) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (52) WRITE_PRIME -> . empty
    (89) empty -> .

    ,               shift and go to state 175
    )               reduce using rule 89 (empty -> .)

    WRITE_PRIME                    shift and go to state 201
    empty                          shift and go to state 176

state 192

    (49) WRITE -> PRINT ( TITLE WRITE_PRIME ) .

    ID              reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    PRINT           reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    IF              reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    WHILE           reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    FOR             reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    }               reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    RETURN          reduce using rule 49 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)


state 193

    (53) CONDITION -> IF ( EXPRESSION ) { . BLOCK } ELSE_STMT
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 202
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 194

    (56) WHILE_STMT -> WHILE ( EXPRESSION ) { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 203
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 195

    (57) FOR_STMT -> FOR ID = EXPRESSION TO . EXPRESSION DO { BLOCK }
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 204
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 196

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 30 (PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .)


state 197

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . VAR_CT }
    (59) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (85) VAR_CT -> . ID
    (86) VAR_CT -> . I_CONST add_operand
    (87) VAR_CT -> . F_CONST add_operand
    (88) VAR_CT -> . C_CONST add_operand
    (62) AND_EXP -> . B_EXP AND_EXP_PRIME
    (65) B_EXP -> . TRUE
    (66) B_EXP -> . FALSE
    (67) B_EXP -> . EXP B_EXP_PRIME
    (73) EXP -> . TERM EXP_PRIME
    (77) TERM -> . FACTOR TERM_PRIME
    (81) FACTOR -> . ( EXPRESSION )
    (82) FACTOR -> . * VAR_CT
    (83) FACTOR -> . / VAR_CT
    (84) FACTOR -> . VAR_CT

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60

    EXPRESSION                     shift and go to state 205
    VAR_CT                         shift and go to state 206
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56

state 198

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .

    FUNC            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)
    VOID            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)


state 199

    (44) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    ID              reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 44 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 200

    (50) WRITE_PRIME -> , EXPRESSION WRITE_PRIME .

    )               reduce using rule 50 (WRITE_PRIME -> , EXPRESSION WRITE_PRIME .)


state 201

    (51) WRITE_PRIME -> , TITLE WRITE_PRIME .

    )               reduce using rule 51 (WRITE_PRIME -> , TITLE WRITE_PRIME .)


state 202

    (53) CONDITION -> IF ( EXPRESSION ) { BLOCK . } ELSE_STMT

    }               shift and go to state 207


state 203

    (56) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK . }

    }               shift and go to state 208


state 204

    (57) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION . DO { BLOCK }

    DO              shift and go to state 209


state 205

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION . }

    }               shift and go to state 210


state 206

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT . }
    (84) FACTOR -> VAR_CT .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 211
    *               reduce using rule 84 (FACTOR -> VAR_CT .)
    /               reduce using rule 84 (FACTOR -> VAR_CT .)
    +               reduce using rule 84 (FACTOR -> VAR_CT .)
    -               reduce using rule 84 (FACTOR -> VAR_CT .)
    >               reduce using rule 84 (FACTOR -> VAR_CT .)
    <               reduce using rule 84 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 84 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 84 (FACTOR -> VAR_CT .)
    AND             reduce using rule 84 (FACTOR -> VAR_CT .)
    OR              reduce using rule 84 (FACTOR -> VAR_CT .)

  ! }               [ reduce using rule 84 (FACTOR -> VAR_CT .) ]


state 207

    (53) CONDITION -> IF ( EXPRESSION ) { BLOCK } . ELSE_STMT
    (54) ELSE_STMT -> . ELSE { BLOCK }
    (55) ELSE_STMT -> . empty
    (89) empty -> .

    ELSE            shift and go to state 213
    ID              reduce using rule 89 (empty -> .)
    PRINT           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)

    ELSE_STMT                      shift and go to state 212
    empty                          shift and go to state 214

state 208

    (56) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .

    ID              reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    PRINT           reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    IF              reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    WHILE           reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    FOR             reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    }               reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    RETURN          reduce using rule 56 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)


state 209

    (57) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO . { BLOCK }

    {               shift and go to state 215


state 210

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .

    FUNC            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)
    VOID            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)


state 211

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .

    FUNC            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)
    VOID            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)


state 212

    (53) CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .

    ID              reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    PRINT           reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    IF              reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    WHILE           reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    FOR             reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    }               reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    RETURN          reduce using rule 53 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)


state 213

    (54) ELSE_STMT -> ELSE . { BLOCK }

    {               shift and go to state 216


state 214

    (55) ELSE_STMT -> empty .

    ID              reduce using rule 55 (ELSE_STMT -> empty .)
    PRINT           reduce using rule 55 (ELSE_STMT -> empty .)
    IF              reduce using rule 55 (ELSE_STMT -> empty .)
    WHILE           reduce using rule 55 (ELSE_STMT -> empty .)
    FOR             reduce using rule 55 (ELSE_STMT -> empty .)
    }               reduce using rule 55 (ELSE_STMT -> empty .)
    RETURN          reduce using rule 55 (ELSE_STMT -> empty .)


state 215

    (57) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 217
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 216

    (54) ELSE_STMT -> ELSE { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . WRITE
    (37) STATEMENT -> . CONDITION
    (38) STATEMENT -> . WHILE_STMT
    (39) STATEMENT -> . FOR_STMT
    (40) STATEMENT -> . DESCRIBE_STMT
    (89) empty -> .
    (44) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (45) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (48) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (49) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (53) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (56) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (57) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (58) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 89 (empty -> .)
    ID              shift and go to state 99
    PRINT           shift and go to state 111
    IF              shift and go to state 112
    WHILE           shift and go to state 113
    FOR             shift and go to state 114

    BLOCK                          shift and go to state 218
    STATEMENT                      shift and go to state 101
    empty                          shift and go to state 102
    ASSIGNATION                    shift and go to state 103
    FUNC_CALL                      shift and go to state 104
    WRITE                          shift and go to state 105
    CONDITION                      shift and go to state 106
    WHILE_STMT                     shift and go to state 107
    FOR_STMT                       shift and go to state 108
    DESCRIBE_STMT                  shift and go to state 109
    VARIABLE                       shift and go to state 110

state 217

    (57) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK . }

    }               shift and go to state 219


state 218

    (54) ELSE_STMT -> ELSE { BLOCK . }

    }               shift and go to state 220


state 219

    (57) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .

    ID              reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    PRINT           reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    IF              reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    WHILE           reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    FOR             reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    }               reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    RETURN          reduce using rule 57 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)


state 220

    (54) ELSE_STMT -> ELSE { BLOCK } .

    ID              reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    PRINT           reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    IF              reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    WHILE           reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    FOR             reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    }               reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)
    RETURN          reduce using rule 54 (ELSE_STMT -> ELSE { BLOCK } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for / in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 127 resolved as shift
WARNING: shift/reduce conflict for / in state 127 resolved as shift
WARNING: shift/reduce conflict for * in state 128 resolved as shift
WARNING: shift/reduce conflict for / in state 128 resolved as shift
WARNING: shift/reduce conflict for } in state 206 resolved as shift
