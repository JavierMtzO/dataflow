Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
Rule 2     add_id -> <empty>
Rule 3     save_ids -> <empty>
Rule 4     VARS_PRIME -> VARS VARS_PRIME
Rule 5     VARS_PRIME -> empty
Rule 6     FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 7     FUNCTION_PRIME -> empty
Rule 8     FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 9     FUNC_PRIME -> empty
Rule 10    add_type -> <empty>
Rule 11    add_current_type -> <empty>
Rule 12    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 13    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 14    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
Rule 15    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
Rule 16    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 17    TIPO_PRIME -> empty
Rule 18    get_variable -> <empty>
Rule 19    VARIABLE -> ID get_variable
Rule 20    VARIABLE -> ID [ EXPRESSION ]
Rule 21    TIPO_SIMPLE -> INT add_type
Rule 22    TIPO_SIMPLE -> FLOAT add_type
Rule 23    TIPO_SIMPLE -> CHAR add_type
Rule 24    TIPO_COMP -> DATAFRAME
Rule 25    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
Rule 26    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
Rule 27    FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
Rule 28    PARAM -> TIPO_SIMPLE ID PARAM_PRIME
Rule 29    PARAM -> empty
Rule 30    PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME
Rule 31    PARAM_PRIME -> empty
Rule 32    BLOCK -> STATEMENT BLOCK
Rule 33    BLOCK -> empty
Rule 34    STATEMENT -> ASSIGNATION
Rule 35    STATEMENT -> FUNC_CALL
Rule 36    STATEMENT -> EXPRESSION ;
Rule 37    STATEMENT -> WRITE ;
Rule 38    STATEMENT -> CONDITION
Rule 39    STATEMENT -> WHILE_STMT
Rule 40    STATEMENT -> FOR_STMT
Rule 41    STATEMENT -> DESCRIBE_STMT
Rule 42    add_operator -> <empty>
Rule 43    add_operand -> <empty>
Rule 44    add_assignation_quad -> <empty>
Rule 45    add_assignation_for_quad -> <empty>
Rule 46    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 47    ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
Rule 48    FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME )
Rule 49    FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME
Rule 50    FUNC_CALL_PRIME -> empty
Rule 51    print_quad -> <empty>
Rule 52    add_print_operator -> <empty>
Rule 53    WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
Rule 54    WRITE -> PRINT add_operator ( TITLE WRITE_PRIME )
Rule 55    WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME
Rule 56    WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME
Rule 57    WRITE_PRIME -> empty
Rule 58    go_to_false_quad -> <empty>
Rule 59    fill_go_to_false_quad -> <empty>
Rule 60    go_to_true_quad -> <empty>
Rule 61    fill_go_to_true_quad -> <empty>
Rule 62    CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
Rule 63    ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
Rule 64    ELSE_STMT -> empty
Rule 65    WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK }
Rule 66    check_exact_type_for -> <empty>
Rule 67    add_final_counter_for -> <empty>
Rule 68    generate_for_quad -> <empty>
Rule 69    check_boolean_expression_for -> <empty>
Rule 70    end_for -> <empty>
Rule 71    FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
Rule 72    FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
Rule 73    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 74    aritmetics_operation -> <empty>
Rule 75    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 76    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 77    EXPRESSION_PRIME -> empty
Rule 78    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 79    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 80    AND_EXP_PRIME -> empty
Rule 81    B_EXP -> TRUE
Rule 82    B_EXP -> FALSE
Rule 83    B_EXP -> EXP B_EXP_PRIME
Rule 84    B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation
Rule 85    B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation
Rule 86    B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation
Rule 87    B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation
Rule 88    B_EXP_PRIME -> empty
Rule 89    EXP -> TERM EXP_PRIME
Rule 90    EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation
Rule 91    EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation
Rule 92    EXP_PRIME -> empty
Rule 93    TERM -> FACTOR TERM_PRIME
Rule 94    TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 95    TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 96    TERM_PRIME -> empty
Rule 97    FACTOR -> ( EXPRESSION )
Rule 98    FACTOR -> * VAR_CT
Rule 99    FACTOR -> / VAR_CT
Rule 100   FACTOR -> VAR_CT
Rule 101   VAR_CT -> ID add_operand
Rule 102   VAR_CT -> I_CONST add_operand
Rule 103   VAR_CT -> F_CONST add_operand
Rule 104   VAR_CT -> C_CONST add_operand
Rule 105   empty -> <empty>

Terminals, with rules where they appear

(                    : 25 26 27 48 53 54 62 65 71 72 73 97
)                    : 25 26 27 48 53 54 62 65 71 72 73 97
*                    : 94 98
+                    : 90
,                    : 16 30 55 56
-                    : 91
.                    : 73
/                    : 95 99
;                    : 1 12 13 14 15 36 37 46
<                    : 85
=                    : 46 47
>                    : 84
AND                  : 79
CHAR                 : 23
C_CONST              : 104
DATAFRAME            : 24
DESCRIBE             : 73
DIFFERENT            : 86
DO                   : 71 72
ELSE                 : 63
EQUAL                : 87
FALSE                : 82
FLOAT                : 22
FOR                  : 47 72
FUNC                 : 25 26 27
F_CONST              : 103
ID                   : 1 12 13 14 15 16 19 20 25 26 27 28 30 48 72 73 101
IF                   : 62
INT                  : 21
I_CONST              : 102
MAIN                 : 1
OR                   : 76
PRINT                : 53 54
PROG                 : 1
RETURN               : 25 26
TITLE                : 54 56
TO                   : 71 72
TRUE                 : 81
VAR                  : 12 13 14 15
VOID                 : 1 27
WHILE                : 65
[                    : 14 15 15 20
]                    : 14 15 15 20
error                : 
{                    : 1 25 26 27 62 63 65 71 72
}                    : 1 25 26 27 62 63 65 71 72

Nonterminals, with rules where they appear

AND_EXP              : 75 76
AND_EXP_PRIME        : 78 79
ASSIGNATION          : 34 71
BLOCK                : 1 25 26 27 32 62 63 65 71 72
B_EXP                : 78 79 84 85 86 87
B_EXP_PRIME          : 83
CONDITION            : 38
DESCRIBE_STMT        : 41
ELSE_STMT            : 62
EXP                  : 83
EXPRESSION           : 14 15 15 20 25 36 46 47 48 49 53 55 62 65 71 72 97
EXPRESSION_PRIME     : 75 76
EXP_PRIME            : 89 90 91
FACTOR               : 93 94 95
FOR_STMT             : 40
FUNCTION             : 6 8
FUNCTION_PRIME       : 1
FUNC_CALL            : 35
FUNC_CALL_PRIME      : 48 49
FUNC_PRIME           : 6 8
PARAM                : 25 26 27
PARAM_PRIME          : 28 30
PROGRAM              : 0
STATEMENT            : 32
TERM                 : 89 90 91
TERM_PRIME           : 93 94 95
TIPO_COMP            : 12
TIPO_PRIME           : 12 13 16
TIPO_SIMPLE          : 13 14 15 25 26 28 30
VARIABLE             : 46 47
VARS                 : 4
VARS_PRIME           : 1 1 4 25 26 27
VAR_CT               : 26 98 99 100
WHILE_STMT           : 39
WRITE                : 37
WRITE_PRIME          : 53 54 55 56
add_assignation_for_quad : 47
add_assignation_quad : 46
add_current_type     : 16
add_final_counter_for : 71 72
add_id               : 1 12 13 16
add_operand          : 101 102 103 104
add_operator         : 46 47 53 54 84 85 86 87 90 91 94 95
add_print_operator   : 55 56
add_type             : 1 21 22 23
aritmetics_operation : 84 85 86 87 90 91 94 95
check_boolean_expression_for : 71 72
check_exact_type_for : 71 71 72 72
empty                : 5 7 9 17 29 31 33 50 57 64 77 80 88 92 96
end_for              : 71 72
fill_go_to_false_quad : 62
fill_go_to_true_quad : 63
generate_for_quad    : 71 72
get_variable         : 19 72
go_to_false_quad     : 62
go_to_true_quad      : 63
print_quad           : 53 55 56
save_ids             : 1 12 13

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (2) add_id -> .

    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids . VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (105) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 105 (empty -> .)
    VOID            reduce using rule 105 (empty -> .)

    VARS_PRIME                     shift and go to state 8
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME . FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (6) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (7) FUNCTION_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (105) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 105 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 12
    FUNCTION                       shift and go to state 13
    empty                          shift and go to state 14

state 9

    (4) VARS_PRIME -> VARS . VARS_PRIME
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (105) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 105 (empty -> .)
    VOID            reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    VARS                           shift and go to state 9
    VARS_PRIME                     shift and go to state 16
    empty                          shift and go to state 10

state 10

    (5) VARS_PRIME -> empty .

    FUNC            reduce using rule 5 (VARS_PRIME -> empty .)
    VOID            reduce using rule 5 (VARS_PRIME -> empty .)
    FOR             reduce using rule 5 (VARS_PRIME -> empty .)
    ID              reduce using rule 5 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 5 (VARS_PRIME -> empty .)
    IF              reduce using rule 5 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 5 (VARS_PRIME -> empty .)
    TRUE            reduce using rule 5 (VARS_PRIME -> empty .)
    FALSE           reduce using rule 5 (VARS_PRIME -> empty .)
    (               reduce using rule 5 (VARS_PRIME -> empty .)
    *               reduce using rule 5 (VARS_PRIME -> empty .)
    /               reduce using rule 5 (VARS_PRIME -> empty .)
    I_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    F_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    C_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    }               reduce using rule 5 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 5 (VARS_PRIME -> empty .)


state 11

    (12) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (24) TIPO_COMP -> . DATAFRAME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 19
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_COMP                      shift and go to state 17
    TIPO_SIMPLE                    shift and go to state 18

state 12

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME . VOID MAIN { VARS_PRIME BLOCK }

    VOID            shift and go to state 23


state 13

    (6) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (105) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 105 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 25
    empty                          shift and go to state 26

state 14

    (7) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 7 (FUNCTION_PRIME -> empty .)


state 15

    (25) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> FUNC . VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 28
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 27

state 16

    (4) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    TRUE            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    FALSE           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    (               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    *               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    /               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    I_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    F_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    C_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)


state 17

    (12) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 29


state 18

    (13) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] [ EXPRESSION ] ;

    ID              shift and go to state 30


state 19

    (24) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 24 (TIPO_COMP -> DATAFRAME .)


state 20

    (21) TIPO_SIMPLE -> INT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 31

state 21

    (22) TIPO_SIMPLE -> FLOAT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (23) TIPO_SIMPLE -> CHAR . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID . MAIN { VARS_PRIME BLOCK }

    MAIN            shift and go to state 34


state 24

    (8) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (105) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 105 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 35
    empty                          shift and go to state 26

state 25

    (6) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 6 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 26

    (9) FUNC_PRIME -> empty .

    VOID            reduce using rule 9 (FUNC_PRIME -> empty .)


state 27

    (25) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    ID              shift and go to state 36


state 28

    (27) FUNCTION -> FUNC VOID . ID ( PARAM ) { VARS_PRIME BLOCK }

    ID              shift and go to state 37


state 29

    (12) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 38

state 30

    (13) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] [ EXPRESSION ] ;
    (2) add_id -> .

    [               shift and go to state 40
    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (21) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 21 (TIPO_SIMPLE -> INT add_type .)


state 32

    (22) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 22 (TIPO_SIMPLE -> FLOAT add_type .)


state 33

    (23) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 23 (TIPO_SIMPLE -> CHAR add_type .)


state 34

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN . { VARS_PRIME BLOCK }

    {               shift and go to state 41


state 35

    (8) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 8 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 36

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    (               shift and go to state 42


state 37

    (27) FUNCTION -> FUNC VOID ID . ( PARAM ) { VARS_PRIME BLOCK }

    (               shift and go to state 43


state 38

    (12) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 105 (empty -> .)

    TIPO_PRIME                     shift and go to state 44
    empty                          shift and go to state 46

state 39

    (13) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 105 (empty -> .)

    TIPO_PRIME                     shift and go to state 47
    empty                          shift and go to state 46

state 40

    (14) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] [ EXPRESSION ] ;
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 49
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 41

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (105) empty -> .

    VAR             shift and go to state 11
    FOR             reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    VARS_PRIME                     shift and go to state 64
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 42

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (105) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 105 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 65
    PARAM                          shift and go to state 66
    empty                          shift and go to state 67

state 43

    (27) FUNCTION -> FUNC VOID ID ( . PARAM ) { VARS_PRIME BLOCK }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (105) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 105 (empty -> .)

    PARAM                          shift and go to state 68
    TIPO_SIMPLE                    shift and go to state 65
    empty                          shift and go to state 67

state 44

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 69


state 45

    (16) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 70


state 46

    (17) TIPO_PRIME -> empty .

    ;               reduce using rule 17 (TIPO_PRIME -> empty .)


state 47

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 71


state 48

    (101) VAR_CT -> ID . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    FOR             reduce using rule 43 (add_operand -> .)
    PRINT           reduce using rule 43 (add_operand -> .)
    IF              reduce using rule 43 (add_operand -> .)
    WHILE           reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)
    RETURN          reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 72

state 49

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] [ EXPRESSION ] ;

    ]               shift and go to state 73


state 50

    (75) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (76) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (77) EXPRESSION_PRIME -> . empty
    (105) empty -> .

    OR              shift and go to state 75
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 74
    empty                          shift and go to state 76

state 51

    (78) AND_EXP -> B_EXP . AND_EXP_PRIME
    (79) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (80) AND_EXP_PRIME -> . empty
    (105) empty -> .

    AND             shift and go to state 78
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 77
    empty                          shift and go to state 79

state 52

    (81) B_EXP -> TRUE .

    AND             reduce using rule 81 (B_EXP -> TRUE .)
    OR              reduce using rule 81 (B_EXP -> TRUE .)
    ]               reduce using rule 81 (B_EXP -> TRUE .)
    )               reduce using rule 81 (B_EXP -> TRUE .)
    ;               reduce using rule 81 (B_EXP -> TRUE .)
    TRUE            reduce using rule 81 (B_EXP -> TRUE .)
    FALSE           reduce using rule 81 (B_EXP -> TRUE .)
    (               reduce using rule 81 (B_EXP -> TRUE .)
    *               reduce using rule 81 (B_EXP -> TRUE .)
    /               reduce using rule 81 (B_EXP -> TRUE .)
    ID              reduce using rule 81 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 81 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 81 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 81 (B_EXP -> TRUE .)
    ,               reduce using rule 81 (B_EXP -> TRUE .)
    TO              reduce using rule 81 (B_EXP -> TRUE .)
    FOR             reduce using rule 81 (B_EXP -> TRUE .)
    PRINT           reduce using rule 81 (B_EXP -> TRUE .)
    IF              reduce using rule 81 (B_EXP -> TRUE .)
    WHILE           reduce using rule 81 (B_EXP -> TRUE .)
    }               reduce using rule 81 (B_EXP -> TRUE .)
    RETURN          reduce using rule 81 (B_EXP -> TRUE .)


state 53

    (82) B_EXP -> FALSE .

    AND             reduce using rule 82 (B_EXP -> FALSE .)
    OR              reduce using rule 82 (B_EXP -> FALSE .)
    ]               reduce using rule 82 (B_EXP -> FALSE .)
    )               reduce using rule 82 (B_EXP -> FALSE .)
    ;               reduce using rule 82 (B_EXP -> FALSE .)
    TRUE            reduce using rule 82 (B_EXP -> FALSE .)
    FALSE           reduce using rule 82 (B_EXP -> FALSE .)
    (               reduce using rule 82 (B_EXP -> FALSE .)
    *               reduce using rule 82 (B_EXP -> FALSE .)
    /               reduce using rule 82 (B_EXP -> FALSE .)
    ID              reduce using rule 82 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 82 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 82 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 82 (B_EXP -> FALSE .)
    ,               reduce using rule 82 (B_EXP -> FALSE .)
    TO              reduce using rule 82 (B_EXP -> FALSE .)
    FOR             reduce using rule 82 (B_EXP -> FALSE .)
    PRINT           reduce using rule 82 (B_EXP -> FALSE .)
    IF              reduce using rule 82 (B_EXP -> FALSE .)
    WHILE           reduce using rule 82 (B_EXP -> FALSE .)
    }               reduce using rule 82 (B_EXP -> FALSE .)
    RETURN          reduce using rule 82 (B_EXP -> FALSE .)


state 54

    (83) B_EXP -> EXP . B_EXP_PRIME
    (84) B_EXP_PRIME -> . > add_operator B_EXP aritmetics_operation
    (85) B_EXP_PRIME -> . < add_operator B_EXP aritmetics_operation
    (86) B_EXP_PRIME -> . DIFFERENT add_operator B_EXP aritmetics_operation
    (87) B_EXP_PRIME -> . EQUAL add_operator B_EXP aritmetics_operation
    (88) B_EXP_PRIME -> . empty
    (105) empty -> .

    >               shift and go to state 81
    <               shift and go to state 82
    DIFFERENT       shift and go to state 83
    EQUAL           shift and go to state 84
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    B_EXP_PRIME                    shift and go to state 80
    empty                          shift and go to state 85

state 55

    (89) EXP -> TERM . EXP_PRIME
    (90) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (91) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (92) EXP_PRIME -> . empty
    (105) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    EXP_PRIME                      shift and go to state 86
    empty                          shift and go to state 89

state 56

    (93) TERM -> FACTOR . TERM_PRIME
    (94) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (95) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (96) TERM_PRIME -> . empty
    (105) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

  ! *               [ reduce using rule 105 (empty -> .) ]
  ! /               [ reduce using rule 105 (empty -> .) ]

    TERM_PRIME                     shift and go to state 90
    empty                          shift and go to state 93

state 57

    (97) FACTOR -> ( . EXPRESSION )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 94
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 58

    (98) FACTOR -> * . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 95

state 59

    (100) FACTOR -> VAR_CT .

    *               reduce using rule 100 (FACTOR -> VAR_CT .)
    /               reduce using rule 100 (FACTOR -> VAR_CT .)
    +               reduce using rule 100 (FACTOR -> VAR_CT .)
    -               reduce using rule 100 (FACTOR -> VAR_CT .)
    >               reduce using rule 100 (FACTOR -> VAR_CT .)
    <               reduce using rule 100 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 100 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 100 (FACTOR -> VAR_CT .)
    AND             reduce using rule 100 (FACTOR -> VAR_CT .)
    OR              reduce using rule 100 (FACTOR -> VAR_CT .)
    ]               reduce using rule 100 (FACTOR -> VAR_CT .)
    )               reduce using rule 100 (FACTOR -> VAR_CT .)
    ;               reduce using rule 100 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 100 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 100 (FACTOR -> VAR_CT .)
    (               reduce using rule 100 (FACTOR -> VAR_CT .)
    ID              reduce using rule 100 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 100 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 100 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 100 (FACTOR -> VAR_CT .)
    ,               reduce using rule 100 (FACTOR -> VAR_CT .)
    TO              reduce using rule 100 (FACTOR -> VAR_CT .)
    FOR             reduce using rule 100 (FACTOR -> VAR_CT .)
    PRINT           reduce using rule 100 (FACTOR -> VAR_CT .)
    IF              reduce using rule 100 (FACTOR -> VAR_CT .)
    WHILE           reduce using rule 100 (FACTOR -> VAR_CT .)
    }               reduce using rule 100 (FACTOR -> VAR_CT .)
    RETURN          reduce using rule 100 (FACTOR -> VAR_CT .)


state 60

    (99) FACTOR -> / . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 96

state 61

    (102) VAR_CT -> I_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    FOR             reduce using rule 43 (add_operand -> .)
    PRINT           reduce using rule 43 (add_operand -> .)
    IF              reduce using rule 43 (add_operand -> .)
    WHILE           reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)
    RETURN          reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 97

state 62

    (103) VAR_CT -> F_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    FOR             reduce using rule 43 (add_operand -> .)
    PRINT           reduce using rule 43 (add_operand -> .)
    IF              reduce using rule 43 (add_operand -> .)
    WHILE           reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)
    RETURN          reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 98

state 63

    (104) VAR_CT -> C_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    FOR             reduce using rule 43 (add_operand -> .)
    PRINT           reduce using rule 43 (add_operand -> .)
    IF              reduce using rule 43 (add_operand -> .)
    WHILE           reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)
    RETURN          reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 99

state 64

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 101
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 65

    (28) PARAM -> TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 117


state 66

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN VAR_CT }

    )               shift and go to state 118


state 67

    (29) PARAM -> empty .

    )               reduce using rule 29 (PARAM -> empty .)


state 68

    (27) FUNCTION -> FUNC VOID ID ( PARAM . ) { VARS_PRIME BLOCK }

    )               shift and go to state 119


state 69

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    TRUE            reduce using rule 3 (save_ids -> .)
    FALSE           reduce using rule 3 (save_ids -> .)
    (               reduce using rule 3 (save_ids -> .)
    *               reduce using rule 3 (save_ids -> .)
    /               reduce using rule 3 (save_ids -> .)
    I_CONST         reduce using rule 3 (save_ids -> .)
    F_CONST         reduce using rule 3 (save_ids -> .)
    C_CONST         reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 120

state 70

    (16) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 121

state 71

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    TRUE            reduce using rule 3 (save_ids -> .)
    FALSE           reduce using rule 3 (save_ids -> .)
    (               reduce using rule 3 (save_ids -> .)
    *               reduce using rule 3 (save_ids -> .)
    /               reduce using rule 3 (save_ids -> .)
    I_CONST         reduce using rule 3 (save_ids -> .)
    F_CONST         reduce using rule 3 (save_ids -> .)
    C_CONST         reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 122

state 72

    (101) VAR_CT -> ID add_operand .

    *               reduce using rule 101 (VAR_CT -> ID add_operand .)
    /               reduce using rule 101 (VAR_CT -> ID add_operand .)
    +               reduce using rule 101 (VAR_CT -> ID add_operand .)
    -               reduce using rule 101 (VAR_CT -> ID add_operand .)
    >               reduce using rule 101 (VAR_CT -> ID add_operand .)
    <               reduce using rule 101 (VAR_CT -> ID add_operand .)
    DIFFERENT       reduce using rule 101 (VAR_CT -> ID add_operand .)
    EQUAL           reduce using rule 101 (VAR_CT -> ID add_operand .)
    AND             reduce using rule 101 (VAR_CT -> ID add_operand .)
    OR              reduce using rule 101 (VAR_CT -> ID add_operand .)
    ]               reduce using rule 101 (VAR_CT -> ID add_operand .)
    )               reduce using rule 101 (VAR_CT -> ID add_operand .)
    ;               reduce using rule 101 (VAR_CT -> ID add_operand .)
    TRUE            reduce using rule 101 (VAR_CT -> ID add_operand .)
    FALSE           reduce using rule 101 (VAR_CT -> ID add_operand .)
    (               reduce using rule 101 (VAR_CT -> ID add_operand .)
    ID              reduce using rule 101 (VAR_CT -> ID add_operand .)
    I_CONST         reduce using rule 101 (VAR_CT -> ID add_operand .)
    F_CONST         reduce using rule 101 (VAR_CT -> ID add_operand .)
    C_CONST         reduce using rule 101 (VAR_CT -> ID add_operand .)
    ,               reduce using rule 101 (VAR_CT -> ID add_operand .)
    TO              reduce using rule 101 (VAR_CT -> ID add_operand .)
    FOR             reduce using rule 101 (VAR_CT -> ID add_operand .)
    PRINT           reduce using rule 101 (VAR_CT -> ID add_operand .)
    IF              reduce using rule 101 (VAR_CT -> ID add_operand .)
    WHILE           reduce using rule 101 (VAR_CT -> ID add_operand .)
    }               reduce using rule 101 (VAR_CT -> ID add_operand .)
    RETURN          reduce using rule 101 (VAR_CT -> ID add_operand .)


state 73

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . [ EXPRESSION ] ;

    ;               shift and go to state 124
    [               shift and go to state 123


state 74

    (75) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 75 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 75

    (76) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    AND_EXP                        shift and go to state 125
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 76

    (77) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    FOR             reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    PRINT           reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    IF              reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    WHILE           reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 77 (EXPRESSION_PRIME -> empty .)
    RETURN          reduce using rule 77 (EXPRESSION_PRIME -> empty .)


state 77

    (78) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 78 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 78

    (79) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 126
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 79

    (80) AND_EXP_PRIME -> empty .

    OR              reduce using rule 80 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 80 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 80 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 80 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 80 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 80 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 80 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 80 (AND_EXP_PRIME -> empty .)
    FOR             reduce using rule 80 (AND_EXP_PRIME -> empty .)
    PRINT           reduce using rule 80 (AND_EXP_PRIME -> empty .)
    IF              reduce using rule 80 (AND_EXP_PRIME -> empty .)
    WHILE           reduce using rule 80 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 80 (AND_EXP_PRIME -> empty .)
    RETURN          reduce using rule 80 (AND_EXP_PRIME -> empty .)


state 80

    (83) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    FOR             reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    PRINT           reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    IF              reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    WHILE           reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)
    RETURN          reduce using rule 83 (B_EXP -> EXP B_EXP_PRIME .)


state 81

    (84) B_EXP_PRIME -> > . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 127

state 82

    (85) B_EXP_PRIME -> < . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 128

state 83

    (86) B_EXP_PRIME -> DIFFERENT . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 129

state 84

    (87) B_EXP_PRIME -> EQUAL . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 130

state 85

    (88) B_EXP_PRIME -> empty .

    AND             reduce using rule 88 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 88 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 88 (B_EXP_PRIME -> empty .)
    )               reduce using rule 88 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 88 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 88 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 88 (B_EXP_PRIME -> empty .)
    (               reduce using rule 88 (B_EXP_PRIME -> empty .)
    *               reduce using rule 88 (B_EXP_PRIME -> empty .)
    /               reduce using rule 88 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 88 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 88 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 88 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 88 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 88 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 88 (B_EXP_PRIME -> empty .)
    FOR             reduce using rule 88 (B_EXP_PRIME -> empty .)
    PRINT           reduce using rule 88 (B_EXP_PRIME -> empty .)
    IF              reduce using rule 88 (B_EXP_PRIME -> empty .)
    WHILE           reduce using rule 88 (B_EXP_PRIME -> empty .)
    }               reduce using rule 88 (B_EXP_PRIME -> empty .)
    RETURN          reduce using rule 88 (B_EXP_PRIME -> empty .)


state 86

    (89) EXP -> TERM EXP_PRIME .

    >               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    FOR             reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    PRINT           reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    IF              reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    WHILE           reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 89 (EXP -> TERM EXP_PRIME .)
    RETURN          reduce using rule 89 (EXP -> TERM EXP_PRIME .)


state 87

    (90) EXP_PRIME -> + . add_operator TERM EXP_PRIME aritmetics_operation
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 131

state 88

    (91) EXP_PRIME -> - . add_operator TERM EXP_PRIME aritmetics_operation
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 132

state 89

    (92) EXP_PRIME -> empty .

    >               reduce using rule 92 (EXP_PRIME -> empty .)
    <               reduce using rule 92 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 92 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 92 (EXP_PRIME -> empty .)
    AND             reduce using rule 92 (EXP_PRIME -> empty .)
    OR              reduce using rule 92 (EXP_PRIME -> empty .)
    ]               reduce using rule 92 (EXP_PRIME -> empty .)
    )               reduce using rule 92 (EXP_PRIME -> empty .)
    ;               reduce using rule 92 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 92 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 92 (EXP_PRIME -> empty .)
    (               reduce using rule 92 (EXP_PRIME -> empty .)
    *               reduce using rule 92 (EXP_PRIME -> empty .)
    /               reduce using rule 92 (EXP_PRIME -> empty .)
    ID              reduce using rule 92 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 92 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 92 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 92 (EXP_PRIME -> empty .)
    ,               reduce using rule 92 (EXP_PRIME -> empty .)
    TO              reduce using rule 92 (EXP_PRIME -> empty .)
    FOR             reduce using rule 92 (EXP_PRIME -> empty .)
    PRINT           reduce using rule 92 (EXP_PRIME -> empty .)
    IF              reduce using rule 92 (EXP_PRIME -> empty .)
    WHILE           reduce using rule 92 (EXP_PRIME -> empty .)
    }               reduce using rule 92 (EXP_PRIME -> empty .)
    RETURN          reduce using rule 92 (EXP_PRIME -> empty .)


state 90

    (93) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    FOR             reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    PRINT           reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    IF              reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    WHILE           reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)
    RETURN          reduce using rule 93 (TERM -> FACTOR TERM_PRIME .)


state 91

    (94) TERM_PRIME -> * . add_operator FACTOR aritmetics_operation TERM_PRIME
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 133

state 92

    (95) TERM_PRIME -> / . add_operator FACTOR aritmetics_operation TERM_PRIME
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 134

state 93

    (96) TERM_PRIME -> empty .

    +               reduce using rule 96 (TERM_PRIME -> empty .)
    -               reduce using rule 96 (TERM_PRIME -> empty .)
    >               reduce using rule 96 (TERM_PRIME -> empty .)
    <               reduce using rule 96 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 96 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 96 (TERM_PRIME -> empty .)
    AND             reduce using rule 96 (TERM_PRIME -> empty .)
    OR              reduce using rule 96 (TERM_PRIME -> empty .)
    ]               reduce using rule 96 (TERM_PRIME -> empty .)
    )               reduce using rule 96 (TERM_PRIME -> empty .)
    ;               reduce using rule 96 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 96 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 96 (TERM_PRIME -> empty .)
    (               reduce using rule 96 (TERM_PRIME -> empty .)
    *               reduce using rule 96 (TERM_PRIME -> empty .)
    /               reduce using rule 96 (TERM_PRIME -> empty .)
    ID              reduce using rule 96 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 96 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 96 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 96 (TERM_PRIME -> empty .)
    ,               reduce using rule 96 (TERM_PRIME -> empty .)
    TO              reduce using rule 96 (TERM_PRIME -> empty .)
    FOR             reduce using rule 96 (TERM_PRIME -> empty .)
    PRINT           reduce using rule 96 (TERM_PRIME -> empty .)
    IF              reduce using rule 96 (TERM_PRIME -> empty .)
    WHILE           reduce using rule 96 (TERM_PRIME -> empty .)
    }               reduce using rule 96 (TERM_PRIME -> empty .)
    RETURN          reduce using rule 96 (TERM_PRIME -> empty .)


state 94

    (97) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 135


state 95

    (98) FACTOR -> * VAR_CT .

    *               reduce using rule 98 (FACTOR -> * VAR_CT .)
    /               reduce using rule 98 (FACTOR -> * VAR_CT .)
    +               reduce using rule 98 (FACTOR -> * VAR_CT .)
    -               reduce using rule 98 (FACTOR -> * VAR_CT .)
    >               reduce using rule 98 (FACTOR -> * VAR_CT .)
    <               reduce using rule 98 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 98 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 98 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 98 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 98 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 98 (FACTOR -> * VAR_CT .)
    )               reduce using rule 98 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 98 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 98 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 98 (FACTOR -> * VAR_CT .)
    (               reduce using rule 98 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 98 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 98 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 98 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 98 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 98 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 98 (FACTOR -> * VAR_CT .)
    FOR             reduce using rule 98 (FACTOR -> * VAR_CT .)
    PRINT           reduce using rule 98 (FACTOR -> * VAR_CT .)
    IF              reduce using rule 98 (FACTOR -> * VAR_CT .)
    WHILE           reduce using rule 98 (FACTOR -> * VAR_CT .)
    }               reduce using rule 98 (FACTOR -> * VAR_CT .)
    RETURN          reduce using rule 98 (FACTOR -> * VAR_CT .)


state 96

    (99) FACTOR -> / VAR_CT .

    *               reduce using rule 99 (FACTOR -> / VAR_CT .)
    /               reduce using rule 99 (FACTOR -> / VAR_CT .)
    +               reduce using rule 99 (FACTOR -> / VAR_CT .)
    -               reduce using rule 99 (FACTOR -> / VAR_CT .)
    >               reduce using rule 99 (FACTOR -> / VAR_CT .)
    <               reduce using rule 99 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 99 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 99 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 99 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 99 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 99 (FACTOR -> / VAR_CT .)
    )               reduce using rule 99 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 99 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 99 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 99 (FACTOR -> / VAR_CT .)
    (               reduce using rule 99 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 99 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 99 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 99 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 99 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 99 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 99 (FACTOR -> / VAR_CT .)
    FOR             reduce using rule 99 (FACTOR -> / VAR_CT .)
    PRINT           reduce using rule 99 (FACTOR -> / VAR_CT .)
    IF              reduce using rule 99 (FACTOR -> / VAR_CT .)
    WHILE           reduce using rule 99 (FACTOR -> / VAR_CT .)
    }               reduce using rule 99 (FACTOR -> / VAR_CT .)
    RETURN          reduce using rule 99 (FACTOR -> / VAR_CT .)


state 97

    (102) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    FOR             reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    PRINT           reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    IF              reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    WHILE           reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 102 (VAR_CT -> I_CONST add_operand .)
    RETURN          reduce using rule 102 (VAR_CT -> I_CONST add_operand .)


state 98

    (103) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    FOR             reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    PRINT           reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    IF              reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    WHILE           reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 103 (VAR_CT -> F_CONST add_operand .)
    RETURN          reduce using rule 103 (VAR_CT -> F_CONST add_operand .)


state 99

    (104) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    FOR             reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    PRINT           reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    IF              reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    WHILE           reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 104 (VAR_CT -> C_CONST add_operand .)
    RETURN          reduce using rule 104 (VAR_CT -> C_CONST add_operand .)


state 100

    (48) FUNC_CALL -> ID . ( EXPRESSION FUNC_CALL_PRIME )
    (73) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (19) VARIABLE -> ID . get_variable
    (20) VARIABLE -> ID . [ EXPRESSION ]
    (101) VAR_CT -> ID . add_operand
    (18) get_variable -> .
    (43) add_operand -> .

    (               shift and go to state 136
    .               shift and go to state 137
    [               shift and go to state 139
    =               reduce using rule 18 (get_variable -> .)
    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)

    get_variable                   shift and go to state 138
    add_operand                    shift and go to state 72

state 101

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK . }

    }               shift and go to state 140


state 102

    (32) BLOCK -> STATEMENT . BLOCK
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    STATEMENT                      shift and go to state 102
    BLOCK                          shift and go to state 141
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 103

    (33) BLOCK -> empty .

    }               reduce using rule 33 (BLOCK -> empty .)
    RETURN          reduce using rule 33 (BLOCK -> empty .)


state 104

    (34) STATEMENT -> ASSIGNATION .
    (71) FOR_STMT -> ASSIGNATION . check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (66) check_exact_type_for -> .

    FOR             reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    ID              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    TRUE            reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    FALSE           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    (               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    *               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    /               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    I_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    F_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    C_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    TO              reduce using rule 66 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 142

state 105

    (35) STATEMENT -> FUNC_CALL .

    FOR             reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    ID              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    TRUE            reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    FALSE           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    (               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    *               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    /               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    I_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    F_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    C_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 35 (STATEMENT -> FUNC_CALL .)


state 106

    (36) STATEMENT -> EXPRESSION . ;

    ;               shift and go to state 143


state 107

    (37) STATEMENT -> WRITE . ;

    ;               shift and go to state 144


state 108

    (38) STATEMENT -> CONDITION .

    FOR             reduce using rule 38 (STATEMENT -> CONDITION .)
    ID              reduce using rule 38 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 38 (STATEMENT -> CONDITION .)
    IF              reduce using rule 38 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 38 (STATEMENT -> CONDITION .)
    TRUE            reduce using rule 38 (STATEMENT -> CONDITION .)
    FALSE           reduce using rule 38 (STATEMENT -> CONDITION .)
    (               reduce using rule 38 (STATEMENT -> CONDITION .)
    *               reduce using rule 38 (STATEMENT -> CONDITION .)
    /               reduce using rule 38 (STATEMENT -> CONDITION .)
    I_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    F_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    C_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    }               reduce using rule 38 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 38 (STATEMENT -> CONDITION .)


state 109

    (39) STATEMENT -> WHILE_STMT .

    FOR             reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    ID              reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    TRUE            reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    FALSE           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    (               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    *               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    /               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    I_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    F_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    C_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 39 (STATEMENT -> WHILE_STMT .)


state 110

    (40) STATEMENT -> FOR_STMT .

    FOR             reduce using rule 40 (STATEMENT -> FOR_STMT .)
    ID              reduce using rule 40 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 40 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    TRUE            reduce using rule 40 (STATEMENT -> FOR_STMT .)
    FALSE           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    (               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    *               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    /               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    I_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    F_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    C_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 40 (STATEMENT -> FOR_STMT .)


state 111

    (41) STATEMENT -> DESCRIBE_STMT .

    FOR             reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    ID              reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    TRUE            reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    FALSE           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    (               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    *               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    /               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    I_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    F_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    C_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)


state 112

    (46) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad

    =               shift and go to state 145


state 113

    (47) ASSIGNATION -> FOR . VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (72) FOR_STMT -> FOR . ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]

    ID              shift and go to state 147

    VARIABLE                       shift and go to state 146

state 114

    (53) WRITE -> PRINT . add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> PRINT . add_operator ( TITLE WRITE_PRIME )
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 148

state 115

    (62) CONDITION -> IF . ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    (               shift and go to state 149


state 116

    (65) WHILE_STMT -> WHILE . ( EXPRESSION ) { BLOCK }

    (               shift and go to state 150


state 117

    (28) PARAM -> TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 152
    )               reduce using rule 105 (empty -> .)

    PARAM_PRIME                    shift and go to state 151
    empty                          shift and go to state 153

state 118

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN VAR_CT }

    {               shift and go to state 154


state 119

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) . { VARS_PRIME BLOCK }

    {               shift and go to state 155


state 120

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 121

    (16) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (11) add_current_type -> .

    ,               reduce using rule 11 (add_current_type -> .)
    ;               reduce using rule 11 (add_current_type -> .)

    add_current_type               shift and go to state 156

state 122

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 123

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ . EXPRESSION ] ;
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 157
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 124

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .

    VAR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FUNC            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    VOID            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FOR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    ID              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    PRINT           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    IF              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    WHILE           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    TRUE            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FALSE           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    (               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    *               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    /               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    }               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    RETURN          reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)


state 125

    (76) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (76) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (77) EXPRESSION_PRIME -> . empty
    (105) empty -> .

    OR              shift and go to state 75
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 158
    empty                          shift and go to state 76

state 126

    (79) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (79) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (80) AND_EXP_PRIME -> . empty
    (105) empty -> .

    AND             shift and go to state 78
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 159
    empty                          shift and go to state 79

state 127

    (84) B_EXP_PRIME -> > add_operator . B_EXP aritmetics_operation
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 160
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 128

    (85) B_EXP_PRIME -> < add_operator . B_EXP aritmetics_operation
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 161
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 129

    (86) B_EXP_PRIME -> DIFFERENT add_operator . B_EXP aritmetics_operation
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 162
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 130

    (87) B_EXP_PRIME -> EQUAL add_operator . B_EXP aritmetics_operation
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 163
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 131

    (90) EXP_PRIME -> + add_operator . TERM EXP_PRIME aritmetics_operation
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 164
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 132

    (91) EXP_PRIME -> - add_operator . TERM EXP_PRIME aritmetics_operation
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 165
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 133

    (94) TERM_PRIME -> * add_operator . FACTOR aritmetics_operation TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 166
    VAR_CT                         shift and go to state 59

state 134

    (95) TERM_PRIME -> / add_operator . FACTOR aritmetics_operation TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 167
    VAR_CT                         shift and go to state 59

state 135

    (97) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    FOR             reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    PRINT           reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    IF              reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    WHILE           reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)
    RETURN          reduce using rule 97 (FACTOR -> ( EXPRESSION ) .)


state 136

    (48) FUNC_CALL -> ID ( . EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 168
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 137

    (73) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 169


state 138

    (19) VARIABLE -> ID get_variable .

    =               reduce using rule 19 (VARIABLE -> ID get_variable .)


state 139

    (20) VARIABLE -> ID [ . EXPRESSION ]
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 170
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 140

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .)


state 141

    (32) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)


state 142

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for . TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    TO              shift and go to state 171


state 143

    (36) STATEMENT -> EXPRESSION ; .

    FOR             reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    ID              reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    PRINT           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    IF              reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    WHILE           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    TRUE            reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    FALSE           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    (               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    *               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    /               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    I_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    F_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    C_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    }               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    RETURN          reduce using rule 36 (STATEMENT -> EXPRESSION ; .)


state 144

    (37) STATEMENT -> WRITE ; .

    FOR             reduce using rule 37 (STATEMENT -> WRITE ; .)
    ID              reduce using rule 37 (STATEMENT -> WRITE ; .)
    PRINT           reduce using rule 37 (STATEMENT -> WRITE ; .)
    IF              reduce using rule 37 (STATEMENT -> WRITE ; .)
    WHILE           reduce using rule 37 (STATEMENT -> WRITE ; .)
    TRUE            reduce using rule 37 (STATEMENT -> WRITE ; .)
    FALSE           reduce using rule 37 (STATEMENT -> WRITE ; .)
    (               reduce using rule 37 (STATEMENT -> WRITE ; .)
    *               reduce using rule 37 (STATEMENT -> WRITE ; .)
    /               reduce using rule 37 (STATEMENT -> WRITE ; .)
    I_CONST         reduce using rule 37 (STATEMENT -> WRITE ; .)
    F_CONST         reduce using rule 37 (STATEMENT -> WRITE ; .)
    C_CONST         reduce using rule 37 (STATEMENT -> WRITE ; .)
    }               reduce using rule 37 (STATEMENT -> WRITE ; .)
    RETURN          reduce using rule 37 (STATEMENT -> WRITE ; .)


state 145

    (46) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 172

state 146

    (47) ASSIGNATION -> FOR VARIABLE . = add_operator EXPRESSION add_assignation_for_quad

    =               shift and go to state 173


state 147

    (72) FOR_STMT -> FOR ID . get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (19) VARIABLE -> ID . get_variable
    (20) VARIABLE -> ID . [ EXPRESSION ]
    (18) get_variable -> .

    [               shift and go to state 139
    TO              reduce using rule 18 (get_variable -> .)
    =               reduce using rule 18 (get_variable -> .)

    get_variable                   shift and go to state 174

state 148

    (53) WRITE -> PRINT add_operator . ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> PRINT add_operator . ( TITLE WRITE_PRIME )

    (               shift and go to state 175


state 149

    (62) CONDITION -> IF ( . EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 176
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 150

    (65) WHILE_STMT -> WHILE ( . EXPRESSION ) { BLOCK }
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 177
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 151

    (28) PARAM -> TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 28 (PARAM -> TIPO_SIMPLE ID PARAM_PRIME .)


state 152

    (30) PARAM_PRIME -> , . TIPO_SIMPLE ID PARAM_PRIME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 178

state 153

    (31) PARAM_PRIME -> empty .

    )               reduce using rule 31 (PARAM_PRIME -> empty .)


state 154

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN VAR_CT }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (105) empty -> .

    VAR             shift and go to state 11
    FOR             reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    VARS_PRIME                     shift and go to state 179
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 155

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (105) empty -> .

    VAR             shift and go to state 11
    FOR             reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    VARS_PRIME                     shift and go to state 180
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 156

    (16) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 105 (empty -> .)

    TIPO_PRIME                     shift and go to state 181
    empty                          shift and go to state 46

state 157

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION . ] ;

    ]               shift and go to state 182


state 158

    (76) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 76 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 159

    (79) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 79 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 160

    (84) B_EXP_PRIME -> > add_operator B_EXP . aritmetics_operation
    (74) aritmetics_operation -> .

    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 183

state 161

    (85) B_EXP_PRIME -> < add_operator B_EXP . aritmetics_operation
    (74) aritmetics_operation -> .

    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 184

state 162

    (86) B_EXP_PRIME -> DIFFERENT add_operator B_EXP . aritmetics_operation
    (74) aritmetics_operation -> .

    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 185

state 163

    (87) B_EXP_PRIME -> EQUAL add_operator B_EXP . aritmetics_operation
    (74) aritmetics_operation -> .

    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 186

state 164

    (90) EXP_PRIME -> + add_operator TERM . EXP_PRIME aritmetics_operation
    (90) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (91) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (92) EXP_PRIME -> . empty
    (105) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    EXP_PRIME                      shift and go to state 187
    empty                          shift and go to state 89

state 165

    (91) EXP_PRIME -> - add_operator TERM . EXP_PRIME aritmetics_operation
    (90) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (91) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (92) EXP_PRIME -> . empty
    (105) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    EXP_PRIME                      shift and go to state 188
    empty                          shift and go to state 89

state 166

    (94) TERM_PRIME -> * add_operator FACTOR . aritmetics_operation TERM_PRIME
    (74) aritmetics_operation -> .

    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    +               reduce using rule 74 (aritmetics_operation -> .)
    -               reduce using rule 74 (aritmetics_operation -> .)
    >               reduce using rule 74 (aritmetics_operation -> .)
    <               reduce using rule 74 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 74 (aritmetics_operation -> .)
    EQUAL           reduce using rule 74 (aritmetics_operation -> .)
    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 189

state 167

    (95) TERM_PRIME -> / add_operator FACTOR . aritmetics_operation TERM_PRIME
    (74) aritmetics_operation -> .

    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    +               reduce using rule 74 (aritmetics_operation -> .)
    -               reduce using rule 74 (aritmetics_operation -> .)
    >               reduce using rule 74 (aritmetics_operation -> .)
    <               reduce using rule 74 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 74 (aritmetics_operation -> .)
    EQUAL           reduce using rule 74 (aritmetics_operation -> .)
    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 190

state 168

    (48) FUNC_CALL -> ID ( EXPRESSION . FUNC_CALL_PRIME )
    (49) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (50) FUNC_CALL_PRIME -> . empty
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (105) empty -> .
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 105 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 191
    FUNC_CALL_PRIME                shift and go to state 192
    empty                          shift and go to state 193
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 169

    (73) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 194


state 170

    (20) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 195


state 171

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO . ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    (               shift and go to state 196


state 172

    (46) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 197
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 173

    (47) ASSIGNATION -> FOR VARIABLE = . add_operator EXPRESSION add_assignation_for_quad
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 198

state 174

    (72) FOR_STMT -> FOR ID get_variable . check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (19) VARIABLE -> ID get_variable .
    (66) check_exact_type_for -> .

    =               reduce using rule 19 (VARIABLE -> ID get_variable .)
    TO              reduce using rule 66 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 199

state 175

    (53) WRITE -> PRINT add_operator ( . EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> PRINT add_operator ( . TITLE WRITE_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 201
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 200
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 176

    (62) CONDITION -> IF ( EXPRESSION . ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    )               shift and go to state 202


state 177

    (65) WHILE_STMT -> WHILE ( EXPRESSION . ) { BLOCK }

    )               shift and go to state 203


state 178

    (30) PARAM_PRIME -> , TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 204


state 179

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN VAR_CT }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    RETURN          reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 205
    EXPRESSION                     shift and go to state 106
    VAR_CT                         shift and go to state 59
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56

state 180

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 206
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 181

    (16) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 16 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 182

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] . ;

    ;               shift and go to state 207


state 183

    (84) B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 84 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)


state 184

    (85) B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 85 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)


state 185

    (86) B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 86 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)


state 186

    (87) B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FOR             reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    PRINT           reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    IF              reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    WHILE           reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    RETURN          reduce using rule 87 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)


state 187

    (90) EXP_PRIME -> + add_operator TERM EXP_PRIME . aritmetics_operation
    (74) aritmetics_operation -> .

    >               reduce using rule 74 (aritmetics_operation -> .)
    <               reduce using rule 74 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 74 (aritmetics_operation -> .)
    EQUAL           reduce using rule 74 (aritmetics_operation -> .)
    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 208

state 188

    (91) EXP_PRIME -> - add_operator TERM EXP_PRIME . aritmetics_operation
    (74) aritmetics_operation -> .

    >               reduce using rule 74 (aritmetics_operation -> .)
    <               reduce using rule 74 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 74 (aritmetics_operation -> .)
    EQUAL           reduce using rule 74 (aritmetics_operation -> .)
    AND             reduce using rule 74 (aritmetics_operation -> .)
    OR              reduce using rule 74 (aritmetics_operation -> .)
    ]               reduce using rule 74 (aritmetics_operation -> .)
    )               reduce using rule 74 (aritmetics_operation -> .)
    ;               reduce using rule 74 (aritmetics_operation -> .)
    TRUE            reduce using rule 74 (aritmetics_operation -> .)
    FALSE           reduce using rule 74 (aritmetics_operation -> .)
    (               reduce using rule 74 (aritmetics_operation -> .)
    *               reduce using rule 74 (aritmetics_operation -> .)
    /               reduce using rule 74 (aritmetics_operation -> .)
    ID              reduce using rule 74 (aritmetics_operation -> .)
    I_CONST         reduce using rule 74 (aritmetics_operation -> .)
    F_CONST         reduce using rule 74 (aritmetics_operation -> .)
    C_CONST         reduce using rule 74 (aritmetics_operation -> .)
    ,               reduce using rule 74 (aritmetics_operation -> .)
    TO              reduce using rule 74 (aritmetics_operation -> .)
    FOR             reduce using rule 74 (aritmetics_operation -> .)
    PRINT           reduce using rule 74 (aritmetics_operation -> .)
    IF              reduce using rule 74 (aritmetics_operation -> .)
    WHILE           reduce using rule 74 (aritmetics_operation -> .)
    }               reduce using rule 74 (aritmetics_operation -> .)
    RETURN          reduce using rule 74 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 209

state 189

    (94) TERM_PRIME -> * add_operator FACTOR aritmetics_operation . TERM_PRIME
    (94) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (95) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (96) TERM_PRIME -> . empty
    (105) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

  ! *               [ reduce using rule 105 (empty -> .) ]
  ! /               [ reduce using rule 105 (empty -> .) ]

    TERM_PRIME                     shift and go to state 210
    empty                          shift and go to state 93

state 190

    (95) TERM_PRIME -> / add_operator FACTOR aritmetics_operation . TERM_PRIME
    (94) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (95) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (96) TERM_PRIME -> . empty
    (105) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    DIFFERENT       reduce using rule 105 (empty -> .)
    EQUAL           reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

  ! *               [ reduce using rule 105 (empty -> .) ]
  ! /               [ reduce using rule 105 (empty -> .) ]

    TERM_PRIME                     shift and go to state 211
    empty                          shift and go to state 93

state 191

    (49) FUNC_CALL_PRIME -> EXPRESSION . FUNC_CALL_PRIME
    (49) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (50) FUNC_CALL_PRIME -> . empty
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (105) empty -> .
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 105 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 191
    FUNC_CALL_PRIME                shift and go to state 212
    empty                          shift and go to state 193
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 192

    (48) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME . )

    )               shift and go to state 213


state 193

    (50) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 50 (FUNC_CALL_PRIME -> empty .)


state 194

    (73) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 214


state 195

    (20) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 20 (VARIABLE -> ID [ EXPRESSION ] .)


state 196

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( . EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 215
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 197

    (46) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 216


state 198

    (47) ASSIGNATION -> FOR VARIABLE = add_operator . EXPRESSION add_assignation_for_quad
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 217
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 199

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for . TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    TO              shift and go to state 218


state 200

    (53) WRITE -> PRINT add_operator ( EXPRESSION . print_quad WRITE_PRIME )
    (51) print_quad -> .

    ,               reduce using rule 51 (print_quad -> .)
    )               reduce using rule 51 (print_quad -> .)

    print_quad                     shift and go to state 219

state 201

    (54) WRITE -> PRINT add_operator ( TITLE . WRITE_PRIME )
    (55) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (57) WRITE_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 221
    )               reduce using rule 105 (empty -> .)

    WRITE_PRIME                    shift and go to state 220
    empty                          shift and go to state 222

state 202

    (62) CONDITION -> IF ( EXPRESSION ) . { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT

    {               shift and go to state 223


state 203

    (65) WHILE_STMT -> WHILE ( EXPRESSION ) . { BLOCK }

    {               shift and go to state 224


state 204

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 152
    )               reduce using rule 105 (empty -> .)

    PARAM_PRIME                    shift and go to state 225
    empty                          shift and go to state 153

state 205

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN VAR_CT }

    RETURN          shift and go to state 226


state 206

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK . }

    }               shift and go to state 227


state 207

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .

    VAR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FUNC            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    VOID            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FOR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    ID              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    PRINT           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    IF              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    WHILE           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    TRUE            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FALSE           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    (               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    *               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    /               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    }               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    RETURN          reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)


state 208

    (90) EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 90 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)


state 209

    (91) EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FOR             reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    PRINT           reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    IF              reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    WHILE           reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    RETURN          reduce using rule 91 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)


state 210

    (94) TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 94 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 211

    (95) TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FOR             reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    PRINT           reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    IF              reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    WHILE           reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    RETURN          reduce using rule 95 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 212

    (49) FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .

    )               reduce using rule 49 (FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .)


state 213

    (48) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .

    FOR             reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    ID              reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    PRINT           reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    IF              reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    WHILE           reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    TRUE            reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FALSE           reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    (               reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    *               reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    /               reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    I_CONST         reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    F_CONST         reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    C_CONST         reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    }               reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    RETURN          reduce using rule 48 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)


state 214

    (73) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    FOR             reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    ID              reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    TRUE            reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FALSE           reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    (               reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    *               reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    /               reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    I_CONST         reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    F_CONST         reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    C_CONST         reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 73 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 215

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION . check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (66) check_exact_type_for -> .

    )               reduce using rule 66 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 228

state 216

    (46) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (44) add_assignation_quad -> .

    TO              reduce using rule 44 (add_assignation_quad -> .)
    FOR             reduce using rule 44 (add_assignation_quad -> .)
    ID              reduce using rule 44 (add_assignation_quad -> .)
    PRINT           reduce using rule 44 (add_assignation_quad -> .)
    IF              reduce using rule 44 (add_assignation_quad -> .)
    WHILE           reduce using rule 44 (add_assignation_quad -> .)
    TRUE            reduce using rule 44 (add_assignation_quad -> .)
    FALSE           reduce using rule 44 (add_assignation_quad -> .)
    (               reduce using rule 44 (add_assignation_quad -> .)
    *               reduce using rule 44 (add_assignation_quad -> .)
    /               reduce using rule 44 (add_assignation_quad -> .)
    I_CONST         reduce using rule 44 (add_assignation_quad -> .)
    F_CONST         reduce using rule 44 (add_assignation_quad -> .)
    C_CONST         reduce using rule 44 (add_assignation_quad -> .)
    }               reduce using rule 44 (add_assignation_quad -> .)
    RETURN          reduce using rule 44 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 229

state 217

    (47) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION . add_assignation_for_quad
    (45) add_assignation_for_quad -> .

    TO              reduce using rule 45 (add_assignation_for_quad -> .)
    FOR             reduce using rule 45 (add_assignation_for_quad -> .)
    ID              reduce using rule 45 (add_assignation_for_quad -> .)
    PRINT           reduce using rule 45 (add_assignation_for_quad -> .)
    IF              reduce using rule 45 (add_assignation_for_quad -> .)
    WHILE           reduce using rule 45 (add_assignation_for_quad -> .)
    TRUE            reduce using rule 45 (add_assignation_for_quad -> .)
    FALSE           reduce using rule 45 (add_assignation_for_quad -> .)
    (               reduce using rule 45 (add_assignation_for_quad -> .)
    *               reduce using rule 45 (add_assignation_for_quad -> .)
    /               reduce using rule 45 (add_assignation_for_quad -> .)
    I_CONST         reduce using rule 45 (add_assignation_for_quad -> .)
    F_CONST         reduce using rule 45 (add_assignation_for_quad -> .)
    C_CONST         reduce using rule 45 (add_assignation_for_quad -> .)
    }               reduce using rule 45 (add_assignation_for_quad -> .)
    RETURN          reduce using rule 45 (add_assignation_for_quad -> .)

    add_assignation_for_quad       shift and go to state 230

state 218

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO . ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for

    (               shift and go to state 231


state 219

    (53) WRITE -> PRINT add_operator ( EXPRESSION print_quad . WRITE_PRIME )
    (55) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (57) WRITE_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 221
    )               reduce using rule 105 (empty -> .)

    WRITE_PRIME                    shift and go to state 232
    empty                          shift and go to state 222

state 220

    (54) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME . )

    )               shift and go to state 233


state 221

    (55) WRITE_PRIME -> , . add_print_operator EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> , . add_print_operator TITLE print_quad WRITE_PRIME
    (52) add_print_operator -> .

    TITLE           reduce using rule 52 (add_print_operator -> .)
    TRUE            reduce using rule 52 (add_print_operator -> .)
    FALSE           reduce using rule 52 (add_print_operator -> .)
    (               reduce using rule 52 (add_print_operator -> .)
    *               reduce using rule 52 (add_print_operator -> .)
    /               reduce using rule 52 (add_print_operator -> .)
    ID              reduce using rule 52 (add_print_operator -> .)
    I_CONST         reduce using rule 52 (add_print_operator -> .)
    F_CONST         reduce using rule 52 (add_print_operator -> .)
    C_CONST         reduce using rule 52 (add_print_operator -> .)

    add_print_operator             shift and go to state 234

state 222

    (57) WRITE_PRIME -> empty .

    )               reduce using rule 57 (WRITE_PRIME -> empty .)


state 223

    (62) CONDITION -> IF ( EXPRESSION ) { . go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (58) go_to_false_quad -> .

    FOR             reduce using rule 58 (go_to_false_quad -> .)
    ID              reduce using rule 58 (go_to_false_quad -> .)
    PRINT           reduce using rule 58 (go_to_false_quad -> .)
    IF              reduce using rule 58 (go_to_false_quad -> .)
    WHILE           reduce using rule 58 (go_to_false_quad -> .)
    TRUE            reduce using rule 58 (go_to_false_quad -> .)
    FALSE           reduce using rule 58 (go_to_false_quad -> .)
    (               reduce using rule 58 (go_to_false_quad -> .)
    *               reduce using rule 58 (go_to_false_quad -> .)
    /               reduce using rule 58 (go_to_false_quad -> .)
    I_CONST         reduce using rule 58 (go_to_false_quad -> .)
    F_CONST         reduce using rule 58 (go_to_false_quad -> .)
    C_CONST         reduce using rule 58 (go_to_false_quad -> .)
    }               reduce using rule 58 (go_to_false_quad -> .)

    go_to_false_quad               shift and go to state 235

state 224

    (65) WHILE_STMT -> WHILE ( EXPRESSION ) { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 236
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 225

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 30 (PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .)


state 226

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . VAR_CT }
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60

    EXPRESSION                     shift and go to state 237
    VAR_CT                         shift and go to state 238
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56

state 227

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .

    FUNC            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)
    VOID            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)


state 228

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for . add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (67) add_final_counter_for -> .

    )               reduce using rule 67 (add_final_counter_for -> .)

    add_final_counter_for          shift and go to state 239

state 229

    (46) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    TO              reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    ID              reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    TRUE            reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FALSE           reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    (               reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    *               reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    /               reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    I_CONST         reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    F_CONST         reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    C_CONST         reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 46 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 230

    (47) ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .

    TO              reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FOR             reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    ID              reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    PRINT           reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    IF              reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    WHILE           reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    TRUE            reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    FALSE           reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    (               reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    *               reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    /               reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    I_CONST         reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    F_CONST         reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    C_CONST         reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    }               reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)
    RETURN          reduce using rule 47 (ASSIGNATION -> FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad .)


state 231

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( . EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 240
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 232

    (53) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME . )

    )               shift and go to state 241


state 233

    (54) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .

    ;               reduce using rule 54 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)


state 234

    (55) WRITE_PRIME -> , add_print_operator . EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> , add_print_operator . TITLE print_quad WRITE_PRIME
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 243
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 242
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 235

    (62) CONDITION -> IF ( EXPRESSION ) { go_to_false_quad . BLOCK } fill_go_to_false_quad ELSE_STMT
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 244
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 236

    (65) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK . }

    }               shift and go to state 245


state 237

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION . }

    }               shift and go to state 246


state 238

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT . }
    (100) FACTOR -> VAR_CT .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 247
    *               reduce using rule 100 (FACTOR -> VAR_CT .)
    /               reduce using rule 100 (FACTOR -> VAR_CT .)
    +               reduce using rule 100 (FACTOR -> VAR_CT .)
    -               reduce using rule 100 (FACTOR -> VAR_CT .)
    >               reduce using rule 100 (FACTOR -> VAR_CT .)
    <               reduce using rule 100 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 100 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 100 (FACTOR -> VAR_CT .)
    AND             reduce using rule 100 (FACTOR -> VAR_CT .)
    OR              reduce using rule 100 (FACTOR -> VAR_CT .)

  ! }               [ reduce using rule 100 (FACTOR -> VAR_CT .) ]


state 239

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for . check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (69) check_boolean_expression_for -> .

    )               reduce using rule 69 (check_boolean_expression_for -> .)

    check_boolean_expression_for   shift and go to state 248

state 240

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION . check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (66) check_exact_type_for -> .

    )               reduce using rule 66 (check_exact_type_for -> .)

    check_exact_type_for           shift and go to state 249

state 241

    (53) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .

    ;               reduce using rule 53 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)


state 242

    (55) WRITE_PRIME -> , add_print_operator EXPRESSION . print_quad WRITE_PRIME
    (51) print_quad -> .

    ,               reduce using rule 51 (print_quad -> .)
    )               reduce using rule 51 (print_quad -> .)

    print_quad                     shift and go to state 250

state 243

    (56) WRITE_PRIME -> , add_print_operator TITLE . print_quad WRITE_PRIME
    (51) print_quad -> .

    ,               reduce using rule 51 (print_quad -> .)
    )               reduce using rule 51 (print_quad -> .)

    print_quad                     shift and go to state 251

state 244

    (62) CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK . } fill_go_to_false_quad ELSE_STMT

    }               shift and go to state 252


state 245

    (65) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .

    FOR             reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    ID              reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    PRINT           reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    IF              reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    WHILE           reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    TRUE            reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    FALSE           reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    (               reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    *               reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    /               reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    I_CONST         reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    F_CONST         reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    C_CONST         reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    }               reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    RETURN          reduce using rule 65 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)


state 246

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .

    FUNC            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)
    VOID            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)


state 247

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .

    FUNC            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)
    VOID            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)


state 248

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for . ) generate_for_quad DO { BLOCK } end_for

    )               shift and go to state 253


state 249

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for . add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (67) add_final_counter_for -> .

    )               reduce using rule 67 (add_final_counter_for -> .)

    add_final_counter_for          shift and go to state 254

state 250

    (55) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad . WRITE_PRIME
    (55) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (57) WRITE_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 221
    )               reduce using rule 105 (empty -> .)

    WRITE_PRIME                    shift and go to state 255
    empty                          shift and go to state 222

state 251

    (56) WRITE_PRIME -> , add_print_operator TITLE print_quad . WRITE_PRIME
    (55) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (56) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (57) WRITE_PRIME -> . empty
    (105) empty -> .

    ,               shift and go to state 221
    )               reduce using rule 105 (empty -> .)

    WRITE_PRIME                    shift and go to state 256
    empty                          shift and go to state 222

state 252

    (62) CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } . fill_go_to_false_quad ELSE_STMT
    (59) fill_go_to_false_quad -> .

    ELSE            reduce using rule 59 (fill_go_to_false_quad -> .)
    FOR             reduce using rule 59 (fill_go_to_false_quad -> .)
    ID              reduce using rule 59 (fill_go_to_false_quad -> .)
    PRINT           reduce using rule 59 (fill_go_to_false_quad -> .)
    IF              reduce using rule 59 (fill_go_to_false_quad -> .)
    WHILE           reduce using rule 59 (fill_go_to_false_quad -> .)
    TRUE            reduce using rule 59 (fill_go_to_false_quad -> .)
    FALSE           reduce using rule 59 (fill_go_to_false_quad -> .)
    (               reduce using rule 59 (fill_go_to_false_quad -> .)
    *               reduce using rule 59 (fill_go_to_false_quad -> .)
    /               reduce using rule 59 (fill_go_to_false_quad -> .)
    I_CONST         reduce using rule 59 (fill_go_to_false_quad -> .)
    F_CONST         reduce using rule 59 (fill_go_to_false_quad -> .)
    C_CONST         reduce using rule 59 (fill_go_to_false_quad -> .)
    }               reduce using rule 59 (fill_go_to_false_quad -> .)
    RETURN          reduce using rule 59 (fill_go_to_false_quad -> .)

    fill_go_to_false_quad          shift and go to state 257

state 253

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) . generate_for_quad DO { BLOCK } end_for
    (68) generate_for_quad -> .

    DO              reduce using rule 68 (generate_for_quad -> .)

    generate_for_quad              shift and go to state 258

state 254

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for . check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (69) check_boolean_expression_for -> .

    )               reduce using rule 69 (check_boolean_expression_for -> .)

    check_boolean_expression_for   shift and go to state 259

state 255

    (55) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .

    )               reduce using rule 55 (WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .)


state 256

    (56) WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .

    )               reduce using rule 56 (WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .)


state 257

    (62) CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad . ELSE_STMT
    (63) ELSE_STMT -> . ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad
    (64) ELSE_STMT -> . empty
    (105) empty -> .

    ELSE            shift and go to state 261
    FOR             reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    I_CONST         reduce using rule 105 (empty -> .)
    F_CONST         reduce using rule 105 (empty -> .)
    C_CONST         reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    ELSE_STMT                      shift and go to state 260
    empty                          shift and go to state 262

state 258

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad . DO { BLOCK } end_for

    DO              shift and go to state 263


state 259

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for . ) generate_for_quad DO { BLOCK } end_for

    )               shift and go to state 264


state 260

    (62) CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .

    FOR             reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    ID              reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    PRINT           reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    IF              reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    WHILE           reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    TRUE            reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    FALSE           reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    (               reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    *               reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    /               reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    I_CONST         reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    F_CONST         reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    C_CONST         reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    }               reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)
    RETURN          reduce using rule 62 (CONDITION -> IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT .)


state 261

    (63) ELSE_STMT -> ELSE . { go_to_true_quad BLOCK } fill_go_to_true_quad

    {               shift and go to state 265


state 262

    (64) ELSE_STMT -> empty .

    FOR             reduce using rule 64 (ELSE_STMT -> empty .)
    ID              reduce using rule 64 (ELSE_STMT -> empty .)
    PRINT           reduce using rule 64 (ELSE_STMT -> empty .)
    IF              reduce using rule 64 (ELSE_STMT -> empty .)
    WHILE           reduce using rule 64 (ELSE_STMT -> empty .)
    TRUE            reduce using rule 64 (ELSE_STMT -> empty .)
    FALSE           reduce using rule 64 (ELSE_STMT -> empty .)
    (               reduce using rule 64 (ELSE_STMT -> empty .)
    *               reduce using rule 64 (ELSE_STMT -> empty .)
    /               reduce using rule 64 (ELSE_STMT -> empty .)
    I_CONST         reduce using rule 64 (ELSE_STMT -> empty .)
    F_CONST         reduce using rule 64 (ELSE_STMT -> empty .)
    C_CONST         reduce using rule 64 (ELSE_STMT -> empty .)
    }               reduce using rule 64 (ELSE_STMT -> empty .)
    RETURN          reduce using rule 64 (ELSE_STMT -> empty .)


state 263

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO . { BLOCK } end_for

    {               shift and go to state 266


state 264

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) . generate_for_quad DO { BLOCK } end_for
    (68) generate_for_quad -> .

    DO              reduce using rule 68 (generate_for_quad -> .)

    generate_for_quad              shift and go to state 267

state 265

    (63) ELSE_STMT -> ELSE { . go_to_true_quad BLOCK } fill_go_to_true_quad
    (60) go_to_true_quad -> .

    FOR             reduce using rule 60 (go_to_true_quad -> .)
    ID              reduce using rule 60 (go_to_true_quad -> .)
    PRINT           reduce using rule 60 (go_to_true_quad -> .)
    IF              reduce using rule 60 (go_to_true_quad -> .)
    WHILE           reduce using rule 60 (go_to_true_quad -> .)
    TRUE            reduce using rule 60 (go_to_true_quad -> .)
    FALSE           reduce using rule 60 (go_to_true_quad -> .)
    (               reduce using rule 60 (go_to_true_quad -> .)
    *               reduce using rule 60 (go_to_true_quad -> .)
    /               reduce using rule 60 (go_to_true_quad -> .)
    I_CONST         reduce using rule 60 (go_to_true_quad -> .)
    F_CONST         reduce using rule 60 (go_to_true_quad -> .)
    C_CONST         reduce using rule 60 (go_to_true_quad -> .)
    }               reduce using rule 60 (go_to_true_quad -> .)

    go_to_true_quad                shift and go to state 268

state 266

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { . BLOCK } end_for
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    ASSIGNATION                    shift and go to state 104
    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 269
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 267

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad . DO { BLOCK } end_for

    DO              shift and go to state 270


state 268

    (63) ELSE_STMT -> ELSE { go_to_true_quad . BLOCK } fill_go_to_true_quad
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 271
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 269

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK . } end_for

    }               shift and go to state 272


state 270

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO . { BLOCK } end_for

    {               shift and go to state 273


state 271

    (63) ELSE_STMT -> ELSE { go_to_true_quad BLOCK . } fill_go_to_true_quad

    }               shift and go to state 274


state 272

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } . end_for
    (70) end_for -> .

    FOR             reduce using rule 70 (end_for -> .)
    ID              reduce using rule 70 (end_for -> .)
    PRINT           reduce using rule 70 (end_for -> .)
    IF              reduce using rule 70 (end_for -> .)
    WHILE           reduce using rule 70 (end_for -> .)
    TRUE            reduce using rule 70 (end_for -> .)
    FALSE           reduce using rule 70 (end_for -> .)
    (               reduce using rule 70 (end_for -> .)
    *               reduce using rule 70 (end_for -> .)
    /               reduce using rule 70 (end_for -> .)
    I_CONST         reduce using rule 70 (end_for -> .)
    F_CONST         reduce using rule 70 (end_for -> .)
    C_CONST         reduce using rule 70 (end_for -> .)
    }               reduce using rule 70 (end_for -> .)
    RETURN          reduce using rule 70 (end_for -> .)

    end_for                        shift and go to state 275

state 273

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { . BLOCK } end_for
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE ;
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (105) empty -> .
    (46) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (47) ASSIGNATION -> . FOR VARIABLE = add_operator EXPRESSION add_assignation_for_quad
    (48) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (75) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (53) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (54) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (62) CONDITION -> . IF ( EXPRESSION ) { go_to_false_quad BLOCK } fill_go_to_false_quad ELSE_STMT
    (65) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (71) FOR_STMT -> . ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (72) FOR_STMT -> . FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for
    (73) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (78) AND_EXP -> . B_EXP AND_EXP_PRIME
    (81) B_EXP -> . TRUE
    (82) B_EXP -> . FALSE
    (83) B_EXP -> . EXP B_EXP_PRIME
    (89) EXP -> . TERM EXP_PRIME
    (93) TERM -> . FACTOR TERM_PRIME
    (97) FACTOR -> . ( EXPRESSION )
    (98) FACTOR -> . * VAR_CT
    (99) FACTOR -> . / VAR_CT
    (100) FACTOR -> . VAR_CT
    (101) VAR_CT -> . ID add_operand
    (102) VAR_CT -> . I_CONST add_operand
    (103) VAR_CT -> . F_CONST add_operand
    (104) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 105 (empty -> .)
    FOR             shift and go to state 113
    ID              shift and go to state 100
    PRINT           shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 276
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 274

    (63) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } . fill_go_to_true_quad
    (61) fill_go_to_true_quad -> .

    FOR             reduce using rule 61 (fill_go_to_true_quad -> .)
    ID              reduce using rule 61 (fill_go_to_true_quad -> .)
    PRINT           reduce using rule 61 (fill_go_to_true_quad -> .)
    IF              reduce using rule 61 (fill_go_to_true_quad -> .)
    WHILE           reduce using rule 61 (fill_go_to_true_quad -> .)
    TRUE            reduce using rule 61 (fill_go_to_true_quad -> .)
    FALSE           reduce using rule 61 (fill_go_to_true_quad -> .)
    (               reduce using rule 61 (fill_go_to_true_quad -> .)
    *               reduce using rule 61 (fill_go_to_true_quad -> .)
    /               reduce using rule 61 (fill_go_to_true_quad -> .)
    I_CONST         reduce using rule 61 (fill_go_to_true_quad -> .)
    F_CONST         reduce using rule 61 (fill_go_to_true_quad -> .)
    C_CONST         reduce using rule 61 (fill_go_to_true_quad -> .)
    }               reduce using rule 61 (fill_go_to_true_quad -> .)
    RETURN          reduce using rule 61 (fill_go_to_true_quad -> .)

    fill_go_to_true_quad           shift and go to state 277

state 275

    (71) FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .

    FOR             reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    ID              reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    PRINT           reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    IF              reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    WHILE           reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    TRUE            reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FALSE           reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    (               reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    *               reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    /               reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    I_CONST         reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    F_CONST         reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    C_CONST         reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    }               reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    RETURN          reduce using rule 71 (FOR_STMT -> ASSIGNATION check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)


state 276

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK . } end_for

    }               shift and go to state 278


state 277

    (63) ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .

    FOR             reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    ID              reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    PRINT           reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    IF              reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    WHILE           reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    TRUE            reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    FALSE           reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    (               reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    *               reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    /               reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    I_CONST         reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    F_CONST         reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    C_CONST         reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    }               reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)
    RETURN          reduce using rule 63 (ELSE_STMT -> ELSE { go_to_true_quad BLOCK } fill_go_to_true_quad .)


state 278

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } . end_for
    (70) end_for -> .

    FOR             reduce using rule 70 (end_for -> .)
    ID              reduce using rule 70 (end_for -> .)
    PRINT           reduce using rule 70 (end_for -> .)
    IF              reduce using rule 70 (end_for -> .)
    WHILE           reduce using rule 70 (end_for -> .)
    TRUE            reduce using rule 70 (end_for -> .)
    FALSE           reduce using rule 70 (end_for -> .)
    (               reduce using rule 70 (end_for -> .)
    *               reduce using rule 70 (end_for -> .)
    /               reduce using rule 70 (end_for -> .)
    I_CONST         reduce using rule 70 (end_for -> .)
    F_CONST         reduce using rule 70 (end_for -> .)
    C_CONST         reduce using rule 70 (end_for -> .)
    }               reduce using rule 70 (end_for -> .)
    RETURN          reduce using rule 70 (end_for -> .)

    end_for                        shift and go to state 279

state 279

    (72) FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .

    FOR             reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    ID              reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    PRINT           reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    IF              reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    WHILE           reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    TRUE            reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    FALSE           reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    (               reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    *               reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    /               reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    I_CONST         reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    F_CONST         reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    C_CONST         reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    }               reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)
    RETURN          reduce using rule 72 (FOR_STMT -> FOR ID get_variable check_exact_type_for TO ( EXPRESSION check_exact_type_for add_final_counter_for check_boolean_expression_for ) generate_for_quad DO { BLOCK } end_for .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for / in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 189 resolved as shift
WARNING: shift/reduce conflict for / in state 189 resolved as shift
WARNING: shift/reduce conflict for * in state 190 resolved as shift
WARNING: shift/reduce conflict for / in state 190 resolved as shift
WARNING: shift/reduce conflict for } in state 238 resolved as shift
