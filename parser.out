Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
Rule 2     add_id -> <empty>
Rule 3     add_type -> <empty>
Rule 4     save_id -> <empty>
Rule 5     VARS_PRIME -> VARS
Rule 6     VARS_PRIME -> empty
Rule 7     FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 8     FUNCTION_PRIME -> empty
Rule 9     FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 10    FUNC_PRIME -> empty
Rule 11    VARS -> VAR TIPO_COMP ID TIPO_PRIME ;
Rule 12    VARS -> VAR TIPO_SIMPLE ID ;
Rule 13    VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ;
Rule 14    TIPO_PRIME -> , ID TIPO_PRIME
Rule 15    TIPO_PRIME -> empty
Rule 16    VARIABLE -> ID
Rule 17    VARIABLE -> ID [ EXPRESSION ]
Rule 18    TIPO_SIMPLE -> INT
Rule 19    TIPO_SIMPLE -> FLOAT
Rule 20    TIPO_SIMPLE -> CHAR
Rule 21    TIPO_COMP -> DATAFRAME
Rule 22    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
Rule 23    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
Rule 24    FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
Rule 25    PARAM -> TIPO_SIMPLE ID PARAM_PRIME
Rule 26    PARAM -> empty
Rule 27    PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME
Rule 28    PARAM_PRIME -> empty
Rule 29    BLOCK -> STATEMENT BLOCK
Rule 30    BLOCK -> empty
Rule 31    STATEMENT -> ASSIGNATION
Rule 32    STATEMENT -> FUNC_CALL
Rule 33    STATEMENT -> WRITE
Rule 34    STATEMENT -> CONDITION
Rule 35    STATEMENT -> WHILE_STMT
Rule 36    STATEMENT -> FOR_STMT
Rule 37    STATEMENT -> DESCRIBE_STMT
Rule 38    ASSIGNATION -> VARIABLE = EXPRESSION
Rule 39    FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME )
Rule 40    FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME
Rule 41    FUNC_CALL_PRIME -> empty
Rule 42    WRITE -> PRINT ( EXPRESSION WRITE_PRIME )
Rule 43    WRITE -> PRINT ( TITLE WRITE_PRIME )
Rule 44    WRITE_PRIME -> , EXPRESSION WRITE_PRIME
Rule 45    WRITE_PRIME -> , TITLE WRITE_PRIME
Rule 46    WRITE_PRIME -> empty
Rule 47    CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT
Rule 48    ELSE_STMT -> ELSE { BLOCK }
Rule 49    ELSE_STMT -> empty
Rule 50    WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK }
Rule 51    FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
Rule 52    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 53    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 54    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 55    EXPRESSION_PRIME -> empty
Rule 56    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 57    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 58    AND_EXP_PRIME -> empty
Rule 59    B_EXP -> TRUE
Rule 60    B_EXP -> FALSE
Rule 61    B_EXP -> EXP B_EXP_PRIME
Rule 62    B_EXP_PRIME -> >
Rule 63    B_EXP_PRIME -> <
Rule 64    B_EXP_PRIME -> DIFFERENT
Rule 65    B_EXP_PRIME -> EQUAL
Rule 66    B_EXP_PRIME -> empty
Rule 67    EXP -> TERM EXP_PRIME
Rule 68    EXP_PRIME -> + TERM EXP_PRIME
Rule 69    EXP_PRIME -> - TERM EXP_PRIME
Rule 70    EXP_PRIME -> empty
Rule 71    TERM -> FACTOR TERM_PRIME
Rule 72    TERM_PRIME -> * FACTOR TERM_PRIME
Rule 73    TERM_PRIME -> / FACTOR TERM_PRIME
Rule 74    TERM_PRIME -> empty
Rule 75    FACTOR -> ( EXPRESSION )
Rule 76    FACTOR -> * VAR_CT
Rule 77    FACTOR -> / VAR_CT
Rule 78    FACTOR -> VAR_CT
Rule 79    VAR_CT -> ID
Rule 80    VAR_CT -> I_CONST
Rule 81    VAR_CT -> F_CONST
Rule 82    VAR_CT -> C_CONST
Rule 83    empty -> <empty>

Terminals, with rules where they appear

(                    : 22 23 24 39 42 43 47 50 52 75
)                    : 22 23 24 39 42 43 47 50 52 75
*                    : 72 76
+                    : 68
,                    : 14 27 44 45
-                    : 69
.                    : 52
/                    : 73 77
;                    : 1 11 12 13
<                    : 63
=                    : 38 51
>                    : 62
AND                  : 57
CHAR                 : 20
C_CONST              : 82
DATAFRAME            : 21
DESCRIBE             : 52
DIFFERENT            : 64
DO                   : 51
ELSE                 : 48
EQUAL                : 65
FALSE                : 60
FLOAT                : 19
FOR                  : 51
FUNC                 : 22 23 24
F_CONST              : 81
ID                   : 1 11 12 13 14 16 17 22 23 24 25 27 39 51 52 79
IF                   : 47
INT                  : 18
I_CONST              : 13 80
MAIN                 : 1
OR                   : 54
PRINT                : 42 43
PROG                 : 1
RETURN               : 22 23
TITLE                : 43 45
TO                   : 51
TRUE                 : 59
VAR                  : 11 12 13
VOID                 : 1 24
WHILE                : 50
[                    : 13 17
]                    : 13 17
error                : 
{                    : 1 22 23 24 47 48 50 51
}                    : 1 22 23 24 47 48 50 51

Nonterminals, with rules where they appear

AND_EXP              : 53 54
AND_EXP_PRIME        : 56 57
ASSIGNATION          : 31
BLOCK                : 1 22 23 24 29 47 48 50 51
B_EXP                : 56 57
B_EXP_PRIME          : 61
CONDITION            : 34
DESCRIBE_STMT        : 37
ELSE_STMT            : 47
EXP                  : 61
EXPRESSION           : 17 22 38 39 40 42 44 47 50 51 51 75
EXPRESSION_PRIME     : 53 54
EXP_PRIME            : 67 68 69
FACTOR               : 71 72 73
FOR_STMT             : 36
FUNCTION             : 7 9
FUNCTION_PRIME       : 1
FUNC_CALL            : 32
FUNC_CALL_PRIME      : 39 40
FUNC_PRIME           : 7 9
PARAM                : 22 23 24
PARAM_PRIME          : 25 27
PROGRAM              : 0
STATEMENT            : 29
TERM                 : 67 68 69
TERM_PRIME           : 71 72 73
TIPO_COMP            : 11
TIPO_PRIME           : 11 14
TIPO_SIMPLE          : 12 13 22 23 25 27
VARIABLE             : 38
VARS                 : 5
VARS_PRIME           : 1 1 22 23 24
VAR_CT               : 23 76 77 78
WHILE_STMT           : 35
WRITE                : 33
WRITE_PRIME          : 42 43 44 45
add_id               : 1
add_type             : 1
empty                : 6 8 10 15 26 28 30 41 46 49 55 58 66 70 74
save_id              : 1

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (3) add_type -> .

    ID              reduce using rule 3 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (2) add_id -> .

    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (4) save_id -> .

    VAR             reduce using rule 4 (save_id -> .)
    FUNC            reduce using rule 4 (save_id -> .)
    VOID            reduce using rule 4 (save_id -> .)

    save_id                        shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; save_id . VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (5) VARS_PRIME -> . VARS
    (6) VARS_PRIME -> . empty
    (11) VARS -> . VAR TIPO_COMP ID TIPO_PRIME ;
    (12) VARS -> . VAR TIPO_SIMPLE ID ;
    (13) VARS -> . VAR TIPO_SIMPLE ID [ I_CONST ] ;
    (83) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 83 (empty -> .)
    VOID            reduce using rule 83 (empty -> .)

    VARS_PRIME                     shift and go to state 8
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME . FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (7) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (8) FUNCTION_PRIME -> . empty
    (22) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (24) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (83) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 83 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 12
    FUNCTION                       shift and go to state 13
    empty                          shift and go to state 14

state 9

    (5) VARS_PRIME -> VARS .

    FUNC            reduce using rule 5 (VARS_PRIME -> VARS .)
    VOID            reduce using rule 5 (VARS_PRIME -> VARS .)
    ID              reduce using rule 5 (VARS_PRIME -> VARS .)
    PRINT           reduce using rule 5 (VARS_PRIME -> VARS .)
    IF              reduce using rule 5 (VARS_PRIME -> VARS .)
    WHILE           reduce using rule 5 (VARS_PRIME -> VARS .)
    FOR             reduce using rule 5 (VARS_PRIME -> VARS .)
    }               reduce using rule 5 (VARS_PRIME -> VARS .)
    RETURN          reduce using rule 5 (VARS_PRIME -> VARS .)


state 10

    (6) VARS_PRIME -> empty .

    FUNC            reduce using rule 6 (VARS_PRIME -> empty .)
    VOID            reduce using rule 6 (VARS_PRIME -> empty .)
    ID              reduce using rule 6 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 6 (VARS_PRIME -> empty .)
    IF              reduce using rule 6 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 6 (VARS_PRIME -> empty .)
    FOR             reduce using rule 6 (VARS_PRIME -> empty .)
    }               reduce using rule 6 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 6 (VARS_PRIME -> empty .)


state 11

    (11) VARS -> VAR . TIPO_COMP ID TIPO_PRIME ;
    (12) VARS -> VAR . TIPO_SIMPLE ID ;
    (13) VARS -> VAR . TIPO_SIMPLE ID [ I_CONST ] ;
    (21) TIPO_COMP -> . DATAFRAME
    (18) TIPO_SIMPLE -> . INT
    (19) TIPO_SIMPLE -> . FLOAT
    (20) TIPO_SIMPLE -> . CHAR

    DATAFRAME       shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    TIPO_COMP                      shift and go to state 16
    TIPO_SIMPLE                    shift and go to state 17

state 12

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME . VOID MAIN { VARS_PRIME BLOCK }

    VOID            shift and go to state 22


state 13

    (7) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (9) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (10) FUNC_PRIME -> . empty
    (22) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (24) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (83) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 83 (empty -> .)

    FUNCTION                       shift and go to state 23
    FUNC_PRIME                     shift and go to state 24
    empty                          shift and go to state 25

state 14

    (8) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 8 (FUNCTION_PRIME -> empty .)


state 15

    (22) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (24) FUNCTION -> FUNC . VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (18) TIPO_SIMPLE -> . INT
    (19) TIPO_SIMPLE -> . FLOAT
    (20) TIPO_SIMPLE -> . CHAR

    VOID            shift and go to state 27
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    TIPO_SIMPLE                    shift and go to state 26

state 16

    (11) VARS -> VAR TIPO_COMP . ID TIPO_PRIME ;

    ID              shift and go to state 28


state 17

    (12) VARS -> VAR TIPO_SIMPLE . ID ;
    (13) VARS -> VAR TIPO_SIMPLE . ID [ I_CONST ] ;

    ID              shift and go to state 29


state 18

    (21) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 21 (TIPO_COMP -> DATAFRAME .)


state 19

    (18) TIPO_SIMPLE -> INT .

    ID              reduce using rule 18 (TIPO_SIMPLE -> INT .)


state 20

    (19) TIPO_SIMPLE -> FLOAT .

    ID              reduce using rule 19 (TIPO_SIMPLE -> FLOAT .)


state 21

    (20) TIPO_SIMPLE -> CHAR .

    ID              reduce using rule 20 (TIPO_SIMPLE -> CHAR .)


state 22

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID . MAIN { VARS_PRIME BLOCK }

    MAIN            shift and go to state 30


state 23

    (9) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (9) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (10) FUNC_PRIME -> . empty
    (22) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (24) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (83) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 83 (empty -> .)

    FUNCTION                       shift and go to state 23
    FUNC_PRIME                     shift and go to state 31
    empty                          shift and go to state 25

state 24

    (7) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 7 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 25

    (10) FUNC_PRIME -> empty .

    VOID            reduce using rule 10 (FUNC_PRIME -> empty .)


state 26

    (22) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    ID              shift and go to state 32


state 27

    (24) FUNCTION -> FUNC VOID . ID ( PARAM ) { VARS_PRIME BLOCK }

    ID              shift and go to state 33


state 28

    (11) VARS -> VAR TIPO_COMP ID . TIPO_PRIME ;
    (14) TIPO_PRIME -> . , ID TIPO_PRIME
    (15) TIPO_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 35
    ;               reduce using rule 83 (empty -> .)

    TIPO_PRIME                     shift and go to state 34
    empty                          shift and go to state 36

state 29

    (12) VARS -> VAR TIPO_SIMPLE ID . ;
    (13) VARS -> VAR TIPO_SIMPLE ID . [ I_CONST ] ;

    ;               shift and go to state 37
    [               shift and go to state 38


state 30

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN . { VARS_PRIME BLOCK }

    {               shift and go to state 39


state 31

    (9) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 9 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 32

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    (               shift and go to state 40


state 33

    (24) FUNCTION -> FUNC VOID ID . ( PARAM ) { VARS_PRIME BLOCK }

    (               shift and go to state 41


state 34

    (11) VARS -> VAR TIPO_COMP ID TIPO_PRIME . ;

    ;               shift and go to state 42


state 35

    (14) TIPO_PRIME -> , . ID TIPO_PRIME

    ID              shift and go to state 43


state 36

    (15) TIPO_PRIME -> empty .

    ;               reduce using rule 15 (TIPO_PRIME -> empty .)


state 37

    (12) VARS -> VAR TIPO_SIMPLE ID ; .

    FUNC            reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    VOID            reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    ID              reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    PRINT           reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    IF              reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    WHILE           reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    FOR             reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    }               reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)
    RETURN          reduce using rule 12 (VARS -> VAR TIPO_SIMPLE ID ; .)


state 38

    (13) VARS -> VAR TIPO_SIMPLE ID [ . I_CONST ] ;

    I_CONST         shift and go to state 44


state 39

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { . VARS_PRIME BLOCK }
    (5) VARS_PRIME -> . VARS
    (6) VARS_PRIME -> . empty
    (11) VARS -> . VAR TIPO_COMP ID TIPO_PRIME ;
    (12) VARS -> . VAR TIPO_SIMPLE ID ;
    (13) VARS -> . VAR TIPO_SIMPLE ID [ I_CONST ] ;
    (83) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)

    VARS_PRIME                     shift and go to state 45
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 40

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (25) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (26) PARAM -> . empty
    (18) TIPO_SIMPLE -> . INT
    (19) TIPO_SIMPLE -> . FLOAT
    (20) TIPO_SIMPLE -> . CHAR
    (83) empty -> .

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    )               reduce using rule 83 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 46
    PARAM                          shift and go to state 47
    empty                          shift and go to state 48

state 41

    (24) FUNCTION -> FUNC VOID ID ( . PARAM ) { VARS_PRIME BLOCK }
    (25) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (26) PARAM -> . empty
    (18) TIPO_SIMPLE -> . INT
    (19) TIPO_SIMPLE -> . FLOAT
    (20) TIPO_SIMPLE -> . CHAR
    (83) empty -> .

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    )               reduce using rule 83 (empty -> .)

    PARAM                          shift and go to state 49
    TIPO_SIMPLE                    shift and go to state 46
    empty                          shift and go to state 48

state 42

    (11) VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .

    FUNC            reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    VOID            reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    ID              reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    PRINT           reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    IF              reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    WHILE           reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    FOR             reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    }               reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)
    RETURN          reduce using rule 11 (VARS -> VAR TIPO_COMP ID TIPO_PRIME ; .)


state 43

    (14) TIPO_PRIME -> , ID . TIPO_PRIME
    (14) TIPO_PRIME -> . , ID TIPO_PRIME
    (15) TIPO_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 35
    ;               reduce using rule 83 (empty -> .)

    TIPO_PRIME                     shift and go to state 50
    empty                          shift and go to state 36

state 44

    (13) VARS -> VAR TIPO_SIMPLE ID [ I_CONST . ] ;

    ]               shift and go to state 51


state 45

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME . BLOCK }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 53
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 46

    (25) PARAM -> TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 68


state 47

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN VAR_CT }

    )               shift and go to state 69


state 48

    (26) PARAM -> empty .

    )               reduce using rule 26 (PARAM -> empty .)


state 49

    (24) FUNCTION -> FUNC VOID ID ( PARAM . ) { VARS_PRIME BLOCK }

    )               shift and go to state 70


state 50

    (14) TIPO_PRIME -> , ID TIPO_PRIME .

    ;               reduce using rule 14 (TIPO_PRIME -> , ID TIPO_PRIME .)


state 51

    (13) VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] . ;

    ;               shift and go to state 71


state 52

    (39) FUNC_CALL -> ID . ( EXPRESSION FUNC_CALL_PRIME )
    (52) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (16) VARIABLE -> ID .
    (17) VARIABLE -> ID . [ EXPRESSION ]

    (               shift and go to state 72
    .               shift and go to state 73
    =               reduce using rule 16 (VARIABLE -> ID .)
    [               shift and go to state 74


state 53

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK . }

    }               shift and go to state 75


state 54

    (29) BLOCK -> STATEMENT . BLOCK
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    STATEMENT                      shift and go to state 54
    BLOCK                          shift and go to state 76
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 55

    (30) BLOCK -> empty .

    }               reduce using rule 30 (BLOCK -> empty .)
    RETURN          reduce using rule 30 (BLOCK -> empty .)


state 56

    (31) STATEMENT -> ASSIGNATION .

    ID              reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    FOR             reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 31 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 31 (STATEMENT -> ASSIGNATION .)


state 57

    (32) STATEMENT -> FUNC_CALL .

    ID              reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    FOR             reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 32 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 32 (STATEMENT -> FUNC_CALL .)


state 58

    (33) STATEMENT -> WRITE .

    ID              reduce using rule 33 (STATEMENT -> WRITE .)
    PRINT           reduce using rule 33 (STATEMENT -> WRITE .)
    IF              reduce using rule 33 (STATEMENT -> WRITE .)
    WHILE           reduce using rule 33 (STATEMENT -> WRITE .)
    FOR             reduce using rule 33 (STATEMENT -> WRITE .)
    }               reduce using rule 33 (STATEMENT -> WRITE .)
    RETURN          reduce using rule 33 (STATEMENT -> WRITE .)


state 59

    (34) STATEMENT -> CONDITION .

    ID              reduce using rule 34 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 34 (STATEMENT -> CONDITION .)
    IF              reduce using rule 34 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 34 (STATEMENT -> CONDITION .)
    FOR             reduce using rule 34 (STATEMENT -> CONDITION .)
    }               reduce using rule 34 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 34 (STATEMENT -> CONDITION .)


state 60

    (35) STATEMENT -> WHILE_STMT .

    ID              reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    FOR             reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 35 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 35 (STATEMENT -> WHILE_STMT .)


state 61

    (36) STATEMENT -> FOR_STMT .

    ID              reduce using rule 36 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 36 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 36 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 36 (STATEMENT -> FOR_STMT .)
    FOR             reduce using rule 36 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 36 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 36 (STATEMENT -> FOR_STMT .)


state 62

    (37) STATEMENT -> DESCRIBE_STMT .

    ID              reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    FOR             reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 37 (STATEMENT -> DESCRIBE_STMT .)


state 63

    (38) ASSIGNATION -> VARIABLE . = EXPRESSION

    =               shift and go to state 77


state 64

    (42) WRITE -> PRINT . ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> PRINT . ( TITLE WRITE_PRIME )

    (               shift and go to state 78


state 65

    (47) CONDITION -> IF . ( EXPRESSION ) { BLOCK } ELSE_STMT

    (               shift and go to state 79


state 66

    (50) WHILE_STMT -> WHILE . ( EXPRESSION ) { BLOCK }

    (               shift and go to state 80


state 67

    (51) FOR_STMT -> FOR . ID = EXPRESSION TO EXPRESSION DO { BLOCK }

    ID              shift and go to state 81


state 68

    (25) PARAM -> TIPO_SIMPLE ID . PARAM_PRIME
    (27) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (28) PARAM_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 83
    )               reduce using rule 83 (empty -> .)

    PARAM_PRIME                    shift and go to state 82
    empty                          shift and go to state 84

state 69

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN VAR_CT }

    {               shift and go to state 85


state 70

    (24) FUNCTION -> FUNC VOID ID ( PARAM ) . { VARS_PRIME BLOCK }

    {               shift and go to state 86


state 71

    (13) VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .

    FUNC            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    VOID            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    ID              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    PRINT           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    IF              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    WHILE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    FOR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    }               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)
    RETURN          reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID [ I_CONST ] ; .)


state 72

    (39) FUNC_CALL -> ID ( . EXPRESSION FUNC_CALL_PRIME )
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 89
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 73

    (52) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 103


state 74

    (17) VARIABLE -> ID [ . EXPRESSION ]
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 104
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 75

    (1) PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; save_id VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .)


state 76

    (29) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 29 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 29 (BLOCK -> STATEMENT BLOCK .)


state 77

    (38) ASSIGNATION -> VARIABLE = . EXPRESSION
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 105
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 78

    (42) WRITE -> PRINT ( . EXPRESSION WRITE_PRIME )
    (43) WRITE -> PRINT ( . TITLE WRITE_PRIME )
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TITLE           shift and go to state 107
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 106
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 79

    (47) CONDITION -> IF ( . EXPRESSION ) { BLOCK } ELSE_STMT
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 108
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 80

    (50) WHILE_STMT -> WHILE ( . EXPRESSION ) { BLOCK }
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 109
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 81

    (51) FOR_STMT -> FOR ID . = EXPRESSION TO EXPRESSION DO { BLOCK }

    =               shift and go to state 110


state 82

    (25) PARAM -> TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 25 (PARAM -> TIPO_SIMPLE ID PARAM_PRIME .)


state 83

    (27) PARAM_PRIME -> , . TIPO_SIMPLE ID PARAM_PRIME
    (18) TIPO_SIMPLE -> . INT
    (19) TIPO_SIMPLE -> . FLOAT
    (20) TIPO_SIMPLE -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    TIPO_SIMPLE                    shift and go to state 111

state 84

    (28) PARAM_PRIME -> empty .

    )               reduce using rule 28 (PARAM_PRIME -> empty .)


state 85

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN VAR_CT }
    (5) VARS_PRIME -> . VARS
    (6) VARS_PRIME -> . empty
    (11) VARS -> . VAR TIPO_COMP ID TIPO_PRIME ;
    (12) VARS -> . VAR TIPO_SIMPLE ID ;
    (13) VARS -> . VAR TIPO_SIMPLE ID [ I_CONST ] ;
    (83) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)

    VARS_PRIME                     shift and go to state 112
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 86

    (24) FUNCTION -> FUNC VOID ID ( PARAM ) { . VARS_PRIME BLOCK }
    (5) VARS_PRIME -> . VARS
    (6) VARS_PRIME -> . empty
    (11) VARS -> . VAR TIPO_COMP ID TIPO_PRIME ;
    (12) VARS -> . VAR TIPO_SIMPLE ID ;
    (13) VARS -> . VAR TIPO_SIMPLE ID [ I_CONST ] ;
    (83) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)

    VARS_PRIME                     shift and go to state 113
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 87

    (79) VAR_CT -> ID .

    *               reduce using rule 79 (VAR_CT -> ID .)
    /               reduce using rule 79 (VAR_CT -> ID .)
    +               reduce using rule 79 (VAR_CT -> ID .)
    -               reduce using rule 79 (VAR_CT -> ID .)
    >               reduce using rule 79 (VAR_CT -> ID .)
    <               reduce using rule 79 (VAR_CT -> ID .)
    DIFFERENT       reduce using rule 79 (VAR_CT -> ID .)
    EQUAL           reduce using rule 79 (VAR_CT -> ID .)
    AND             reduce using rule 79 (VAR_CT -> ID .)
    OR              reduce using rule 79 (VAR_CT -> ID .)
    TRUE            reduce using rule 79 (VAR_CT -> ID .)
    FALSE           reduce using rule 79 (VAR_CT -> ID .)
    (               reduce using rule 79 (VAR_CT -> ID .)
    ID              reduce using rule 79 (VAR_CT -> ID .)
    I_CONST         reduce using rule 79 (VAR_CT -> ID .)
    F_CONST         reduce using rule 79 (VAR_CT -> ID .)
    C_CONST         reduce using rule 79 (VAR_CT -> ID .)
    )               reduce using rule 79 (VAR_CT -> ID .)
    ]               reduce using rule 79 (VAR_CT -> ID .)
    PRINT           reduce using rule 79 (VAR_CT -> ID .)
    IF              reduce using rule 79 (VAR_CT -> ID .)
    WHILE           reduce using rule 79 (VAR_CT -> ID .)
    FOR             reduce using rule 79 (VAR_CT -> ID .)
    }               reduce using rule 79 (VAR_CT -> ID .)
    RETURN          reduce using rule 79 (VAR_CT -> ID .)
    ,               reduce using rule 79 (VAR_CT -> ID .)
    TO              reduce using rule 79 (VAR_CT -> ID .)
    DO              reduce using rule 79 (VAR_CT -> ID .)


state 88

    (75) FACTOR -> ( . EXPRESSION )
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 114
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 89

    (39) FUNC_CALL -> ID ( EXPRESSION . FUNC_CALL_PRIME )
    (40) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (41) FUNC_CALL_PRIME -> . empty
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (83) empty -> .
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    )               reduce using rule 83 (empty -> .)
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 115
    FUNC_CALL_PRIME                shift and go to state 116
    empty                          shift and go to state 117
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 90

    (53) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (54) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (55) EXPRESSION_PRIME -> . empty
    (83) empty -> .

    OR              shift and go to state 119
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 118
    empty                          shift and go to state 120

state 91

    (56) AND_EXP -> B_EXP . AND_EXP_PRIME
    (57) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (58) AND_EXP_PRIME -> . empty
    (83) empty -> .

    AND             shift and go to state 122
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 121
    empty                          shift and go to state 123

state 92

    (59) B_EXP -> TRUE .

    AND             reduce using rule 59 (B_EXP -> TRUE .)
    OR              reduce using rule 59 (B_EXP -> TRUE .)
    TRUE            reduce using rule 59 (B_EXP -> TRUE .)
    FALSE           reduce using rule 59 (B_EXP -> TRUE .)
    (               reduce using rule 59 (B_EXP -> TRUE .)
    *               reduce using rule 59 (B_EXP -> TRUE .)
    /               reduce using rule 59 (B_EXP -> TRUE .)
    ID              reduce using rule 59 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 59 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 59 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 59 (B_EXP -> TRUE .)
    )               reduce using rule 59 (B_EXP -> TRUE .)
    ]               reduce using rule 59 (B_EXP -> TRUE .)
    PRINT           reduce using rule 59 (B_EXP -> TRUE .)
    IF              reduce using rule 59 (B_EXP -> TRUE .)
    WHILE           reduce using rule 59 (B_EXP -> TRUE .)
    FOR             reduce using rule 59 (B_EXP -> TRUE .)
    }               reduce using rule 59 (B_EXP -> TRUE .)
    RETURN          reduce using rule 59 (B_EXP -> TRUE .)
    ,               reduce using rule 59 (B_EXP -> TRUE .)
    TO              reduce using rule 59 (B_EXP -> TRUE .)
    DO              reduce using rule 59 (B_EXP -> TRUE .)


state 93

    (60) B_EXP -> FALSE .

    AND             reduce using rule 60 (B_EXP -> FALSE .)
    OR              reduce using rule 60 (B_EXP -> FALSE .)
    TRUE            reduce using rule 60 (B_EXP -> FALSE .)
    FALSE           reduce using rule 60 (B_EXP -> FALSE .)
    (               reduce using rule 60 (B_EXP -> FALSE .)
    *               reduce using rule 60 (B_EXP -> FALSE .)
    /               reduce using rule 60 (B_EXP -> FALSE .)
    ID              reduce using rule 60 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 60 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 60 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 60 (B_EXP -> FALSE .)
    )               reduce using rule 60 (B_EXP -> FALSE .)
    ]               reduce using rule 60 (B_EXP -> FALSE .)
    PRINT           reduce using rule 60 (B_EXP -> FALSE .)
    IF              reduce using rule 60 (B_EXP -> FALSE .)
    WHILE           reduce using rule 60 (B_EXP -> FALSE .)
    FOR             reduce using rule 60 (B_EXP -> FALSE .)
    }               reduce using rule 60 (B_EXP -> FALSE .)
    RETURN          reduce using rule 60 (B_EXP -> FALSE .)
    ,               reduce using rule 60 (B_EXP -> FALSE .)
    TO              reduce using rule 60 (B_EXP -> FALSE .)
    DO              reduce using rule 60 (B_EXP -> FALSE .)


state 94

    (61) B_EXP -> EXP . B_EXP_PRIME
    (62) B_EXP_PRIME -> . >
    (63) B_EXP_PRIME -> . <
    (64) B_EXP_PRIME -> . DIFFERENT
    (65) B_EXP_PRIME -> . EQUAL
    (66) B_EXP_PRIME -> . empty
    (83) empty -> .

    >               shift and go to state 125
    <               shift and go to state 126
    DIFFERENT       shift and go to state 127
    EQUAL           shift and go to state 128
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    B_EXP_PRIME                    shift and go to state 124
    empty                          shift and go to state 129

state 95

    (67) EXP -> TERM . EXP_PRIME
    (68) EXP_PRIME -> . + TERM EXP_PRIME
    (69) EXP_PRIME -> . - TERM EXP_PRIME
    (70) EXP_PRIME -> . empty
    (83) empty -> .

    +               shift and go to state 131
    -               shift and go to state 132
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    EXP_PRIME                      shift and go to state 130
    empty                          shift and go to state 133

state 96

    (71) TERM -> FACTOR . TERM_PRIME
    (72) TERM_PRIME -> . * FACTOR TERM_PRIME
    (73) TERM_PRIME -> . / FACTOR TERM_PRIME
    (74) TERM_PRIME -> . empty
    (83) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 135
    /               shift and go to state 136
    +               reduce using rule 83 (empty -> .)
    -               reduce using rule 83 (empty -> .)
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

  ! *               [ reduce using rule 83 (empty -> .) ]
  ! /               [ reduce using rule 83 (empty -> .) ]

    TERM_PRIME                     shift and go to state 134
    empty                          shift and go to state 137

state 97

    (76) FACTOR -> * . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    VAR_CT                         shift and go to state 138

state 98

    (78) FACTOR -> VAR_CT .

    *               reduce using rule 78 (FACTOR -> VAR_CT .)
    /               reduce using rule 78 (FACTOR -> VAR_CT .)
    +               reduce using rule 78 (FACTOR -> VAR_CT .)
    -               reduce using rule 78 (FACTOR -> VAR_CT .)
    >               reduce using rule 78 (FACTOR -> VAR_CT .)
    <               reduce using rule 78 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 78 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 78 (FACTOR -> VAR_CT .)
    AND             reduce using rule 78 (FACTOR -> VAR_CT .)
    OR              reduce using rule 78 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 78 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 78 (FACTOR -> VAR_CT .)
    (               reduce using rule 78 (FACTOR -> VAR_CT .)
    ID              reduce using rule 78 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 78 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 78 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 78 (FACTOR -> VAR_CT .)
    )               reduce using rule 78 (FACTOR -> VAR_CT .)
    ]               reduce using rule 78 (FACTOR -> VAR_CT .)
    PRINT           reduce using rule 78 (FACTOR -> VAR_CT .)
    IF              reduce using rule 78 (FACTOR -> VAR_CT .)
    WHILE           reduce using rule 78 (FACTOR -> VAR_CT .)
    FOR             reduce using rule 78 (FACTOR -> VAR_CT .)
    }               reduce using rule 78 (FACTOR -> VAR_CT .)
    RETURN          reduce using rule 78 (FACTOR -> VAR_CT .)
    ,               reduce using rule 78 (FACTOR -> VAR_CT .)
    TO              reduce using rule 78 (FACTOR -> VAR_CT .)
    DO              reduce using rule 78 (FACTOR -> VAR_CT .)


state 99

    (77) FACTOR -> / . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    VAR_CT                         shift and go to state 139

state 100

    (80) VAR_CT -> I_CONST .

    *               reduce using rule 80 (VAR_CT -> I_CONST .)
    /               reduce using rule 80 (VAR_CT -> I_CONST .)
    +               reduce using rule 80 (VAR_CT -> I_CONST .)
    -               reduce using rule 80 (VAR_CT -> I_CONST .)
    >               reduce using rule 80 (VAR_CT -> I_CONST .)
    <               reduce using rule 80 (VAR_CT -> I_CONST .)
    DIFFERENT       reduce using rule 80 (VAR_CT -> I_CONST .)
    EQUAL           reduce using rule 80 (VAR_CT -> I_CONST .)
    AND             reduce using rule 80 (VAR_CT -> I_CONST .)
    OR              reduce using rule 80 (VAR_CT -> I_CONST .)
    TRUE            reduce using rule 80 (VAR_CT -> I_CONST .)
    FALSE           reduce using rule 80 (VAR_CT -> I_CONST .)
    (               reduce using rule 80 (VAR_CT -> I_CONST .)
    ID              reduce using rule 80 (VAR_CT -> I_CONST .)
    I_CONST         reduce using rule 80 (VAR_CT -> I_CONST .)
    F_CONST         reduce using rule 80 (VAR_CT -> I_CONST .)
    C_CONST         reduce using rule 80 (VAR_CT -> I_CONST .)
    )               reduce using rule 80 (VAR_CT -> I_CONST .)
    ]               reduce using rule 80 (VAR_CT -> I_CONST .)
    PRINT           reduce using rule 80 (VAR_CT -> I_CONST .)
    IF              reduce using rule 80 (VAR_CT -> I_CONST .)
    WHILE           reduce using rule 80 (VAR_CT -> I_CONST .)
    FOR             reduce using rule 80 (VAR_CT -> I_CONST .)
    }               reduce using rule 80 (VAR_CT -> I_CONST .)
    RETURN          reduce using rule 80 (VAR_CT -> I_CONST .)
    ,               reduce using rule 80 (VAR_CT -> I_CONST .)
    TO              reduce using rule 80 (VAR_CT -> I_CONST .)
    DO              reduce using rule 80 (VAR_CT -> I_CONST .)


state 101

    (81) VAR_CT -> F_CONST .

    *               reduce using rule 81 (VAR_CT -> F_CONST .)
    /               reduce using rule 81 (VAR_CT -> F_CONST .)
    +               reduce using rule 81 (VAR_CT -> F_CONST .)
    -               reduce using rule 81 (VAR_CT -> F_CONST .)
    >               reduce using rule 81 (VAR_CT -> F_CONST .)
    <               reduce using rule 81 (VAR_CT -> F_CONST .)
    DIFFERENT       reduce using rule 81 (VAR_CT -> F_CONST .)
    EQUAL           reduce using rule 81 (VAR_CT -> F_CONST .)
    AND             reduce using rule 81 (VAR_CT -> F_CONST .)
    OR              reduce using rule 81 (VAR_CT -> F_CONST .)
    TRUE            reduce using rule 81 (VAR_CT -> F_CONST .)
    FALSE           reduce using rule 81 (VAR_CT -> F_CONST .)
    (               reduce using rule 81 (VAR_CT -> F_CONST .)
    ID              reduce using rule 81 (VAR_CT -> F_CONST .)
    I_CONST         reduce using rule 81 (VAR_CT -> F_CONST .)
    F_CONST         reduce using rule 81 (VAR_CT -> F_CONST .)
    C_CONST         reduce using rule 81 (VAR_CT -> F_CONST .)
    )               reduce using rule 81 (VAR_CT -> F_CONST .)
    ]               reduce using rule 81 (VAR_CT -> F_CONST .)
    PRINT           reduce using rule 81 (VAR_CT -> F_CONST .)
    IF              reduce using rule 81 (VAR_CT -> F_CONST .)
    WHILE           reduce using rule 81 (VAR_CT -> F_CONST .)
    FOR             reduce using rule 81 (VAR_CT -> F_CONST .)
    }               reduce using rule 81 (VAR_CT -> F_CONST .)
    RETURN          reduce using rule 81 (VAR_CT -> F_CONST .)
    ,               reduce using rule 81 (VAR_CT -> F_CONST .)
    TO              reduce using rule 81 (VAR_CT -> F_CONST .)
    DO              reduce using rule 81 (VAR_CT -> F_CONST .)


state 102

    (82) VAR_CT -> C_CONST .

    *               reduce using rule 82 (VAR_CT -> C_CONST .)
    /               reduce using rule 82 (VAR_CT -> C_CONST .)
    +               reduce using rule 82 (VAR_CT -> C_CONST .)
    -               reduce using rule 82 (VAR_CT -> C_CONST .)
    >               reduce using rule 82 (VAR_CT -> C_CONST .)
    <               reduce using rule 82 (VAR_CT -> C_CONST .)
    DIFFERENT       reduce using rule 82 (VAR_CT -> C_CONST .)
    EQUAL           reduce using rule 82 (VAR_CT -> C_CONST .)
    AND             reduce using rule 82 (VAR_CT -> C_CONST .)
    OR              reduce using rule 82 (VAR_CT -> C_CONST .)
    TRUE            reduce using rule 82 (VAR_CT -> C_CONST .)
    FALSE           reduce using rule 82 (VAR_CT -> C_CONST .)
    (               reduce using rule 82 (VAR_CT -> C_CONST .)
    ID              reduce using rule 82 (VAR_CT -> C_CONST .)
    I_CONST         reduce using rule 82 (VAR_CT -> C_CONST .)
    F_CONST         reduce using rule 82 (VAR_CT -> C_CONST .)
    C_CONST         reduce using rule 82 (VAR_CT -> C_CONST .)
    )               reduce using rule 82 (VAR_CT -> C_CONST .)
    ]               reduce using rule 82 (VAR_CT -> C_CONST .)
    PRINT           reduce using rule 82 (VAR_CT -> C_CONST .)
    IF              reduce using rule 82 (VAR_CT -> C_CONST .)
    WHILE           reduce using rule 82 (VAR_CT -> C_CONST .)
    FOR             reduce using rule 82 (VAR_CT -> C_CONST .)
    }               reduce using rule 82 (VAR_CT -> C_CONST .)
    RETURN          reduce using rule 82 (VAR_CT -> C_CONST .)
    ,               reduce using rule 82 (VAR_CT -> C_CONST .)
    TO              reduce using rule 82 (VAR_CT -> C_CONST .)
    DO              reduce using rule 82 (VAR_CT -> C_CONST .)


state 103

    (52) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 140


state 104

    (17) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 141


state 105

    (38) ASSIGNATION -> VARIABLE = EXPRESSION .

    ID              reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    PRINT           reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    IF              reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    WHILE           reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    FOR             reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    }               reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)
    RETURN          reduce using rule 38 (ASSIGNATION -> VARIABLE = EXPRESSION .)


state 106

    (42) WRITE -> PRINT ( EXPRESSION . WRITE_PRIME )
    (44) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (45) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (46) WRITE_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 143
    )               reduce using rule 83 (empty -> .)

    WRITE_PRIME                    shift and go to state 142
    empty                          shift and go to state 144

state 107

    (43) WRITE -> PRINT ( TITLE . WRITE_PRIME )
    (44) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (45) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (46) WRITE_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 143
    )               reduce using rule 83 (empty -> .)

    WRITE_PRIME                    shift and go to state 145
    empty                          shift and go to state 144

state 108

    (47) CONDITION -> IF ( EXPRESSION . ) { BLOCK } ELSE_STMT

    )               shift and go to state 146


state 109

    (50) WHILE_STMT -> WHILE ( EXPRESSION . ) { BLOCK }

    )               shift and go to state 147


state 110

    (51) FOR_STMT -> FOR ID = . EXPRESSION TO EXPRESSION DO { BLOCK }
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 148
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 111

    (27) PARAM_PRIME -> , TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 149


state 112

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN VAR_CT }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    RETURN          reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 150
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 113

    (24) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME . BLOCK }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 151
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 114

    (75) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 152


state 115

    (40) FUNC_CALL_PRIME -> EXPRESSION . FUNC_CALL_PRIME
    (40) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (41) FUNC_CALL_PRIME -> . empty
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (83) empty -> .
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    )               reduce using rule 83 (empty -> .)
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 115
    FUNC_CALL_PRIME                shift and go to state 153
    empty                          shift and go to state 117
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 116

    (39) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME . )

    )               shift and go to state 154


state 117

    (41) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 41 (FUNC_CALL_PRIME -> empty .)


state 118

    (53) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    TRUE            reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ]               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 53 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 119

    (54) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    AND_EXP                        shift and go to state 155
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 120

    (55) EXPRESSION_PRIME -> empty .

    TRUE            reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    ]               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    PRINT           reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    IF              reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    WHILE           reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    FOR             reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    RETURN          reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 55 (EXPRESSION_PRIME -> empty .)
    DO              reduce using rule 55 (EXPRESSION_PRIME -> empty .)


state 121

    (56) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 56 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 122

    (57) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    B_EXP                          shift and go to state 156
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 123

    (58) AND_EXP_PRIME -> empty .

    OR              reduce using rule 58 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 58 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 58 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 58 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 58 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 58 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 58 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    PRINT           reduce using rule 58 (AND_EXP_PRIME -> empty .)
    IF              reduce using rule 58 (AND_EXP_PRIME -> empty .)
    WHILE           reduce using rule 58 (AND_EXP_PRIME -> empty .)
    FOR             reduce using rule 58 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    RETURN          reduce using rule 58 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 58 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 58 (AND_EXP_PRIME -> empty .)
    DO              reduce using rule 58 (AND_EXP_PRIME -> empty .)


state 124

    (61) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    PRINT           reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    IF              reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    WHILE           reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    FOR             reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    RETURN          reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)
    DO              reduce using rule 61 (B_EXP -> EXP B_EXP_PRIME .)


state 125

    (62) B_EXP_PRIME -> > .

    AND             reduce using rule 62 (B_EXP_PRIME -> > .)
    OR              reduce using rule 62 (B_EXP_PRIME -> > .)
    TRUE            reduce using rule 62 (B_EXP_PRIME -> > .)
    FALSE           reduce using rule 62 (B_EXP_PRIME -> > .)
    (               reduce using rule 62 (B_EXP_PRIME -> > .)
    *               reduce using rule 62 (B_EXP_PRIME -> > .)
    /               reduce using rule 62 (B_EXP_PRIME -> > .)
    ID              reduce using rule 62 (B_EXP_PRIME -> > .)
    I_CONST         reduce using rule 62 (B_EXP_PRIME -> > .)
    F_CONST         reduce using rule 62 (B_EXP_PRIME -> > .)
    C_CONST         reduce using rule 62 (B_EXP_PRIME -> > .)
    )               reduce using rule 62 (B_EXP_PRIME -> > .)
    ]               reduce using rule 62 (B_EXP_PRIME -> > .)
    PRINT           reduce using rule 62 (B_EXP_PRIME -> > .)
    IF              reduce using rule 62 (B_EXP_PRIME -> > .)
    WHILE           reduce using rule 62 (B_EXP_PRIME -> > .)
    FOR             reduce using rule 62 (B_EXP_PRIME -> > .)
    }               reduce using rule 62 (B_EXP_PRIME -> > .)
    RETURN          reduce using rule 62 (B_EXP_PRIME -> > .)
    ,               reduce using rule 62 (B_EXP_PRIME -> > .)
    TO              reduce using rule 62 (B_EXP_PRIME -> > .)
    DO              reduce using rule 62 (B_EXP_PRIME -> > .)


state 126

    (63) B_EXP_PRIME -> < .

    AND             reduce using rule 63 (B_EXP_PRIME -> < .)
    OR              reduce using rule 63 (B_EXP_PRIME -> < .)
    TRUE            reduce using rule 63 (B_EXP_PRIME -> < .)
    FALSE           reduce using rule 63 (B_EXP_PRIME -> < .)
    (               reduce using rule 63 (B_EXP_PRIME -> < .)
    *               reduce using rule 63 (B_EXP_PRIME -> < .)
    /               reduce using rule 63 (B_EXP_PRIME -> < .)
    ID              reduce using rule 63 (B_EXP_PRIME -> < .)
    I_CONST         reduce using rule 63 (B_EXP_PRIME -> < .)
    F_CONST         reduce using rule 63 (B_EXP_PRIME -> < .)
    C_CONST         reduce using rule 63 (B_EXP_PRIME -> < .)
    )               reduce using rule 63 (B_EXP_PRIME -> < .)
    ]               reduce using rule 63 (B_EXP_PRIME -> < .)
    PRINT           reduce using rule 63 (B_EXP_PRIME -> < .)
    IF              reduce using rule 63 (B_EXP_PRIME -> < .)
    WHILE           reduce using rule 63 (B_EXP_PRIME -> < .)
    FOR             reduce using rule 63 (B_EXP_PRIME -> < .)
    }               reduce using rule 63 (B_EXP_PRIME -> < .)
    RETURN          reduce using rule 63 (B_EXP_PRIME -> < .)
    ,               reduce using rule 63 (B_EXP_PRIME -> < .)
    TO              reduce using rule 63 (B_EXP_PRIME -> < .)
    DO              reduce using rule 63 (B_EXP_PRIME -> < .)


state 127

    (64) B_EXP_PRIME -> DIFFERENT .

    AND             reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    OR              reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    TRUE            reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    FALSE           reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    (               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    *               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    /               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    ID              reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    I_CONST         reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    F_CONST         reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    C_CONST         reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    )               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    ]               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    PRINT           reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    IF              reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    WHILE           reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    FOR             reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    }               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    RETURN          reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    ,               reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    TO              reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)
    DO              reduce using rule 64 (B_EXP_PRIME -> DIFFERENT .)


state 128

    (65) B_EXP_PRIME -> EQUAL .

    AND             reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    OR              reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    TRUE            reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    FALSE           reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    (               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    *               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    /               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    ID              reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    I_CONST         reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    F_CONST         reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    C_CONST         reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    )               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    ]               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    PRINT           reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    IF              reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    WHILE           reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    FOR             reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    }               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    RETURN          reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    ,               reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    TO              reduce using rule 65 (B_EXP_PRIME -> EQUAL .)
    DO              reduce using rule 65 (B_EXP_PRIME -> EQUAL .)


state 129

    (66) B_EXP_PRIME -> empty .

    AND             reduce using rule 66 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 66 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 66 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 66 (B_EXP_PRIME -> empty .)
    (               reduce using rule 66 (B_EXP_PRIME -> empty .)
    *               reduce using rule 66 (B_EXP_PRIME -> empty .)
    /               reduce using rule 66 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 66 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 66 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 66 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 66 (B_EXP_PRIME -> empty .)
    )               reduce using rule 66 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 66 (B_EXP_PRIME -> empty .)
    PRINT           reduce using rule 66 (B_EXP_PRIME -> empty .)
    IF              reduce using rule 66 (B_EXP_PRIME -> empty .)
    WHILE           reduce using rule 66 (B_EXP_PRIME -> empty .)
    FOR             reduce using rule 66 (B_EXP_PRIME -> empty .)
    }               reduce using rule 66 (B_EXP_PRIME -> empty .)
    RETURN          reduce using rule 66 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 66 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 66 (B_EXP_PRIME -> empty .)
    DO              reduce using rule 66 (B_EXP_PRIME -> empty .)


state 130

    (67) EXP -> TERM EXP_PRIME .

    >               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    PRINT           reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    IF              reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    WHILE           reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    FOR             reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    RETURN          reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 67 (EXP -> TERM EXP_PRIME .)
    DO              reduce using rule 67 (EXP -> TERM EXP_PRIME .)


state 131

    (68) EXP_PRIME -> + . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    TERM                           shift and go to state 157
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 132

    (69) EXP_PRIME -> - . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    TERM                           shift and go to state 158
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 133

    (70) EXP_PRIME -> empty .

    >               reduce using rule 70 (EXP_PRIME -> empty .)
    <               reduce using rule 70 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 70 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 70 (EXP_PRIME -> empty .)
    AND             reduce using rule 70 (EXP_PRIME -> empty .)
    OR              reduce using rule 70 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 70 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 70 (EXP_PRIME -> empty .)
    (               reduce using rule 70 (EXP_PRIME -> empty .)
    *               reduce using rule 70 (EXP_PRIME -> empty .)
    /               reduce using rule 70 (EXP_PRIME -> empty .)
    ID              reduce using rule 70 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 70 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 70 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 70 (EXP_PRIME -> empty .)
    )               reduce using rule 70 (EXP_PRIME -> empty .)
    ]               reduce using rule 70 (EXP_PRIME -> empty .)
    PRINT           reduce using rule 70 (EXP_PRIME -> empty .)
    IF              reduce using rule 70 (EXP_PRIME -> empty .)
    WHILE           reduce using rule 70 (EXP_PRIME -> empty .)
    FOR             reduce using rule 70 (EXP_PRIME -> empty .)
    }               reduce using rule 70 (EXP_PRIME -> empty .)
    RETURN          reduce using rule 70 (EXP_PRIME -> empty .)
    ,               reduce using rule 70 (EXP_PRIME -> empty .)
    TO              reduce using rule 70 (EXP_PRIME -> empty .)
    DO              reduce using rule 70 (EXP_PRIME -> empty .)


state 134

    (71) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    PRINT           reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    IF              reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    WHILE           reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    FOR             reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    RETURN          reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)
    DO              reduce using rule 71 (TERM -> FACTOR TERM_PRIME .)


state 135

    (72) TERM_PRIME -> * . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    FACTOR                         shift and go to state 159
    VAR_CT                         shift and go to state 98

state 136

    (73) TERM_PRIME -> / . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    FACTOR                         shift and go to state 160
    VAR_CT                         shift and go to state 98

state 137

    (74) TERM_PRIME -> empty .

    +               reduce using rule 74 (TERM_PRIME -> empty .)
    -               reduce using rule 74 (TERM_PRIME -> empty .)
    >               reduce using rule 74 (TERM_PRIME -> empty .)
    <               reduce using rule 74 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 74 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 74 (TERM_PRIME -> empty .)
    AND             reduce using rule 74 (TERM_PRIME -> empty .)
    OR              reduce using rule 74 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 74 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 74 (TERM_PRIME -> empty .)
    (               reduce using rule 74 (TERM_PRIME -> empty .)
    *               reduce using rule 74 (TERM_PRIME -> empty .)
    /               reduce using rule 74 (TERM_PRIME -> empty .)
    ID              reduce using rule 74 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 74 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 74 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 74 (TERM_PRIME -> empty .)
    )               reduce using rule 74 (TERM_PRIME -> empty .)
    ]               reduce using rule 74 (TERM_PRIME -> empty .)
    PRINT           reduce using rule 74 (TERM_PRIME -> empty .)
    IF              reduce using rule 74 (TERM_PRIME -> empty .)
    WHILE           reduce using rule 74 (TERM_PRIME -> empty .)
    FOR             reduce using rule 74 (TERM_PRIME -> empty .)
    }               reduce using rule 74 (TERM_PRIME -> empty .)
    RETURN          reduce using rule 74 (TERM_PRIME -> empty .)
    ,               reduce using rule 74 (TERM_PRIME -> empty .)
    TO              reduce using rule 74 (TERM_PRIME -> empty .)
    DO              reduce using rule 74 (TERM_PRIME -> empty .)


state 138

    (76) FACTOR -> * VAR_CT .

    *               reduce using rule 76 (FACTOR -> * VAR_CT .)
    /               reduce using rule 76 (FACTOR -> * VAR_CT .)
    +               reduce using rule 76 (FACTOR -> * VAR_CT .)
    -               reduce using rule 76 (FACTOR -> * VAR_CT .)
    >               reduce using rule 76 (FACTOR -> * VAR_CT .)
    <               reduce using rule 76 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 76 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 76 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 76 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 76 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 76 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 76 (FACTOR -> * VAR_CT .)
    (               reduce using rule 76 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 76 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 76 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 76 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 76 (FACTOR -> * VAR_CT .)
    )               reduce using rule 76 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 76 (FACTOR -> * VAR_CT .)
    PRINT           reduce using rule 76 (FACTOR -> * VAR_CT .)
    IF              reduce using rule 76 (FACTOR -> * VAR_CT .)
    WHILE           reduce using rule 76 (FACTOR -> * VAR_CT .)
    FOR             reduce using rule 76 (FACTOR -> * VAR_CT .)
    }               reduce using rule 76 (FACTOR -> * VAR_CT .)
    RETURN          reduce using rule 76 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 76 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 76 (FACTOR -> * VAR_CT .)
    DO              reduce using rule 76 (FACTOR -> * VAR_CT .)


state 139

    (77) FACTOR -> / VAR_CT .

    *               reduce using rule 77 (FACTOR -> / VAR_CT .)
    /               reduce using rule 77 (FACTOR -> / VAR_CT .)
    +               reduce using rule 77 (FACTOR -> / VAR_CT .)
    -               reduce using rule 77 (FACTOR -> / VAR_CT .)
    >               reduce using rule 77 (FACTOR -> / VAR_CT .)
    <               reduce using rule 77 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 77 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 77 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 77 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 77 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 77 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 77 (FACTOR -> / VAR_CT .)
    (               reduce using rule 77 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 77 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 77 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 77 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 77 (FACTOR -> / VAR_CT .)
    )               reduce using rule 77 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 77 (FACTOR -> / VAR_CT .)
    PRINT           reduce using rule 77 (FACTOR -> / VAR_CT .)
    IF              reduce using rule 77 (FACTOR -> / VAR_CT .)
    WHILE           reduce using rule 77 (FACTOR -> / VAR_CT .)
    FOR             reduce using rule 77 (FACTOR -> / VAR_CT .)
    }               reduce using rule 77 (FACTOR -> / VAR_CT .)
    RETURN          reduce using rule 77 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 77 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 77 (FACTOR -> / VAR_CT .)
    DO              reduce using rule 77 (FACTOR -> / VAR_CT .)


state 140

    (52) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 161


state 141

    (17) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 17 (VARIABLE -> ID [ EXPRESSION ] .)


state 142

    (42) WRITE -> PRINT ( EXPRESSION WRITE_PRIME . )

    )               shift and go to state 162


state 143

    (44) WRITE_PRIME -> , . EXPRESSION WRITE_PRIME
    (45) WRITE_PRIME -> , . TITLE WRITE_PRIME
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TITLE           shift and go to state 164
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 163
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 144

    (46) WRITE_PRIME -> empty .

    )               reduce using rule 46 (WRITE_PRIME -> empty .)


state 145

    (43) WRITE -> PRINT ( TITLE WRITE_PRIME . )

    )               shift and go to state 165


state 146

    (47) CONDITION -> IF ( EXPRESSION ) . { BLOCK } ELSE_STMT

    {               shift and go to state 166


state 147

    (50) WHILE_STMT -> WHILE ( EXPRESSION ) . { BLOCK }

    {               shift and go to state 167


state 148

    (51) FOR_STMT -> FOR ID = EXPRESSION . TO EXPRESSION DO { BLOCK }

    TO              shift and go to state 168


state 149

    (27) PARAM_PRIME -> , TIPO_SIMPLE ID . PARAM_PRIME
    (27) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (28) PARAM_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 83
    )               reduce using rule 83 (empty -> .)

    PARAM_PRIME                    shift and go to state 169
    empty                          shift and go to state 84

state 150

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN VAR_CT }

    RETURN          shift and go to state 170


state 151

    (24) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK . }

    }               shift and go to state 171


state 152

    (75) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    PRINT           reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    IF              reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    WHILE           reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    FOR             reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    RETURN          reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)
    DO              reduce using rule 75 (FACTOR -> ( EXPRESSION ) .)


state 153

    (40) FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .

    )               reduce using rule 40 (FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .)


state 154

    (39) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .

    ID              reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    PRINT           reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    IF              reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    WHILE           reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FOR             reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    }               reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    RETURN          reduce using rule 39 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)


state 155

    (54) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (54) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (55) EXPRESSION_PRIME -> . empty
    (83) empty -> .

    OR              shift and go to state 119
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 172
    empty                          shift and go to state 120

state 156

    (57) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (57) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (58) AND_EXP_PRIME -> . empty
    (83) empty -> .

    AND             shift and go to state 122
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 173
    empty                          shift and go to state 123

state 157

    (68) EXP_PRIME -> + TERM . EXP_PRIME
    (68) EXP_PRIME -> . + TERM EXP_PRIME
    (69) EXP_PRIME -> . - TERM EXP_PRIME
    (70) EXP_PRIME -> . empty
    (83) empty -> .

    +               shift and go to state 131
    -               shift and go to state 132
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    EXP_PRIME                      shift and go to state 174
    empty                          shift and go to state 133

state 158

    (69) EXP_PRIME -> - TERM . EXP_PRIME
    (68) EXP_PRIME -> . + TERM EXP_PRIME
    (69) EXP_PRIME -> . - TERM EXP_PRIME
    (70) EXP_PRIME -> . empty
    (83) empty -> .

    +               shift and go to state 131
    -               shift and go to state 132
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    *               reduce using rule 83 (empty -> .)
    /               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

    EXP_PRIME                      shift and go to state 175
    empty                          shift and go to state 133

state 159

    (72) TERM_PRIME -> * FACTOR . TERM_PRIME
    (72) TERM_PRIME -> . * FACTOR TERM_PRIME
    (73) TERM_PRIME -> . / FACTOR TERM_PRIME
    (74) TERM_PRIME -> . empty
    (83) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 135
    /               shift and go to state 136
    +               reduce using rule 83 (empty -> .)
    -               reduce using rule 83 (empty -> .)
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

  ! *               [ reduce using rule 83 (empty -> .) ]
  ! /               [ reduce using rule 83 (empty -> .) ]

    TERM_PRIME                     shift and go to state 176
    empty                          shift and go to state 137

state 160

    (73) TERM_PRIME -> / FACTOR . TERM_PRIME
    (72) TERM_PRIME -> . * FACTOR TERM_PRIME
    (73) TERM_PRIME -> . / FACTOR TERM_PRIME
    (74) TERM_PRIME -> . empty
    (83) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 135
    /               shift and go to state 136
    +               reduce using rule 83 (empty -> .)
    -               reduce using rule 83 (empty -> .)
    >               reduce using rule 83 (empty -> .)
    <               reduce using rule 83 (empty -> .)
    DIFFERENT       reduce using rule 83 (empty -> .)
    EQUAL           reduce using rule 83 (empty -> .)
    AND             reduce using rule 83 (empty -> .)
    OR              reduce using rule 83 (empty -> .)
    TRUE            reduce using rule 83 (empty -> .)
    FALSE           reduce using rule 83 (empty -> .)
    (               reduce using rule 83 (empty -> .)
    ID              reduce using rule 83 (empty -> .)
    I_CONST         reduce using rule 83 (empty -> .)
    F_CONST         reduce using rule 83 (empty -> .)
    C_CONST         reduce using rule 83 (empty -> .)
    )               reduce using rule 83 (empty -> .)
    ]               reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)
    ,               reduce using rule 83 (empty -> .)
    TO              reduce using rule 83 (empty -> .)
    DO              reduce using rule 83 (empty -> .)

  ! *               [ reduce using rule 83 (empty -> .) ]
  ! /               [ reduce using rule 83 (empty -> .) ]

    TERM_PRIME                     shift and go to state 177
    empty                          shift and go to state 137

state 161

    (52) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    ID              reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FOR             reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 52 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 162

    (42) WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .

    ID              reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    PRINT           reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    IF              reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    WHILE           reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    FOR             reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    }               reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)
    RETURN          reduce using rule 42 (WRITE -> PRINT ( EXPRESSION WRITE_PRIME ) .)


state 163

    (44) WRITE_PRIME -> , EXPRESSION . WRITE_PRIME
    (44) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (45) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (46) WRITE_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 143
    )               reduce using rule 83 (empty -> .)

    WRITE_PRIME                    shift and go to state 178
    empty                          shift and go to state 144

state 164

    (45) WRITE_PRIME -> , TITLE . WRITE_PRIME
    (44) WRITE_PRIME -> . , EXPRESSION WRITE_PRIME
    (45) WRITE_PRIME -> . , TITLE WRITE_PRIME
    (46) WRITE_PRIME -> . empty
    (83) empty -> .

    ,               shift and go to state 143
    )               reduce using rule 83 (empty -> .)

    WRITE_PRIME                    shift and go to state 179
    empty                          shift and go to state 144

state 165

    (43) WRITE -> PRINT ( TITLE WRITE_PRIME ) .

    ID              reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    PRINT           reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    IF              reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    WHILE           reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    FOR             reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    }               reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)
    RETURN          reduce using rule 43 (WRITE -> PRINT ( TITLE WRITE_PRIME ) .)


state 166

    (47) CONDITION -> IF ( EXPRESSION ) { . BLOCK } ELSE_STMT
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 180
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 167

    (50) WHILE_STMT -> WHILE ( EXPRESSION ) { . BLOCK }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 181
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 168

    (51) FOR_STMT -> FOR ID = EXPRESSION TO . EXPRESSION DO { BLOCK }
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST

    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99
    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102

    EXPRESSION                     shift and go to state 182
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96
    VAR_CT                         shift and go to state 98

state 169

    (27) PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 27 (PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .)


state 170

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . EXPRESSION }
    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . VAR_CT }
    (53) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (79) VAR_CT -> . ID
    (80) VAR_CT -> . I_CONST
    (81) VAR_CT -> . F_CONST
    (82) VAR_CT -> . C_CONST
    (56) AND_EXP -> . B_EXP AND_EXP_PRIME
    (59) B_EXP -> . TRUE
    (60) B_EXP -> . FALSE
    (61) B_EXP -> . EXP B_EXP_PRIME
    (67) EXP -> . TERM EXP_PRIME
    (71) TERM -> . FACTOR TERM_PRIME
    (75) FACTOR -> . ( EXPRESSION )
    (76) FACTOR -> . * VAR_CT
    (77) FACTOR -> . / VAR_CT
    (78) FACTOR -> . VAR_CT

    ID              shift and go to state 87
    I_CONST         shift and go to state 100
    F_CONST         shift and go to state 101
    C_CONST         shift and go to state 102
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    (               shift and go to state 88
    *               shift and go to state 97
    /               shift and go to state 99

    EXPRESSION                     shift and go to state 183
    VAR_CT                         shift and go to state 184
    AND_EXP                        shift and go to state 90
    B_EXP                          shift and go to state 91
    EXP                            shift and go to state 94
    TERM                           shift and go to state 95
    FACTOR                         shift and go to state 96

state 171

    (24) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .

    FUNC            reduce using rule 24 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)
    VOID            reduce using rule 24 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)


state 172

    (54) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    TRUE            reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ]               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    PRINT           reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    IF              reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    WHILE           reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FOR             reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    RETURN          reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 54 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 173

    (57) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    PRINT           reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    IF              reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    WHILE           reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FOR             reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    RETURN          reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 57 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 174

    (68) EXP_PRIME -> + TERM EXP_PRIME .

    >               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    <               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    EQUAL           reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    AND             reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    OR              reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    TRUE            reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    FALSE           reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    (               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    *               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    /               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    ID              reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    I_CONST         reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    F_CONST         reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    C_CONST         reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    )               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    ]               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    PRINT           reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    IF              reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    WHILE           reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    FOR             reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    }               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    RETURN          reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    ,               reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    TO              reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)
    DO              reduce using rule 68 (EXP_PRIME -> + TERM EXP_PRIME .)


state 175

    (69) EXP_PRIME -> - TERM EXP_PRIME .

    >               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    <               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    EQUAL           reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    AND             reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    OR              reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    TRUE            reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    FALSE           reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    (               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    *               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    /               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    ID              reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    I_CONST         reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    F_CONST         reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    C_CONST         reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    )               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    ]               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    PRINT           reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    IF              reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    WHILE           reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    FOR             reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    }               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    RETURN          reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    ,               reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    TO              reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)
    DO              reduce using rule 69 (EXP_PRIME -> - TERM EXP_PRIME .)


state 176

    (72) TERM_PRIME -> * FACTOR TERM_PRIME .

    +               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    -               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    >               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    <               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    AND             reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    OR              reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    TRUE            reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    FALSE           reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    (               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    *               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    /               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ID              reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    )               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ]               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    PRINT           reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    IF              reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    WHILE           reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    FOR             reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    }               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    RETURN          reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    ,               reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    TO              reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)
    DO              reduce using rule 72 (TERM_PRIME -> * FACTOR TERM_PRIME .)


state 177

    (73) TERM_PRIME -> / FACTOR TERM_PRIME .

    +               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    -               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    >               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    <               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    AND             reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    OR              reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    TRUE            reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    FALSE           reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    (               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    *               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    /               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ID              reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    )               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ]               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    PRINT           reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    IF              reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    WHILE           reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    FOR             reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    }               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    RETURN          reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    ,               reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    TO              reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)
    DO              reduce using rule 73 (TERM_PRIME -> / FACTOR TERM_PRIME .)


state 178

    (44) WRITE_PRIME -> , EXPRESSION WRITE_PRIME .

    )               reduce using rule 44 (WRITE_PRIME -> , EXPRESSION WRITE_PRIME .)


state 179

    (45) WRITE_PRIME -> , TITLE WRITE_PRIME .

    )               reduce using rule 45 (WRITE_PRIME -> , TITLE WRITE_PRIME .)


state 180

    (47) CONDITION -> IF ( EXPRESSION ) { BLOCK . } ELSE_STMT

    }               shift and go to state 185


state 181

    (50) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK . }

    }               shift and go to state 186


state 182

    (51) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION . DO { BLOCK }

    DO              shift and go to state 187


state 183

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION . }

    }               shift and go to state 188


state 184

    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT . }
    (78) FACTOR -> VAR_CT .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 189
    *               reduce using rule 78 (FACTOR -> VAR_CT .)
    /               reduce using rule 78 (FACTOR -> VAR_CT .)
    +               reduce using rule 78 (FACTOR -> VAR_CT .)
    -               reduce using rule 78 (FACTOR -> VAR_CT .)
    >               reduce using rule 78 (FACTOR -> VAR_CT .)
    <               reduce using rule 78 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 78 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 78 (FACTOR -> VAR_CT .)
    AND             reduce using rule 78 (FACTOR -> VAR_CT .)
    OR              reduce using rule 78 (FACTOR -> VAR_CT .)

  ! }               [ reduce using rule 78 (FACTOR -> VAR_CT .) ]


state 185

    (47) CONDITION -> IF ( EXPRESSION ) { BLOCK } . ELSE_STMT
    (48) ELSE_STMT -> . ELSE { BLOCK }
    (49) ELSE_STMT -> . empty
    (83) empty -> .

    ELSE            shift and go to state 191
    ID              reduce using rule 83 (empty -> .)
    PRINT           reduce using rule 83 (empty -> .)
    IF              reduce using rule 83 (empty -> .)
    WHILE           reduce using rule 83 (empty -> .)
    FOR             reduce using rule 83 (empty -> .)
    }               reduce using rule 83 (empty -> .)
    RETURN          reduce using rule 83 (empty -> .)

    ELSE_STMT                      shift and go to state 190
    empty                          shift and go to state 192

state 186

    (50) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .

    ID              reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    PRINT           reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    IF              reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    WHILE           reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    FOR             reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    }               reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    RETURN          reduce using rule 50 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)


state 187

    (51) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO . { BLOCK }

    {               shift and go to state 193


state 188

    (22) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .

    FUNC            reduce using rule 22 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)
    VOID            reduce using rule 22 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)


state 189

    (23) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .

    FUNC            reduce using rule 23 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)
    VOID            reduce using rule 23 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)


state 190

    (47) CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .

    ID              reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    PRINT           reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    IF              reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    WHILE           reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    FOR             reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    }               reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    RETURN          reduce using rule 47 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)


state 191

    (48) ELSE_STMT -> ELSE . { BLOCK }

    {               shift and go to state 194


state 192

    (49) ELSE_STMT -> empty .

    ID              reduce using rule 49 (ELSE_STMT -> empty .)
    PRINT           reduce using rule 49 (ELSE_STMT -> empty .)
    IF              reduce using rule 49 (ELSE_STMT -> empty .)
    WHILE           reduce using rule 49 (ELSE_STMT -> empty .)
    FOR             reduce using rule 49 (ELSE_STMT -> empty .)
    }               reduce using rule 49 (ELSE_STMT -> empty .)
    RETURN          reduce using rule 49 (ELSE_STMT -> empty .)


state 193

    (51) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { . BLOCK }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 195
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 194

    (48) ELSE_STMT -> ELSE { . BLOCK }
    (29) BLOCK -> . STATEMENT BLOCK
    (30) BLOCK -> . empty
    (31) STATEMENT -> . ASSIGNATION
    (32) STATEMENT -> . FUNC_CALL
    (33) STATEMENT -> . WRITE
    (34) STATEMENT -> . CONDITION
    (35) STATEMENT -> . WHILE_STMT
    (36) STATEMENT -> . FOR_STMT
    (37) STATEMENT -> . DESCRIBE_STMT
    (83) empty -> .
    (38) ASSIGNATION -> . VARIABLE = EXPRESSION
    (39) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (42) WRITE -> . PRINT ( EXPRESSION WRITE_PRIME )
    (43) WRITE -> . PRINT ( TITLE WRITE_PRIME )
    (47) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (50) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (51) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (52) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (16) VARIABLE -> . ID
    (17) VARIABLE -> . ID [ EXPRESSION ]

    }               reduce using rule 83 (empty -> .)
    ID              shift and go to state 52
    PRINT           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67

    BLOCK                          shift and go to state 196
    STATEMENT                      shift and go to state 54
    empty                          shift and go to state 55
    ASSIGNATION                    shift and go to state 56
    FUNC_CALL                      shift and go to state 57
    WRITE                          shift and go to state 58
    CONDITION                      shift and go to state 59
    WHILE_STMT                     shift and go to state 60
    FOR_STMT                       shift and go to state 61
    DESCRIBE_STMT                  shift and go to state 62
    VARIABLE                       shift and go to state 63

state 195

    (51) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK . }

    }               shift and go to state 197


state 196

    (48) ELSE_STMT -> ELSE { BLOCK . }

    }               shift and go to state 198


state 197

    (51) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .

    ID              reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    PRINT           reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    IF              reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    WHILE           reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    FOR             reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    }               reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    RETURN          reduce using rule 51 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)


state 198

    (48) ELSE_STMT -> ELSE { BLOCK } .

    ID              reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    PRINT           reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    IF              reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    WHILE           reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    FOR             reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    }               reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)
    RETURN          reduce using rule 48 (ELSE_STMT -> ELSE { BLOCK } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 96 resolved as shift
WARNING: shift/reduce conflict for / in state 96 resolved as shift
WARNING: shift/reduce conflict for * in state 159 resolved as shift
WARNING: shift/reduce conflict for / in state 159 resolved as shift
WARNING: shift/reduce conflict for * in state 160 resolved as shift
WARNING: shift/reduce conflict for / in state 160 resolved as shift
WARNING: shift/reduce conflict for } in state 184 resolved as shift
