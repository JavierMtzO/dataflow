Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
Rule 2     add_id -> <empty>
Rule 3     save_ids -> <empty>
Rule 4     VARS_PRIME -> VARS VARS_PRIME
Rule 5     VARS_PRIME -> empty
Rule 6     FUNCTION_PRIME -> FUNCTION FUNC_PRIME
Rule 7     FUNCTION_PRIME -> empty
Rule 8     FUNC_PRIME -> FUNCTION FUNC_PRIME
Rule 9     FUNC_PRIME -> empty
Rule 10    add_type -> <empty>
Rule 11    add_current_type -> <empty>
Rule 12    VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
Rule 13    VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
Rule 14    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
Rule 15    VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
Rule 16    TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME
Rule 17    TIPO_PRIME -> empty
Rule 18    get_variable -> <empty>
Rule 19    VARIABLE -> ID get_variable
Rule 20    VARIABLE -> ID [ EXPRESSION ]
Rule 21    TIPO_SIMPLE -> INT add_type
Rule 22    TIPO_SIMPLE -> FLOAT add_type
Rule 23    TIPO_SIMPLE -> CHAR add_type
Rule 24    TIPO_COMP -> DATAFRAME
Rule 25    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
Rule 26    FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
Rule 27    FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
Rule 28    PARAM -> TIPO_SIMPLE ID PARAM_PRIME
Rule 29    PARAM -> empty
Rule 30    PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME
Rule 31    PARAM_PRIME -> empty
Rule 32    BLOCK -> STATEMENT BLOCK
Rule 33    BLOCK -> empty
Rule 34    STATEMENT -> ASSIGNATION
Rule 35    STATEMENT -> FUNC_CALL
Rule 36    STATEMENT -> EXPRESSION ;
Rule 37    STATEMENT -> WRITE
Rule 38    STATEMENT -> CONDITION
Rule 39    STATEMENT -> WHILE_STMT
Rule 40    STATEMENT -> FOR_STMT
Rule 41    STATEMENT -> DESCRIBE_STMT
Rule 42    add_operator -> <empty>
Rule 43    add_operand -> <empty>
Rule 44    add_assignation_quad -> <empty>
Rule 45    ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad
Rule 46    FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME )
Rule 47    FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME
Rule 48    FUNC_CALL_PRIME -> empty
Rule 49    print_quad -> <empty>
Rule 50    add_print_operator -> <empty>
Rule 51    WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
Rule 52    WRITE -> PRINT add_operator ( TITLE WRITE_PRIME )
Rule 53    WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME
Rule 54    WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME
Rule 55    WRITE_PRIME -> empty
Rule 56    CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT
Rule 57    ELSE_STMT -> ELSE { BLOCK }
Rule 58    ELSE_STMT -> empty
Rule 59    WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK }
Rule 60    FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
Rule 61    DESCRIBE_STMT -> ID . DESCRIBE ( )
Rule 62    aritmetics_operation -> <empty>
Rule 63    EXPRESSION -> AND_EXP EXPRESSION_PRIME
Rule 64    EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME
Rule 65    EXPRESSION_PRIME -> empty
Rule 66    AND_EXP -> B_EXP AND_EXP_PRIME
Rule 67    AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME
Rule 68    AND_EXP_PRIME -> empty
Rule 69    B_EXP -> TRUE
Rule 70    B_EXP -> FALSE
Rule 71    B_EXP -> EXP B_EXP_PRIME
Rule 72    B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation
Rule 73    B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation
Rule 74    B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation
Rule 75    B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation
Rule 76    B_EXP_PRIME -> empty
Rule 77    EXP -> TERM EXP_PRIME
Rule 78    EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation
Rule 79    EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation
Rule 80    EXP_PRIME -> empty
Rule 81    TERM -> FACTOR TERM_PRIME
Rule 82    TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 83    TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME
Rule 84    TERM_PRIME -> empty
Rule 85    FACTOR -> ( EXPRESSION )
Rule 86    FACTOR -> * VAR_CT
Rule 87    FACTOR -> / VAR_CT
Rule 88    FACTOR -> VAR_CT
Rule 89    VAR_CT -> ID add_operand
Rule 90    VAR_CT -> I_CONST add_operand
Rule 91    VAR_CT -> F_CONST add_operand
Rule 92    VAR_CT -> C_CONST add_operand
Rule 93    empty -> <empty>

Terminals, with rules where they appear

(                    : 25 26 27 46 51 52 56 59 61 85
)                    : 25 26 27 46 51 52 56 59 61 85
*                    : 82 86
+                    : 78
,                    : 16 30 53 54
-                    : 79
.                    : 61
/                    : 83 87
;                    : 1 12 13 14 15 36 45
<                    : 73
=                    : 45 60
>                    : 72
AND                  : 67
CHAR                 : 23
C_CONST              : 92
DATAFRAME            : 24
DESCRIBE             : 61
DIFFERENT            : 74
DO                   : 60
ELSE                 : 57
EQUAL                : 75
FALSE                : 70
FLOAT                : 22
FOR                  : 60
FUNC                 : 25 26 27
F_CONST              : 91
ID                   : 1 12 13 14 15 16 19 20 25 26 27 28 30 46 60 61 89
IF                   : 56
INT                  : 21
I_CONST              : 90
MAIN                 : 1
OR                   : 64
PRINT                : 51 52
PROG                 : 1
RETURN               : 25 26
TITLE                : 52 54
TO                   : 60
TRUE                 : 69
VAR                  : 12 13 14 15
VOID                 : 1 27
WHILE                : 59
[                    : 14 15 15 20
]                    : 14 15 15 20
error                : 
{                    : 1 25 26 27 56 57 59 60
}                    : 1 25 26 27 56 57 59 60

Nonterminals, with rules where they appear

AND_EXP              : 63 64
AND_EXP_PRIME        : 66 67
ASSIGNATION          : 34
BLOCK                : 1 25 26 27 32 56 57 59 60
B_EXP                : 66 67 72 73 74 75
B_EXP_PRIME          : 71
CONDITION            : 38
DESCRIBE_STMT        : 41
ELSE_STMT            : 56
EXP                  : 71
EXPRESSION           : 14 15 15 20 25 36 45 46 47 51 53 56 59 60 60 85
EXPRESSION_PRIME     : 63 64
EXP_PRIME            : 77 78 79
FACTOR               : 81 82 83
FOR_STMT             : 40
FUNCTION             : 6 8
FUNCTION_PRIME       : 1
FUNC_CALL            : 35
FUNC_CALL_PRIME      : 46 47
FUNC_PRIME           : 6 8
PARAM                : 25 26 27
PARAM_PRIME          : 28 30
PROGRAM              : 0
STATEMENT            : 32
TERM                 : 77 78 79
TERM_PRIME           : 81 82 83
TIPO_COMP            : 12
TIPO_PRIME           : 12 13 16
TIPO_SIMPLE          : 13 14 15 25 26 28 30
VARIABLE             : 45
VARS                 : 4
VARS_PRIME           : 1 1 4 25 26 27
VAR_CT               : 26 86 87 88
WHILE_STMT           : 39
WRITE                : 37
WRITE_PRIME          : 51 52 53 54
add_assignation_quad : 45
add_current_type     : 16
add_id               : 1 12 13 16
add_operand          : 89 90 91 92
add_operator         : 45 51 52 72 73 74 75 78 79 82 83
add_print_operator   : 53 54
add_type             : 1 21 22 23
aritmetics_operation : 72 73 74 75 78 79 82 83
empty                : 5 7 9 17 29 31 33 48 55 58 65 68 76 80 84
get_variable         : 19
print_quad           : 51 53 54
save_ids             : 1 12 13

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    PROG            shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROG . add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 3

state 3

    (1) PROGRAM -> PROG add_type . ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ID              shift and go to state 4


state 4

    (1) PROGRAM -> PROG add_type ID . add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (2) add_id -> .

    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 5

state 5

    (1) PROGRAM -> PROG add_type ID add_id . ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }

    ;               shift and go to state 6


state 6

    (1) PROGRAM -> PROG add_type ID add_id ; . save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 7

state 7

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids . VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (93) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)

    VARS_PRIME                     shift and go to state 8
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 8

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME . FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK }
    (6) FUNCTION_PRIME -> . FUNCTION FUNC_PRIME
    (7) FUNCTION_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (93) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 93 (empty -> .)

    FUNCTION_PRIME                 shift and go to state 12
    FUNCTION                       shift and go to state 13
    empty                          shift and go to state 14

state 9

    (4) VARS_PRIME -> VARS . VARS_PRIME
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (93) empty -> .

    VAR             shift and go to state 11
    FUNC            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)

    VARS                           shift and go to state 9
    VARS_PRIME                     shift and go to state 16
    empty                          shift and go to state 10

state 10

    (5) VARS_PRIME -> empty .

    FUNC            reduce using rule 5 (VARS_PRIME -> empty .)
    VOID            reduce using rule 5 (VARS_PRIME -> empty .)
    ID              reduce using rule 5 (VARS_PRIME -> empty .)
    PRINT           reduce using rule 5 (VARS_PRIME -> empty .)
    IF              reduce using rule 5 (VARS_PRIME -> empty .)
    WHILE           reduce using rule 5 (VARS_PRIME -> empty .)
    FOR             reduce using rule 5 (VARS_PRIME -> empty .)
    TRUE            reduce using rule 5 (VARS_PRIME -> empty .)
    FALSE           reduce using rule 5 (VARS_PRIME -> empty .)
    (               reduce using rule 5 (VARS_PRIME -> empty .)
    *               reduce using rule 5 (VARS_PRIME -> empty .)
    /               reduce using rule 5 (VARS_PRIME -> empty .)
    I_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    F_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    C_CONST         reduce using rule 5 (VARS_PRIME -> empty .)
    }               reduce using rule 5 (VARS_PRIME -> empty .)
    RETURN          reduce using rule 5 (VARS_PRIME -> empty .)


state 11

    (12) VARS -> VAR . TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> VAR . TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> VAR . TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (24) TIPO_COMP -> . DATAFRAME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    DATAFRAME       shift and go to state 19
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_COMP                      shift and go to state 17
    TIPO_SIMPLE                    shift and go to state 18

state 12

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME . VOID MAIN { VARS_PRIME BLOCK }

    VOID            shift and go to state 23


state 13

    (6) FUNCTION_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (93) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 93 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 25
    empty                          shift and go to state 26

state 14

    (7) FUNCTION_PRIME -> empty .

    VOID            reduce using rule 7 (FUNCTION_PRIME -> empty .)


state 15

    (25) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC . TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> FUNC . VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    VOID            shift and go to state 28
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 27

state 16

    (4) VARS_PRIME -> VARS VARS_PRIME .

    FUNC            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    VOID            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    ID              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    PRINT           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    IF              reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    WHILE           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    FOR             reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    TRUE            reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    FALSE           reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    (               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    *               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    /               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    I_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    F_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    C_CONST         reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    }               reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)
    RETURN          reduce using rule 4 (VARS_PRIME -> VARS VARS_PRIME .)


state 17

    (12) VARS -> VAR TIPO_COMP . ID add_id TIPO_PRIME ; save_ids

    ID              shift and go to state 29


state 18

    (13) VARS -> VAR TIPO_SIMPLE . ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE . ID [ EXPRESSION ] [ EXPRESSION ] ;

    ID              shift and go to state 30


state 19

    (24) TIPO_COMP -> DATAFRAME .

    ID              reduce using rule 24 (TIPO_COMP -> DATAFRAME .)


state 20

    (21) TIPO_SIMPLE -> INT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 31

state 21

    (22) TIPO_SIMPLE -> FLOAT . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 32

state 22

    (23) TIPO_SIMPLE -> CHAR . add_type
    (10) add_type -> .

    ID              reduce using rule 10 (add_type -> .)

    add_type                       shift and go to state 33

state 23

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID . MAIN { VARS_PRIME BLOCK }

    MAIN            shift and go to state 34


state 24

    (8) FUNC_PRIME -> FUNCTION . FUNC_PRIME
    (8) FUNC_PRIME -> . FUNCTION FUNC_PRIME
    (9) FUNC_PRIME -> . empty
    (25) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> . FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (27) FUNCTION -> . FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK }
    (93) empty -> .

    FUNC            shift and go to state 15
    VOID            reduce using rule 93 (empty -> .)

    FUNCTION                       shift and go to state 24
    FUNC_PRIME                     shift and go to state 35
    empty                          shift and go to state 26

state 25

    (6) FUNCTION_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 6 (FUNCTION_PRIME -> FUNCTION FUNC_PRIME .)


state 26

    (9) FUNC_PRIME -> empty .

    VOID            reduce using rule 9 (FUNC_PRIME -> empty .)


state 27

    (25) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE . ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    ID              shift and go to state 36


state 28

    (27) FUNCTION -> FUNC VOID . ID ( PARAM ) { VARS_PRIME BLOCK }

    ID              shift and go to state 37


state 29

    (12) VARS -> VAR TIPO_COMP ID . add_id TIPO_PRIME ; save_ids
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 38

state 30

    (13) VARS -> VAR TIPO_SIMPLE ID . add_id TIPO_PRIME ; save_ids
    (14) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID . [ EXPRESSION ] [ EXPRESSION ] ;
    (2) add_id -> .

    [               shift and go to state 40
    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 39

state 31

    (21) TIPO_SIMPLE -> INT add_type .

    ID              reduce using rule 21 (TIPO_SIMPLE -> INT add_type .)


state 32

    (22) TIPO_SIMPLE -> FLOAT add_type .

    ID              reduce using rule 22 (TIPO_SIMPLE -> FLOAT add_type .)


state 33

    (23) TIPO_SIMPLE -> CHAR add_type .

    ID              reduce using rule 23 (TIPO_SIMPLE -> CHAR add_type .)


state 34

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN . { VARS_PRIME BLOCK }

    {               shift and go to state 41


state 35

    (8) FUNC_PRIME -> FUNCTION FUNC_PRIME .

    VOID            reduce using rule 8 (FUNC_PRIME -> FUNCTION FUNC_PRIME .)


state 36

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID . ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }

    (               shift and go to state 42


state 37

    (27) FUNCTION -> FUNC VOID ID . ( PARAM ) { VARS_PRIME BLOCK }

    (               shift and go to state 43


state 38

    (12) VARS -> VAR TIPO_COMP ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 93 (empty -> .)

    TIPO_PRIME                     shift and go to state 44
    empty                          shift and go to state 46

state 39

    (13) VARS -> VAR TIPO_SIMPLE ID add_id . TIPO_PRIME ; save_ids
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 93 (empty -> .)

    TIPO_PRIME                     shift and go to state 47
    empty                          shift and go to state 46

state 40

    (14) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ . EXPRESSION ] [ EXPRESSION ] ;
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 49
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 41

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (93) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    VARS_PRIME                     shift and go to state 64
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 42

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( . PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (93) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 93 (empty -> .)

    TIPO_SIMPLE                    shift and go to state 65
    PARAM                          shift and go to state 66
    empty                          shift and go to state 67

state 43

    (27) FUNCTION -> FUNC VOID ID ( . PARAM ) { VARS_PRIME BLOCK }
    (28) PARAM -> . TIPO_SIMPLE ID PARAM_PRIME
    (29) PARAM -> . empty
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type
    (93) empty -> .

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22
    )               reduce using rule 93 (empty -> .)

    PARAM                          shift and go to state 68
    TIPO_SIMPLE                    shift and go to state 65
    empty                          shift and go to state 67

state 44

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 69


state 45

    (16) TIPO_PRIME -> , . ID add_id add_current_type TIPO_PRIME

    ID              shift and go to state 70


state 46

    (17) TIPO_PRIME -> empty .

    ;               reduce using rule 17 (TIPO_PRIME -> empty .)


state 47

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME . ; save_ids

    ;               shift and go to state 71


state 48

    (89) VAR_CT -> ID . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    DO              reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 72

state 49

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION . ] [ EXPRESSION ] ;

    ]               shift and go to state 73


state 50

    (63) EXPRESSION -> AND_EXP . EXPRESSION_PRIME
    (64) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (65) EXPRESSION_PRIME -> . empty
    (93) empty -> .

    OR              shift and go to state 75
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 74
    empty                          shift and go to state 76

state 51

    (66) AND_EXP -> B_EXP . AND_EXP_PRIME
    (67) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (68) AND_EXP_PRIME -> . empty
    (93) empty -> .

    AND             shift and go to state 78
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 77
    empty                          shift and go to state 79

state 52

    (69) B_EXP -> TRUE .

    AND             reduce using rule 69 (B_EXP -> TRUE .)
    OR              reduce using rule 69 (B_EXP -> TRUE .)
    ]               reduce using rule 69 (B_EXP -> TRUE .)
    )               reduce using rule 69 (B_EXP -> TRUE .)
    ;               reduce using rule 69 (B_EXP -> TRUE .)
    TRUE            reduce using rule 69 (B_EXP -> TRUE .)
    FALSE           reduce using rule 69 (B_EXP -> TRUE .)
    (               reduce using rule 69 (B_EXP -> TRUE .)
    *               reduce using rule 69 (B_EXP -> TRUE .)
    /               reduce using rule 69 (B_EXP -> TRUE .)
    ID              reduce using rule 69 (B_EXP -> TRUE .)
    I_CONST         reduce using rule 69 (B_EXP -> TRUE .)
    F_CONST         reduce using rule 69 (B_EXP -> TRUE .)
    C_CONST         reduce using rule 69 (B_EXP -> TRUE .)
    ,               reduce using rule 69 (B_EXP -> TRUE .)
    TO              reduce using rule 69 (B_EXP -> TRUE .)
    DO              reduce using rule 69 (B_EXP -> TRUE .)
    }               reduce using rule 69 (B_EXP -> TRUE .)


state 53

    (70) B_EXP -> FALSE .

    AND             reduce using rule 70 (B_EXP -> FALSE .)
    OR              reduce using rule 70 (B_EXP -> FALSE .)
    ]               reduce using rule 70 (B_EXP -> FALSE .)
    )               reduce using rule 70 (B_EXP -> FALSE .)
    ;               reduce using rule 70 (B_EXP -> FALSE .)
    TRUE            reduce using rule 70 (B_EXP -> FALSE .)
    FALSE           reduce using rule 70 (B_EXP -> FALSE .)
    (               reduce using rule 70 (B_EXP -> FALSE .)
    *               reduce using rule 70 (B_EXP -> FALSE .)
    /               reduce using rule 70 (B_EXP -> FALSE .)
    ID              reduce using rule 70 (B_EXP -> FALSE .)
    I_CONST         reduce using rule 70 (B_EXP -> FALSE .)
    F_CONST         reduce using rule 70 (B_EXP -> FALSE .)
    C_CONST         reduce using rule 70 (B_EXP -> FALSE .)
    ,               reduce using rule 70 (B_EXP -> FALSE .)
    TO              reduce using rule 70 (B_EXP -> FALSE .)
    DO              reduce using rule 70 (B_EXP -> FALSE .)
    }               reduce using rule 70 (B_EXP -> FALSE .)


state 54

    (71) B_EXP -> EXP . B_EXP_PRIME
    (72) B_EXP_PRIME -> . > add_operator B_EXP aritmetics_operation
    (73) B_EXP_PRIME -> . < add_operator B_EXP aritmetics_operation
    (74) B_EXP_PRIME -> . DIFFERENT add_operator B_EXP aritmetics_operation
    (75) B_EXP_PRIME -> . EQUAL add_operator B_EXP aritmetics_operation
    (76) B_EXP_PRIME -> . empty
    (93) empty -> .

    >               shift and go to state 81
    <               shift and go to state 82
    DIFFERENT       shift and go to state 83
    EQUAL           shift and go to state 84
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    B_EXP_PRIME                    shift and go to state 80
    empty                          shift and go to state 85

state 55

    (77) EXP -> TERM . EXP_PRIME
    (78) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (79) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (80) EXP_PRIME -> . empty
    (93) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    EXP_PRIME                      shift and go to state 86
    empty                          shift and go to state 89

state 56

    (81) TERM -> FACTOR . TERM_PRIME
    (82) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (83) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (84) TERM_PRIME -> . empty
    (93) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 93 (empty -> .)
    -               reduce using rule 93 (empty -> .)
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

  ! *               [ reduce using rule 93 (empty -> .) ]
  ! /               [ reduce using rule 93 (empty -> .) ]

    TERM_PRIME                     shift and go to state 90
    empty                          shift and go to state 93

state 57

    (85) FACTOR -> ( . EXPRESSION )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 94
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 58

    (86) FACTOR -> * . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 95

state 59

    (88) FACTOR -> VAR_CT .

    *               reduce using rule 88 (FACTOR -> VAR_CT .)
    /               reduce using rule 88 (FACTOR -> VAR_CT .)
    +               reduce using rule 88 (FACTOR -> VAR_CT .)
    -               reduce using rule 88 (FACTOR -> VAR_CT .)
    >               reduce using rule 88 (FACTOR -> VAR_CT .)
    <               reduce using rule 88 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 88 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 88 (FACTOR -> VAR_CT .)
    AND             reduce using rule 88 (FACTOR -> VAR_CT .)
    OR              reduce using rule 88 (FACTOR -> VAR_CT .)
    ]               reduce using rule 88 (FACTOR -> VAR_CT .)
    )               reduce using rule 88 (FACTOR -> VAR_CT .)
    ;               reduce using rule 88 (FACTOR -> VAR_CT .)
    TRUE            reduce using rule 88 (FACTOR -> VAR_CT .)
    FALSE           reduce using rule 88 (FACTOR -> VAR_CT .)
    (               reduce using rule 88 (FACTOR -> VAR_CT .)
    ID              reduce using rule 88 (FACTOR -> VAR_CT .)
    I_CONST         reduce using rule 88 (FACTOR -> VAR_CT .)
    F_CONST         reduce using rule 88 (FACTOR -> VAR_CT .)
    C_CONST         reduce using rule 88 (FACTOR -> VAR_CT .)
    ,               reduce using rule 88 (FACTOR -> VAR_CT .)
    TO              reduce using rule 88 (FACTOR -> VAR_CT .)
    DO              reduce using rule 88 (FACTOR -> VAR_CT .)
    }               reduce using rule 88 (FACTOR -> VAR_CT .)


state 60

    (87) FACTOR -> / . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    VAR_CT                         shift and go to state 96

state 61

    (90) VAR_CT -> I_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    DO              reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 97

state 62

    (91) VAR_CT -> F_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    DO              reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 98

state 63

    (92) VAR_CT -> C_CONST . add_operand
    (43) add_operand -> .

    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ]               reduce using rule 43 (add_operand -> .)
    )               reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)
    TRUE            reduce using rule 43 (add_operand -> .)
    FALSE           reduce using rule 43 (add_operand -> .)
    (               reduce using rule 43 (add_operand -> .)
    ID              reduce using rule 43 (add_operand -> .)
    I_CONST         reduce using rule 43 (add_operand -> .)
    F_CONST         reduce using rule 43 (add_operand -> .)
    C_CONST         reduce using rule 43 (add_operand -> .)
    ,               reduce using rule 43 (add_operand -> .)
    TO              reduce using rule 43 (add_operand -> .)
    DO              reduce using rule 43 (add_operand -> .)
    }               reduce using rule 43 (add_operand -> .)

    add_operand                    shift and go to state 99

state 64

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 101
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 65

    (28) PARAM -> TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 117


state 66

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM . ) { VARS_PRIME BLOCK RETURN VAR_CT }

    )               shift and go to state 118


state 67

    (29) PARAM -> empty .

    )               reduce using rule 29 (PARAM -> empty .)


state 68

    (27) FUNCTION -> FUNC VOID ID ( PARAM . ) { VARS_PRIME BLOCK }

    )               shift and go to state 119


state 69

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    TRUE            reduce using rule 3 (save_ids -> .)
    FALSE           reduce using rule 3 (save_ids -> .)
    (               reduce using rule 3 (save_ids -> .)
    *               reduce using rule 3 (save_ids -> .)
    /               reduce using rule 3 (save_ids -> .)
    I_CONST         reduce using rule 3 (save_ids -> .)
    F_CONST         reduce using rule 3 (save_ids -> .)
    C_CONST         reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 120

state 70

    (16) TIPO_PRIME -> , ID . add_id add_current_type TIPO_PRIME
    (2) add_id -> .

    ,               reduce using rule 2 (add_id -> .)
    ;               reduce using rule 2 (add_id -> .)

    add_id                         shift and go to state 121

state 71

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; . save_ids
    (3) save_ids -> .

    VAR             reduce using rule 3 (save_ids -> .)
    FUNC            reduce using rule 3 (save_ids -> .)
    VOID            reduce using rule 3 (save_ids -> .)
    ID              reduce using rule 3 (save_ids -> .)
    PRINT           reduce using rule 3 (save_ids -> .)
    IF              reduce using rule 3 (save_ids -> .)
    WHILE           reduce using rule 3 (save_ids -> .)
    FOR             reduce using rule 3 (save_ids -> .)
    TRUE            reduce using rule 3 (save_ids -> .)
    FALSE           reduce using rule 3 (save_ids -> .)
    (               reduce using rule 3 (save_ids -> .)
    *               reduce using rule 3 (save_ids -> .)
    /               reduce using rule 3 (save_ids -> .)
    I_CONST         reduce using rule 3 (save_ids -> .)
    F_CONST         reduce using rule 3 (save_ids -> .)
    C_CONST         reduce using rule 3 (save_ids -> .)
    }               reduce using rule 3 (save_ids -> .)
    RETURN          reduce using rule 3 (save_ids -> .)

    save_ids                       shift and go to state 122

state 72

    (89) VAR_CT -> ID add_operand .

    *               reduce using rule 89 (VAR_CT -> ID add_operand .)
    /               reduce using rule 89 (VAR_CT -> ID add_operand .)
    +               reduce using rule 89 (VAR_CT -> ID add_operand .)
    -               reduce using rule 89 (VAR_CT -> ID add_operand .)
    >               reduce using rule 89 (VAR_CT -> ID add_operand .)
    <               reduce using rule 89 (VAR_CT -> ID add_operand .)
    DIFFERENT       reduce using rule 89 (VAR_CT -> ID add_operand .)
    EQUAL           reduce using rule 89 (VAR_CT -> ID add_operand .)
    AND             reduce using rule 89 (VAR_CT -> ID add_operand .)
    OR              reduce using rule 89 (VAR_CT -> ID add_operand .)
    ]               reduce using rule 89 (VAR_CT -> ID add_operand .)
    )               reduce using rule 89 (VAR_CT -> ID add_operand .)
    ;               reduce using rule 89 (VAR_CT -> ID add_operand .)
    TRUE            reduce using rule 89 (VAR_CT -> ID add_operand .)
    FALSE           reduce using rule 89 (VAR_CT -> ID add_operand .)
    (               reduce using rule 89 (VAR_CT -> ID add_operand .)
    ID              reduce using rule 89 (VAR_CT -> ID add_operand .)
    I_CONST         reduce using rule 89 (VAR_CT -> ID add_operand .)
    F_CONST         reduce using rule 89 (VAR_CT -> ID add_operand .)
    C_CONST         reduce using rule 89 (VAR_CT -> ID add_operand .)
    ,               reduce using rule 89 (VAR_CT -> ID add_operand .)
    TO              reduce using rule 89 (VAR_CT -> ID add_operand .)
    DO              reduce using rule 89 (VAR_CT -> ID add_operand .)
    }               reduce using rule 89 (VAR_CT -> ID add_operand .)


state 73

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . ;
    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] . [ EXPRESSION ] ;

    ;               shift and go to state 124
    [               shift and go to state 123


state 74

    (63) EXPRESSION -> AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 63 (EXPRESSION -> AND_EXP EXPRESSION_PRIME .)


state 75

    (64) EXPRESSION_PRIME -> OR . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    AND_EXP                        shift and go to state 125
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 76

    (65) EXPRESSION_PRIME -> empty .

    ]               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    )               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    ;               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    TRUE            reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    FALSE           reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    (               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    *               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    /               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    ID              reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    I_CONST         reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    F_CONST         reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    C_CONST         reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    ,               reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    TO              reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    DO              reduce using rule 65 (EXPRESSION_PRIME -> empty .)
    }               reduce using rule 65 (EXPRESSION_PRIME -> empty .)


state 77

    (66) AND_EXP -> B_EXP AND_EXP_PRIME .

    OR              reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    )               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    (               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    *               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    /               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)
    }               reduce using rule 66 (AND_EXP -> B_EXP AND_EXP_PRIME .)


state 78

    (67) AND_EXP_PRIME -> AND . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 126
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 79

    (68) AND_EXP_PRIME -> empty .

    OR              reduce using rule 68 (AND_EXP_PRIME -> empty .)
    ]               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    )               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    ;               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    TRUE            reduce using rule 68 (AND_EXP_PRIME -> empty .)
    FALSE           reduce using rule 68 (AND_EXP_PRIME -> empty .)
    (               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    *               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    /               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    ID              reduce using rule 68 (AND_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 68 (AND_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 68 (AND_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 68 (AND_EXP_PRIME -> empty .)
    ,               reduce using rule 68 (AND_EXP_PRIME -> empty .)
    TO              reduce using rule 68 (AND_EXP_PRIME -> empty .)
    DO              reduce using rule 68 (AND_EXP_PRIME -> empty .)
    }               reduce using rule 68 (AND_EXP_PRIME -> empty .)


state 80

    (71) B_EXP -> EXP B_EXP_PRIME .

    AND             reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    OR              reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    ]               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    )               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    ;               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    TRUE            reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    FALSE           reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    (               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    *               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    /               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    ID              reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    I_CONST         reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    F_CONST         reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    C_CONST         reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    ,               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    TO              reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    DO              reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)
    }               reduce using rule 71 (B_EXP -> EXP B_EXP_PRIME .)


state 81

    (72) B_EXP_PRIME -> > . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 127

state 82

    (73) B_EXP_PRIME -> < . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 128

state 83

    (74) B_EXP_PRIME -> DIFFERENT . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 129

state 84

    (75) B_EXP_PRIME -> EQUAL . add_operator B_EXP aritmetics_operation
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 130

state 85

    (76) B_EXP_PRIME -> empty .

    AND             reduce using rule 76 (B_EXP_PRIME -> empty .)
    OR              reduce using rule 76 (B_EXP_PRIME -> empty .)
    ]               reduce using rule 76 (B_EXP_PRIME -> empty .)
    )               reduce using rule 76 (B_EXP_PRIME -> empty .)
    ;               reduce using rule 76 (B_EXP_PRIME -> empty .)
    TRUE            reduce using rule 76 (B_EXP_PRIME -> empty .)
    FALSE           reduce using rule 76 (B_EXP_PRIME -> empty .)
    (               reduce using rule 76 (B_EXP_PRIME -> empty .)
    *               reduce using rule 76 (B_EXP_PRIME -> empty .)
    /               reduce using rule 76 (B_EXP_PRIME -> empty .)
    ID              reduce using rule 76 (B_EXP_PRIME -> empty .)
    I_CONST         reduce using rule 76 (B_EXP_PRIME -> empty .)
    F_CONST         reduce using rule 76 (B_EXP_PRIME -> empty .)
    C_CONST         reduce using rule 76 (B_EXP_PRIME -> empty .)
    ,               reduce using rule 76 (B_EXP_PRIME -> empty .)
    TO              reduce using rule 76 (B_EXP_PRIME -> empty .)
    DO              reduce using rule 76 (B_EXP_PRIME -> empty .)
    }               reduce using rule 76 (B_EXP_PRIME -> empty .)


state 86

    (77) EXP -> TERM EXP_PRIME .

    >               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    <               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    DIFFERENT       reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    EQUAL           reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    AND             reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    OR              reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    ]               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    )               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    ;               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    TRUE            reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    FALSE           reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    (               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    *               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    /               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    ID              reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    I_CONST         reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    F_CONST         reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    C_CONST         reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    ,               reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    TO              reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    DO              reduce using rule 77 (EXP -> TERM EXP_PRIME .)
    }               reduce using rule 77 (EXP -> TERM EXP_PRIME .)


state 87

    (78) EXP_PRIME -> + . add_operator TERM EXP_PRIME aritmetics_operation
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 131

state 88

    (79) EXP_PRIME -> - . add_operator TERM EXP_PRIME aritmetics_operation
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 132

state 89

    (80) EXP_PRIME -> empty .

    >               reduce using rule 80 (EXP_PRIME -> empty .)
    <               reduce using rule 80 (EXP_PRIME -> empty .)
    DIFFERENT       reduce using rule 80 (EXP_PRIME -> empty .)
    EQUAL           reduce using rule 80 (EXP_PRIME -> empty .)
    AND             reduce using rule 80 (EXP_PRIME -> empty .)
    OR              reduce using rule 80 (EXP_PRIME -> empty .)
    ]               reduce using rule 80 (EXP_PRIME -> empty .)
    )               reduce using rule 80 (EXP_PRIME -> empty .)
    ;               reduce using rule 80 (EXP_PRIME -> empty .)
    TRUE            reduce using rule 80 (EXP_PRIME -> empty .)
    FALSE           reduce using rule 80 (EXP_PRIME -> empty .)
    (               reduce using rule 80 (EXP_PRIME -> empty .)
    *               reduce using rule 80 (EXP_PRIME -> empty .)
    /               reduce using rule 80 (EXP_PRIME -> empty .)
    ID              reduce using rule 80 (EXP_PRIME -> empty .)
    I_CONST         reduce using rule 80 (EXP_PRIME -> empty .)
    F_CONST         reduce using rule 80 (EXP_PRIME -> empty .)
    C_CONST         reduce using rule 80 (EXP_PRIME -> empty .)
    ,               reduce using rule 80 (EXP_PRIME -> empty .)
    TO              reduce using rule 80 (EXP_PRIME -> empty .)
    DO              reduce using rule 80 (EXP_PRIME -> empty .)
    }               reduce using rule 80 (EXP_PRIME -> empty .)


state 90

    (81) TERM -> FACTOR TERM_PRIME .

    +               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    -               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    >               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    <               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    DIFFERENT       reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    EQUAL           reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    AND             reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    OR              reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    ]               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    )               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    ;               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    TRUE            reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    FALSE           reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    (               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    *               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    /               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    ID              reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    I_CONST         reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    F_CONST         reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    C_CONST         reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    ,               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    TO              reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    DO              reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)
    }               reduce using rule 81 (TERM -> FACTOR TERM_PRIME .)


state 91

    (82) TERM_PRIME -> * . add_operator FACTOR aritmetics_operation TERM_PRIME
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 133

state 92

    (83) TERM_PRIME -> / . add_operator FACTOR aritmetics_operation TERM_PRIME
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 134

state 93

    (84) TERM_PRIME -> empty .

    +               reduce using rule 84 (TERM_PRIME -> empty .)
    -               reduce using rule 84 (TERM_PRIME -> empty .)
    >               reduce using rule 84 (TERM_PRIME -> empty .)
    <               reduce using rule 84 (TERM_PRIME -> empty .)
    DIFFERENT       reduce using rule 84 (TERM_PRIME -> empty .)
    EQUAL           reduce using rule 84 (TERM_PRIME -> empty .)
    AND             reduce using rule 84 (TERM_PRIME -> empty .)
    OR              reduce using rule 84 (TERM_PRIME -> empty .)
    ]               reduce using rule 84 (TERM_PRIME -> empty .)
    )               reduce using rule 84 (TERM_PRIME -> empty .)
    ;               reduce using rule 84 (TERM_PRIME -> empty .)
    TRUE            reduce using rule 84 (TERM_PRIME -> empty .)
    FALSE           reduce using rule 84 (TERM_PRIME -> empty .)
    (               reduce using rule 84 (TERM_PRIME -> empty .)
    *               reduce using rule 84 (TERM_PRIME -> empty .)
    /               reduce using rule 84 (TERM_PRIME -> empty .)
    ID              reduce using rule 84 (TERM_PRIME -> empty .)
    I_CONST         reduce using rule 84 (TERM_PRIME -> empty .)
    F_CONST         reduce using rule 84 (TERM_PRIME -> empty .)
    C_CONST         reduce using rule 84 (TERM_PRIME -> empty .)
    ,               reduce using rule 84 (TERM_PRIME -> empty .)
    TO              reduce using rule 84 (TERM_PRIME -> empty .)
    DO              reduce using rule 84 (TERM_PRIME -> empty .)
    }               reduce using rule 84 (TERM_PRIME -> empty .)


state 94

    (85) FACTOR -> ( EXPRESSION . )

    )               shift and go to state 135


state 95

    (86) FACTOR -> * VAR_CT .

    *               reduce using rule 86 (FACTOR -> * VAR_CT .)
    /               reduce using rule 86 (FACTOR -> * VAR_CT .)
    +               reduce using rule 86 (FACTOR -> * VAR_CT .)
    -               reduce using rule 86 (FACTOR -> * VAR_CT .)
    >               reduce using rule 86 (FACTOR -> * VAR_CT .)
    <               reduce using rule 86 (FACTOR -> * VAR_CT .)
    DIFFERENT       reduce using rule 86 (FACTOR -> * VAR_CT .)
    EQUAL           reduce using rule 86 (FACTOR -> * VAR_CT .)
    AND             reduce using rule 86 (FACTOR -> * VAR_CT .)
    OR              reduce using rule 86 (FACTOR -> * VAR_CT .)
    ]               reduce using rule 86 (FACTOR -> * VAR_CT .)
    )               reduce using rule 86 (FACTOR -> * VAR_CT .)
    ;               reduce using rule 86 (FACTOR -> * VAR_CT .)
    TRUE            reduce using rule 86 (FACTOR -> * VAR_CT .)
    FALSE           reduce using rule 86 (FACTOR -> * VAR_CT .)
    (               reduce using rule 86 (FACTOR -> * VAR_CT .)
    ID              reduce using rule 86 (FACTOR -> * VAR_CT .)
    I_CONST         reduce using rule 86 (FACTOR -> * VAR_CT .)
    F_CONST         reduce using rule 86 (FACTOR -> * VAR_CT .)
    C_CONST         reduce using rule 86 (FACTOR -> * VAR_CT .)
    ,               reduce using rule 86 (FACTOR -> * VAR_CT .)
    TO              reduce using rule 86 (FACTOR -> * VAR_CT .)
    DO              reduce using rule 86 (FACTOR -> * VAR_CT .)
    }               reduce using rule 86 (FACTOR -> * VAR_CT .)


state 96

    (87) FACTOR -> / VAR_CT .

    *               reduce using rule 87 (FACTOR -> / VAR_CT .)
    /               reduce using rule 87 (FACTOR -> / VAR_CT .)
    +               reduce using rule 87 (FACTOR -> / VAR_CT .)
    -               reduce using rule 87 (FACTOR -> / VAR_CT .)
    >               reduce using rule 87 (FACTOR -> / VAR_CT .)
    <               reduce using rule 87 (FACTOR -> / VAR_CT .)
    DIFFERENT       reduce using rule 87 (FACTOR -> / VAR_CT .)
    EQUAL           reduce using rule 87 (FACTOR -> / VAR_CT .)
    AND             reduce using rule 87 (FACTOR -> / VAR_CT .)
    OR              reduce using rule 87 (FACTOR -> / VAR_CT .)
    ]               reduce using rule 87 (FACTOR -> / VAR_CT .)
    )               reduce using rule 87 (FACTOR -> / VAR_CT .)
    ;               reduce using rule 87 (FACTOR -> / VAR_CT .)
    TRUE            reduce using rule 87 (FACTOR -> / VAR_CT .)
    FALSE           reduce using rule 87 (FACTOR -> / VAR_CT .)
    (               reduce using rule 87 (FACTOR -> / VAR_CT .)
    ID              reduce using rule 87 (FACTOR -> / VAR_CT .)
    I_CONST         reduce using rule 87 (FACTOR -> / VAR_CT .)
    F_CONST         reduce using rule 87 (FACTOR -> / VAR_CT .)
    C_CONST         reduce using rule 87 (FACTOR -> / VAR_CT .)
    ,               reduce using rule 87 (FACTOR -> / VAR_CT .)
    TO              reduce using rule 87 (FACTOR -> / VAR_CT .)
    DO              reduce using rule 87 (FACTOR -> / VAR_CT .)
    }               reduce using rule 87 (FACTOR -> / VAR_CT .)


state 97

    (90) VAR_CT -> I_CONST add_operand .

    *               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    /               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    +               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    -               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    >               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    <               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    DIFFERENT       reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    EQUAL           reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    AND             reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    OR              reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    ]               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    )               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    ;               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    TRUE            reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    FALSE           reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    (               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    ID              reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    I_CONST         reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    F_CONST         reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    C_CONST         reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    ,               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    TO              reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    DO              reduce using rule 90 (VAR_CT -> I_CONST add_operand .)
    }               reduce using rule 90 (VAR_CT -> I_CONST add_operand .)


state 98

    (91) VAR_CT -> F_CONST add_operand .

    *               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    /               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    +               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    -               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    >               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    <               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    DIFFERENT       reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    EQUAL           reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    AND             reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    OR              reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    ]               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    )               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    ;               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    TRUE            reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    FALSE           reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    (               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    ID              reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    I_CONST         reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    F_CONST         reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    C_CONST         reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    ,               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    TO              reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    DO              reduce using rule 91 (VAR_CT -> F_CONST add_operand .)
    }               reduce using rule 91 (VAR_CT -> F_CONST add_operand .)


state 99

    (92) VAR_CT -> C_CONST add_operand .

    *               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    /               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    +               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    -               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    >               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    <               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    DIFFERENT       reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    EQUAL           reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    AND             reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    OR              reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    ]               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    )               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    ;               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    TRUE            reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    FALSE           reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    (               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    ID              reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    I_CONST         reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    F_CONST         reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    C_CONST         reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    ,               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    TO              reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    DO              reduce using rule 92 (VAR_CT -> C_CONST add_operand .)
    }               reduce using rule 92 (VAR_CT -> C_CONST add_operand .)


state 100

    (46) FUNC_CALL -> ID . ( EXPRESSION FUNC_CALL_PRIME )
    (61) DESCRIBE_STMT -> ID . . DESCRIBE ( )
    (19) VARIABLE -> ID . get_variable
    (20) VARIABLE -> ID . [ EXPRESSION ]
    (89) VAR_CT -> ID . add_operand
    (18) get_variable -> .
    (43) add_operand -> .

    (               shift and go to state 136
    .               shift and go to state 137
    [               shift and go to state 139
    =               reduce using rule 18 (get_variable -> .)
    *               reduce using rule 43 (add_operand -> .)
    /               reduce using rule 43 (add_operand -> .)
    +               reduce using rule 43 (add_operand -> .)
    -               reduce using rule 43 (add_operand -> .)
    >               reduce using rule 43 (add_operand -> .)
    <               reduce using rule 43 (add_operand -> .)
    DIFFERENT       reduce using rule 43 (add_operand -> .)
    EQUAL           reduce using rule 43 (add_operand -> .)
    AND             reduce using rule 43 (add_operand -> .)
    OR              reduce using rule 43 (add_operand -> .)
    ;               reduce using rule 43 (add_operand -> .)

    get_variable                   shift and go to state 138
    add_operand                    shift and go to state 72

state 101

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK . }

    }               shift and go to state 140


state 102

    (32) BLOCK -> STATEMENT . BLOCK
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    STATEMENT                      shift and go to state 102
    BLOCK                          shift and go to state 141
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 103

    (33) BLOCK -> empty .

    }               reduce using rule 33 (BLOCK -> empty .)
    RETURN          reduce using rule 33 (BLOCK -> empty .)


state 104

    (34) STATEMENT -> ASSIGNATION .

    ID              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    PRINT           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    IF              reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    WHILE           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    FOR             reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    TRUE            reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    FALSE           reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    (               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    *               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    /               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    I_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    F_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    C_CONST         reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    }               reduce using rule 34 (STATEMENT -> ASSIGNATION .)
    RETURN          reduce using rule 34 (STATEMENT -> ASSIGNATION .)


state 105

    (35) STATEMENT -> FUNC_CALL .

    ID              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    PRINT           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    IF              reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    WHILE           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    FOR             reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    TRUE            reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    FALSE           reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    (               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    *               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    /               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    I_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    F_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    C_CONST         reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    }               reduce using rule 35 (STATEMENT -> FUNC_CALL .)
    RETURN          reduce using rule 35 (STATEMENT -> FUNC_CALL .)


state 106

    (36) STATEMENT -> EXPRESSION . ;

    ;               shift and go to state 142


state 107

    (37) STATEMENT -> WRITE .

    ID              reduce using rule 37 (STATEMENT -> WRITE .)
    PRINT           reduce using rule 37 (STATEMENT -> WRITE .)
    IF              reduce using rule 37 (STATEMENT -> WRITE .)
    WHILE           reduce using rule 37 (STATEMENT -> WRITE .)
    FOR             reduce using rule 37 (STATEMENT -> WRITE .)
    TRUE            reduce using rule 37 (STATEMENT -> WRITE .)
    FALSE           reduce using rule 37 (STATEMENT -> WRITE .)
    (               reduce using rule 37 (STATEMENT -> WRITE .)
    *               reduce using rule 37 (STATEMENT -> WRITE .)
    /               reduce using rule 37 (STATEMENT -> WRITE .)
    I_CONST         reduce using rule 37 (STATEMENT -> WRITE .)
    F_CONST         reduce using rule 37 (STATEMENT -> WRITE .)
    C_CONST         reduce using rule 37 (STATEMENT -> WRITE .)
    }               reduce using rule 37 (STATEMENT -> WRITE .)
    RETURN          reduce using rule 37 (STATEMENT -> WRITE .)


state 108

    (38) STATEMENT -> CONDITION .

    ID              reduce using rule 38 (STATEMENT -> CONDITION .)
    PRINT           reduce using rule 38 (STATEMENT -> CONDITION .)
    IF              reduce using rule 38 (STATEMENT -> CONDITION .)
    WHILE           reduce using rule 38 (STATEMENT -> CONDITION .)
    FOR             reduce using rule 38 (STATEMENT -> CONDITION .)
    TRUE            reduce using rule 38 (STATEMENT -> CONDITION .)
    FALSE           reduce using rule 38 (STATEMENT -> CONDITION .)
    (               reduce using rule 38 (STATEMENT -> CONDITION .)
    *               reduce using rule 38 (STATEMENT -> CONDITION .)
    /               reduce using rule 38 (STATEMENT -> CONDITION .)
    I_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    F_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    C_CONST         reduce using rule 38 (STATEMENT -> CONDITION .)
    }               reduce using rule 38 (STATEMENT -> CONDITION .)
    RETURN          reduce using rule 38 (STATEMENT -> CONDITION .)


state 109

    (39) STATEMENT -> WHILE_STMT .

    ID              reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    PRINT           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    IF              reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    WHILE           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    FOR             reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    TRUE            reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    FALSE           reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    (               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    *               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    /               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    I_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    F_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    C_CONST         reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    }               reduce using rule 39 (STATEMENT -> WHILE_STMT .)
    RETURN          reduce using rule 39 (STATEMENT -> WHILE_STMT .)


state 110

    (40) STATEMENT -> FOR_STMT .

    ID              reduce using rule 40 (STATEMENT -> FOR_STMT .)
    PRINT           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    IF              reduce using rule 40 (STATEMENT -> FOR_STMT .)
    WHILE           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    FOR             reduce using rule 40 (STATEMENT -> FOR_STMT .)
    TRUE            reduce using rule 40 (STATEMENT -> FOR_STMT .)
    FALSE           reduce using rule 40 (STATEMENT -> FOR_STMT .)
    (               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    *               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    /               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    I_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    F_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    C_CONST         reduce using rule 40 (STATEMENT -> FOR_STMT .)
    }               reduce using rule 40 (STATEMENT -> FOR_STMT .)
    RETURN          reduce using rule 40 (STATEMENT -> FOR_STMT .)


state 111

    (41) STATEMENT -> DESCRIBE_STMT .

    ID              reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    PRINT           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    IF              reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    WHILE           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    FOR             reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    TRUE            reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    FALSE           reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    (               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    *               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    /               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    I_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    F_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    C_CONST         reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    }               reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)
    RETURN          reduce using rule 41 (STATEMENT -> DESCRIBE_STMT .)


state 112

    (45) ASSIGNATION -> VARIABLE . = add_operator EXPRESSION ; add_assignation_quad

    =               shift and go to state 143


state 113

    (51) WRITE -> PRINT . add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> PRINT . add_operator ( TITLE WRITE_PRIME )
    (42) add_operator -> .

    (               reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 144

state 114

    (56) CONDITION -> IF . ( EXPRESSION ) { BLOCK } ELSE_STMT

    (               shift and go to state 145


state 115

    (59) WHILE_STMT -> WHILE . ( EXPRESSION ) { BLOCK }

    (               shift and go to state 146


state 116

    (60) FOR_STMT -> FOR . ID = EXPRESSION TO EXPRESSION DO { BLOCK }

    ID              shift and go to state 147


state 117

    (28) PARAM -> TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 149
    )               reduce using rule 93 (empty -> .)

    PARAM_PRIME                    shift and go to state 148
    empty                          shift and go to state 150

state 118

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) . { VARS_PRIME BLOCK RETURN VAR_CT }

    {               shift and go to state 151


state 119

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) . { VARS_PRIME BLOCK }

    {               shift and go to state 152


state 120

    (12) VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 12 (VARS -> VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids .)


state 121

    (16) TIPO_PRIME -> , ID add_id . add_current_type TIPO_PRIME
    (11) add_current_type -> .

    ,               reduce using rule 11 (add_current_type -> .)
    ;               reduce using rule 11 (add_current_type -> .)

    add_current_type               shift and go to state 153

state 122

    (13) VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .

    VAR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FUNC            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    VOID            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    ID              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    PRINT           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    IF              reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    WHILE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FOR             reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    TRUE            reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    FALSE           reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    (               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    *               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    /               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    I_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    F_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    C_CONST         reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    }               reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)
    RETURN          reduce using rule 13 (VARS -> VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids .)


state 123

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ . EXPRESSION ] ;
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 154
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 124

    (14) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .

    VAR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FUNC            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    VOID            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    ID              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    PRINT           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    IF              reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    WHILE           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FOR             reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    TRUE            reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    FALSE           reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    (               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    *               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    /               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    }               reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)
    RETURN          reduce using rule 14 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] ; .)


state 125

    (64) EXPRESSION_PRIME -> OR AND_EXP . EXPRESSION_PRIME
    (64) EXPRESSION_PRIME -> . OR AND_EXP EXPRESSION_PRIME
    (65) EXPRESSION_PRIME -> . empty
    (93) empty -> .

    OR              shift and go to state 75
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    EXPRESSION_PRIME               shift and go to state 155
    empty                          shift and go to state 76

state 126

    (67) AND_EXP_PRIME -> AND B_EXP . AND_EXP_PRIME
    (67) AND_EXP_PRIME -> . AND B_EXP AND_EXP_PRIME
    (68) AND_EXP_PRIME -> . empty
    (93) empty -> .

    AND             shift and go to state 78
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    AND_EXP_PRIME                  shift and go to state 156
    empty                          shift and go to state 79

state 127

    (72) B_EXP_PRIME -> > add_operator . B_EXP aritmetics_operation
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 157
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 128

    (73) B_EXP_PRIME -> < add_operator . B_EXP aritmetics_operation
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 158
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 129

    (74) B_EXP_PRIME -> DIFFERENT add_operator . B_EXP aritmetics_operation
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 159
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 130

    (75) B_EXP_PRIME -> EQUAL add_operator . B_EXP aritmetics_operation
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    B_EXP                          shift and go to state 160
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 131

    (78) EXP_PRIME -> + add_operator . TERM EXP_PRIME aritmetics_operation
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 161
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 132

    (79) EXP_PRIME -> - add_operator . TERM EXP_PRIME aritmetics_operation
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    TERM                           shift and go to state 162
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 133

    (82) TERM_PRIME -> * add_operator . FACTOR aritmetics_operation TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 163
    VAR_CT                         shift and go to state 59

state 134

    (83) TERM_PRIME -> / add_operator . FACTOR aritmetics_operation TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    FACTOR                         shift and go to state 164
    VAR_CT                         shift and go to state 59

state 135

    (85) FACTOR -> ( EXPRESSION ) .

    *               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    /               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    +               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    -               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    >               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    <               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    DIFFERENT       reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    EQUAL           reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    AND             reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    OR              reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    ]               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    )               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    ;               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    TRUE            reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    FALSE           reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    (               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    ID              reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    I_CONST         reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    F_CONST         reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    C_CONST         reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    ,               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    TO              reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    DO              reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)
    }               reduce using rule 85 (FACTOR -> ( EXPRESSION ) .)


state 136

    (46) FUNC_CALL -> ID ( . EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 165
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 137

    (61) DESCRIBE_STMT -> ID . . DESCRIBE ( )

    DESCRIBE        shift and go to state 166


state 138

    (19) VARIABLE -> ID get_variable .

    =               reduce using rule 19 (VARIABLE -> ID get_variable .)


state 139

    (20) VARIABLE -> ID [ . EXPRESSION ]
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 167
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 140

    (1) PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .

    $end            reduce using rule 1 (PROGRAM -> PROG add_type ID add_id ; save_ids VARS_PRIME FUNCTION_PRIME VOID MAIN { VARS_PRIME BLOCK } .)


state 141

    (32) BLOCK -> STATEMENT BLOCK .

    }               reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)
    RETURN          reduce using rule 32 (BLOCK -> STATEMENT BLOCK .)


state 142

    (36) STATEMENT -> EXPRESSION ; .

    ID              reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    PRINT           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    IF              reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    WHILE           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    FOR             reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    TRUE            reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    FALSE           reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    (               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    *               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    /               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    I_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    F_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    C_CONST         reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    }               reduce using rule 36 (STATEMENT -> EXPRESSION ; .)
    RETURN          reduce using rule 36 (STATEMENT -> EXPRESSION ; .)


state 143

    (45) ASSIGNATION -> VARIABLE = . add_operator EXPRESSION ; add_assignation_quad
    (42) add_operator -> .

    TRUE            reduce using rule 42 (add_operator -> .)
    FALSE           reduce using rule 42 (add_operator -> .)
    (               reduce using rule 42 (add_operator -> .)
    *               reduce using rule 42 (add_operator -> .)
    /               reduce using rule 42 (add_operator -> .)
    ID              reduce using rule 42 (add_operator -> .)
    I_CONST         reduce using rule 42 (add_operator -> .)
    F_CONST         reduce using rule 42 (add_operator -> .)
    C_CONST         reduce using rule 42 (add_operator -> .)

    add_operator                   shift and go to state 168

state 144

    (51) WRITE -> PRINT add_operator . ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> PRINT add_operator . ( TITLE WRITE_PRIME )

    (               shift and go to state 169


state 145

    (56) CONDITION -> IF ( . EXPRESSION ) { BLOCK } ELSE_STMT
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 170
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 146

    (59) WHILE_STMT -> WHILE ( . EXPRESSION ) { BLOCK }
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 171
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 147

    (60) FOR_STMT -> FOR ID . = EXPRESSION TO EXPRESSION DO { BLOCK }

    =               shift and go to state 172


state 148

    (28) PARAM -> TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 28 (PARAM -> TIPO_SIMPLE ID PARAM_PRIME .)


state 149

    (30) PARAM_PRIME -> , . TIPO_SIMPLE ID PARAM_PRIME
    (21) TIPO_SIMPLE -> . INT add_type
    (22) TIPO_SIMPLE -> . FLOAT add_type
    (23) TIPO_SIMPLE -> . CHAR add_type

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 22

    TIPO_SIMPLE                    shift and go to state 173

state 150

    (31) PARAM_PRIME -> empty .

    )               reduce using rule 31 (PARAM_PRIME -> empty .)


state 151

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { . VARS_PRIME BLOCK RETURN VAR_CT }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (93) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)

    VARS_PRIME                     shift and go to state 174
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 152

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { . VARS_PRIME BLOCK }
    (4) VARS_PRIME -> . VARS VARS_PRIME
    (5) VARS_PRIME -> . empty
    (12) VARS -> . VAR TIPO_COMP ID add_id TIPO_PRIME ; save_ids
    (13) VARS -> . VAR TIPO_SIMPLE ID add_id TIPO_PRIME ; save_ids
    (14) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] ;
    (15) VARS -> . VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ;
    (93) empty -> .

    VAR             shift and go to state 11
    ID              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    VARS_PRIME                     shift and go to state 175
    VARS                           shift and go to state 9
    empty                          shift and go to state 10

state 153

    (16) TIPO_PRIME -> , ID add_id add_current_type . TIPO_PRIME
    (16) TIPO_PRIME -> . , ID add_id add_current_type TIPO_PRIME
    (17) TIPO_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 45
    ;               reduce using rule 93 (empty -> .)

    TIPO_PRIME                     shift and go to state 176
    empty                          shift and go to state 46

state 154

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION . ] ;

    ]               shift and go to state 177


state 155

    (64) EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .

    ]               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    )               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ;               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TRUE            reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    FALSE           reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    (               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    *               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    /               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ID              reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    I_CONST         reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    F_CONST         reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    C_CONST         reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    ,               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    TO              reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    DO              reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)
    }               reduce using rule 64 (EXPRESSION_PRIME -> OR AND_EXP EXPRESSION_PRIME .)


state 156

    (67) AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .

    OR              reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ]               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    )               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ;               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TRUE            reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    FALSE           reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    (               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    *               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    /               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ID              reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    I_CONST         reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    F_CONST         reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    C_CONST         reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    ,               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    TO              reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    DO              reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)
    }               reduce using rule 67 (AND_EXP_PRIME -> AND B_EXP AND_EXP_PRIME .)


state 157

    (72) B_EXP_PRIME -> > add_operator B_EXP . aritmetics_operation
    (62) aritmetics_operation -> .

    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 178

state 158

    (73) B_EXP_PRIME -> < add_operator B_EXP . aritmetics_operation
    (62) aritmetics_operation -> .

    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 179

state 159

    (74) B_EXP_PRIME -> DIFFERENT add_operator B_EXP . aritmetics_operation
    (62) aritmetics_operation -> .

    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 180

state 160

    (75) B_EXP_PRIME -> EQUAL add_operator B_EXP . aritmetics_operation
    (62) aritmetics_operation -> .

    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 181

state 161

    (78) EXP_PRIME -> + add_operator TERM . EXP_PRIME aritmetics_operation
    (78) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (79) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (80) EXP_PRIME -> . empty
    (93) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    EXP_PRIME                      shift and go to state 182
    empty                          shift and go to state 89

state 162

    (79) EXP_PRIME -> - add_operator TERM . EXP_PRIME aritmetics_operation
    (78) EXP_PRIME -> . + add_operator TERM EXP_PRIME aritmetics_operation
    (79) EXP_PRIME -> . - add_operator TERM EXP_PRIME aritmetics_operation
    (80) EXP_PRIME -> . empty
    (93) empty -> .

    +               shift and go to state 87
    -               shift and go to state 88
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

    EXP_PRIME                      shift and go to state 183
    empty                          shift and go to state 89

state 163

    (82) TERM_PRIME -> * add_operator FACTOR . aritmetics_operation TERM_PRIME
    (62) aritmetics_operation -> .

    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    +               reduce using rule 62 (aritmetics_operation -> .)
    -               reduce using rule 62 (aritmetics_operation -> .)
    >               reduce using rule 62 (aritmetics_operation -> .)
    <               reduce using rule 62 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 62 (aritmetics_operation -> .)
    EQUAL           reduce using rule 62 (aritmetics_operation -> .)
    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 184

state 164

    (83) TERM_PRIME -> / add_operator FACTOR . aritmetics_operation TERM_PRIME
    (62) aritmetics_operation -> .

    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    +               reduce using rule 62 (aritmetics_operation -> .)
    -               reduce using rule 62 (aritmetics_operation -> .)
    >               reduce using rule 62 (aritmetics_operation -> .)
    <               reduce using rule 62 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 62 (aritmetics_operation -> .)
    EQUAL           reduce using rule 62 (aritmetics_operation -> .)
    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 185

state 165

    (46) FUNC_CALL -> ID ( EXPRESSION . FUNC_CALL_PRIME )
    (47) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (48) FUNC_CALL_PRIME -> . empty
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (93) empty -> .
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 93 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 186
    FUNC_CALL_PRIME                shift and go to state 187
    empty                          shift and go to state 188
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 166

    (61) DESCRIBE_STMT -> ID . DESCRIBE . ( )

    (               shift and go to state 189


state 167

    (20) VARIABLE -> ID [ EXPRESSION . ]

    ]               shift and go to state 190


state 168

    (45) ASSIGNATION -> VARIABLE = add_operator . EXPRESSION ; add_assignation_quad
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 191
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 169

    (51) WRITE -> PRINT add_operator ( . EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> PRINT add_operator ( . TITLE WRITE_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 193
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 192
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 170

    (56) CONDITION -> IF ( EXPRESSION . ) { BLOCK } ELSE_STMT

    )               shift and go to state 194


state 171

    (59) WHILE_STMT -> WHILE ( EXPRESSION . ) { BLOCK }

    )               shift and go to state 195


state 172

    (60) FOR_STMT -> FOR ID = . EXPRESSION TO EXPRESSION DO { BLOCK }
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 196
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 173

    (30) PARAM_PRIME -> , TIPO_SIMPLE . ID PARAM_PRIME

    ID              shift and go to state 197


state 174

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME . BLOCK RETURN VAR_CT }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    RETURN          reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 198
    EXPRESSION                     shift and go to state 106
    VAR_CT                         shift and go to state 59
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56

state 175

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 199
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 176

    (16) TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .

    ;               reduce using rule 16 (TIPO_PRIME -> , ID add_id add_current_type TIPO_PRIME .)


state 177

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] . ;

    ;               shift and go to state 200


state 178

    (72) B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    DO              reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 72 (B_EXP_PRIME -> > add_operator B_EXP aritmetics_operation .)


state 179

    (73) B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    DO              reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 73 (B_EXP_PRIME -> < add_operator B_EXP aritmetics_operation .)


state 180

    (74) B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    DO              reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 74 (B_EXP_PRIME -> DIFFERENT add_operator B_EXP aritmetics_operation .)


state 181

    (75) B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .

    AND             reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    OR              reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ]               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    )               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ;               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TRUE            reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    FALSE           reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    (               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    *               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    /               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ID              reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    I_CONST         reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    F_CONST         reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    C_CONST         reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    ,               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    TO              reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    DO              reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)
    }               reduce using rule 75 (B_EXP_PRIME -> EQUAL add_operator B_EXP aritmetics_operation .)


state 182

    (78) EXP_PRIME -> + add_operator TERM EXP_PRIME . aritmetics_operation
    (62) aritmetics_operation -> .

    >               reduce using rule 62 (aritmetics_operation -> .)
    <               reduce using rule 62 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 62 (aritmetics_operation -> .)
    EQUAL           reduce using rule 62 (aritmetics_operation -> .)
    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 201

state 183

    (79) EXP_PRIME -> - add_operator TERM EXP_PRIME . aritmetics_operation
    (62) aritmetics_operation -> .

    >               reduce using rule 62 (aritmetics_operation -> .)
    <               reduce using rule 62 (aritmetics_operation -> .)
    DIFFERENT       reduce using rule 62 (aritmetics_operation -> .)
    EQUAL           reduce using rule 62 (aritmetics_operation -> .)
    AND             reduce using rule 62 (aritmetics_operation -> .)
    OR              reduce using rule 62 (aritmetics_operation -> .)
    ]               reduce using rule 62 (aritmetics_operation -> .)
    )               reduce using rule 62 (aritmetics_operation -> .)
    ;               reduce using rule 62 (aritmetics_operation -> .)
    TRUE            reduce using rule 62 (aritmetics_operation -> .)
    FALSE           reduce using rule 62 (aritmetics_operation -> .)
    (               reduce using rule 62 (aritmetics_operation -> .)
    *               reduce using rule 62 (aritmetics_operation -> .)
    /               reduce using rule 62 (aritmetics_operation -> .)
    ID              reduce using rule 62 (aritmetics_operation -> .)
    I_CONST         reduce using rule 62 (aritmetics_operation -> .)
    F_CONST         reduce using rule 62 (aritmetics_operation -> .)
    C_CONST         reduce using rule 62 (aritmetics_operation -> .)
    ,               reduce using rule 62 (aritmetics_operation -> .)
    TO              reduce using rule 62 (aritmetics_operation -> .)
    DO              reduce using rule 62 (aritmetics_operation -> .)
    }               reduce using rule 62 (aritmetics_operation -> .)

    aritmetics_operation           shift and go to state 202

state 184

    (82) TERM_PRIME -> * add_operator FACTOR aritmetics_operation . TERM_PRIME
    (82) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (83) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (84) TERM_PRIME -> . empty
    (93) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 93 (empty -> .)
    -               reduce using rule 93 (empty -> .)
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

  ! *               [ reduce using rule 93 (empty -> .) ]
  ! /               [ reduce using rule 93 (empty -> .) ]

    TERM_PRIME                     shift and go to state 203
    empty                          shift and go to state 93

state 185

    (83) TERM_PRIME -> / add_operator FACTOR aritmetics_operation . TERM_PRIME
    (82) TERM_PRIME -> . * add_operator FACTOR aritmetics_operation TERM_PRIME
    (83) TERM_PRIME -> . / add_operator FACTOR aritmetics_operation TERM_PRIME
    (84) TERM_PRIME -> . empty
    (93) empty -> .

  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    *               shift and go to state 91
    /               shift and go to state 92
    +               reduce using rule 93 (empty -> .)
    -               reduce using rule 93 (empty -> .)
    >               reduce using rule 93 (empty -> .)
    <               reduce using rule 93 (empty -> .)
    DIFFERENT       reduce using rule 93 (empty -> .)
    EQUAL           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    ]               reduce using rule 93 (empty -> .)
    )               reduce using rule 93 (empty -> .)
    ;               reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    ,               reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)

  ! *               [ reduce using rule 93 (empty -> .) ]
  ! /               [ reduce using rule 93 (empty -> .) ]

    TERM_PRIME                     shift and go to state 204
    empty                          shift and go to state 93

state 186

    (47) FUNC_CALL_PRIME -> EXPRESSION . FUNC_CALL_PRIME
    (47) FUNC_CALL_PRIME -> . EXPRESSION FUNC_CALL_PRIME
    (48) FUNC_CALL_PRIME -> . empty
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (93) empty -> .
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    )               reduce using rule 93 (empty -> .)
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 186
    FUNC_CALL_PRIME                shift and go to state 205
    empty                          shift and go to state 188
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 187

    (46) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME . )

    )               shift and go to state 206


state 188

    (48) FUNC_CALL_PRIME -> empty .

    )               reduce using rule 48 (FUNC_CALL_PRIME -> empty .)


state 189

    (61) DESCRIBE_STMT -> ID . DESCRIBE ( . )

    )               shift and go to state 207


state 190

    (20) VARIABLE -> ID [ EXPRESSION ] .

    =               reduce using rule 20 (VARIABLE -> ID [ EXPRESSION ] .)


state 191

    (45) ASSIGNATION -> VARIABLE = add_operator EXPRESSION . ; add_assignation_quad

    ;               shift and go to state 208


state 192

    (51) WRITE -> PRINT add_operator ( EXPRESSION . print_quad WRITE_PRIME )
    (49) print_quad -> .

    ,               reduce using rule 49 (print_quad -> .)
    )               reduce using rule 49 (print_quad -> .)

    print_quad                     shift and go to state 209

state 193

    (52) WRITE -> PRINT add_operator ( TITLE . WRITE_PRIME )
    (53) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (55) WRITE_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 211
    )               reduce using rule 93 (empty -> .)

    WRITE_PRIME                    shift and go to state 210
    empty                          shift and go to state 212

state 194

    (56) CONDITION -> IF ( EXPRESSION ) . { BLOCK } ELSE_STMT

    {               shift and go to state 213


state 195

    (59) WHILE_STMT -> WHILE ( EXPRESSION ) . { BLOCK }

    {               shift and go to state 214


state 196

    (60) FOR_STMT -> FOR ID = EXPRESSION . TO EXPRESSION DO { BLOCK }

    TO              shift and go to state 215


state 197

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID . PARAM_PRIME
    (30) PARAM_PRIME -> . , TIPO_SIMPLE ID PARAM_PRIME
    (31) PARAM_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 149
    )               reduce using rule 93 (empty -> .)

    PARAM_PRIME                    shift and go to state 216
    empty                          shift and go to state 150

state 198

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK . RETURN VAR_CT }

    RETURN          shift and go to state 217


state 199

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK . }

    }               shift and go to state 218


state 200

    (15) VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .

    VAR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FUNC            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    VOID            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    ID              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    PRINT           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    IF              reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    WHILE           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FOR             reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    TRUE            reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    FALSE           reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    (               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    *               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    /               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    I_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    F_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    C_CONST         reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    }               reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)
    RETURN          reduce using rule 15 (VARS -> VAR TIPO_SIMPLE ID [ EXPRESSION ] [ EXPRESSION ] ; .)


state 201

    (78) EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    DO              reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 78 (EXP_PRIME -> + add_operator TERM EXP_PRIME aritmetics_operation .)


state 202

    (79) EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .

    >               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    <               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DIFFERENT       reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    EQUAL           reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    AND             reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    OR              reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ]               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    )               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ;               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TRUE            reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    FALSE           reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    (               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    *               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    /               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ID              reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    I_CONST         reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    F_CONST         reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    C_CONST         reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    ,               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    TO              reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    DO              reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)
    }               reduce using rule 79 (EXP_PRIME -> - add_operator TERM EXP_PRIME aritmetics_operation .)


state 203

    (82) TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DO              reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 82 (TERM_PRIME -> * add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 204

    (83) TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .

    +               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    -               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    >               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    <               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DIFFERENT       reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    EQUAL           reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    AND             reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    OR              reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ]               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    )               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ;               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TRUE            reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    FALSE           reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    (               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    *               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    /               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ID              reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    I_CONST         reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    F_CONST         reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    C_CONST         reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    ,               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    TO              reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    DO              reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)
    }               reduce using rule 83 (TERM_PRIME -> / add_operator FACTOR aritmetics_operation TERM_PRIME .)


state 205

    (47) FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .

    )               reduce using rule 47 (FUNC_CALL_PRIME -> EXPRESSION FUNC_CALL_PRIME .)


state 206

    (46) FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .

    ID              reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    PRINT           reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    IF              reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    WHILE           reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FOR             reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    TRUE            reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    FALSE           reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    (               reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    *               reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    /               reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    I_CONST         reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    F_CONST         reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    C_CONST         reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    }               reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)
    RETURN          reduce using rule 46 (FUNC_CALL -> ID ( EXPRESSION FUNC_CALL_PRIME ) .)


state 207

    (61) DESCRIBE_STMT -> ID . DESCRIBE ( ) .

    ID              reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    PRINT           reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    IF              reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    WHILE           reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FOR             reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    TRUE            reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    FALSE           reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    (               reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    *               reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    /               reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    I_CONST         reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    F_CONST         reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    C_CONST         reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    }               reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)
    RETURN          reduce using rule 61 (DESCRIBE_STMT -> ID . DESCRIBE ( ) .)


state 208

    (45) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; . add_assignation_quad
    (44) add_assignation_quad -> .

    ID              reduce using rule 44 (add_assignation_quad -> .)
    PRINT           reduce using rule 44 (add_assignation_quad -> .)
    IF              reduce using rule 44 (add_assignation_quad -> .)
    WHILE           reduce using rule 44 (add_assignation_quad -> .)
    FOR             reduce using rule 44 (add_assignation_quad -> .)
    TRUE            reduce using rule 44 (add_assignation_quad -> .)
    FALSE           reduce using rule 44 (add_assignation_quad -> .)
    (               reduce using rule 44 (add_assignation_quad -> .)
    *               reduce using rule 44 (add_assignation_quad -> .)
    /               reduce using rule 44 (add_assignation_quad -> .)
    I_CONST         reduce using rule 44 (add_assignation_quad -> .)
    F_CONST         reduce using rule 44 (add_assignation_quad -> .)
    C_CONST         reduce using rule 44 (add_assignation_quad -> .)
    }               reduce using rule 44 (add_assignation_quad -> .)
    RETURN          reduce using rule 44 (add_assignation_quad -> .)

    add_assignation_quad           shift and go to state 219

state 209

    (51) WRITE -> PRINT add_operator ( EXPRESSION print_quad . WRITE_PRIME )
    (53) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (55) WRITE_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 211
    )               reduce using rule 93 (empty -> .)

    WRITE_PRIME                    shift and go to state 220
    empty                          shift and go to state 212

state 210

    (52) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME . )

    )               shift and go to state 221


state 211

    (53) WRITE_PRIME -> , . add_print_operator EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> , . add_print_operator TITLE print_quad WRITE_PRIME
    (50) add_print_operator -> .

    TITLE           reduce using rule 50 (add_print_operator -> .)
    TRUE            reduce using rule 50 (add_print_operator -> .)
    FALSE           reduce using rule 50 (add_print_operator -> .)
    (               reduce using rule 50 (add_print_operator -> .)
    *               reduce using rule 50 (add_print_operator -> .)
    /               reduce using rule 50 (add_print_operator -> .)
    ID              reduce using rule 50 (add_print_operator -> .)
    I_CONST         reduce using rule 50 (add_print_operator -> .)
    F_CONST         reduce using rule 50 (add_print_operator -> .)
    C_CONST         reduce using rule 50 (add_print_operator -> .)

    add_print_operator             shift and go to state 222

state 212

    (55) WRITE_PRIME -> empty .

    )               reduce using rule 55 (WRITE_PRIME -> empty .)


state 213

    (56) CONDITION -> IF ( EXPRESSION ) { . BLOCK } ELSE_STMT
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 223
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 214

    (59) WHILE_STMT -> WHILE ( EXPRESSION ) { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 224
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 215

    (60) FOR_STMT -> FOR ID = EXPRESSION TO . EXPRESSION DO { BLOCK }
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 225
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 216

    (30) PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .

    )               reduce using rule 30 (PARAM_PRIME -> , TIPO_SIMPLE ID PARAM_PRIME .)


state 217

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . EXPRESSION }
    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN . VAR_CT }
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT

    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60

    EXPRESSION                     shift and go to state 226
    VAR_CT                         shift and go to state 227
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56

state 218

    (27) FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .

    FUNC            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)
    VOID            reduce using rule 27 (FUNCTION -> FUNC VOID ID ( PARAM ) { VARS_PRIME BLOCK } .)


state 219

    (45) ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .

    ID              reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    PRINT           reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    IF              reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    WHILE           reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FOR             reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    TRUE            reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    FALSE           reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    (               reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    *               reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    /               reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    I_CONST         reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    F_CONST         reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    C_CONST         reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    }               reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)
    RETURN          reduce using rule 45 (ASSIGNATION -> VARIABLE = add_operator EXPRESSION ; add_assignation_quad .)


state 220

    (51) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME . )

    )               shift and go to state 228


state 221

    (52) WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .

    ID              reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    PRINT           reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    IF              reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    WHILE           reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    FOR             reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    TRUE            reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    FALSE           reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    (               reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    *               reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    /               reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    I_CONST         reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    F_CONST         reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    C_CONST         reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    }               reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)
    RETURN          reduce using rule 52 (WRITE -> PRINT add_operator ( TITLE WRITE_PRIME ) .)


state 222

    (53) WRITE_PRIME -> , add_print_operator . EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> , add_print_operator . TITLE print_quad WRITE_PRIME
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    TITLE           shift and go to state 230
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    ID              shift and go to state 48
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 229
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 223

    (56) CONDITION -> IF ( EXPRESSION ) { BLOCK . } ELSE_STMT

    }               shift and go to state 231


state 224

    (59) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK . }

    }               shift and go to state 232


state 225

    (60) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION . DO { BLOCK }

    DO              shift and go to state 233


state 226

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION . }

    }               shift and go to state 234


state 227

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT . }
    (88) FACTOR -> VAR_CT .

  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 235
    *               reduce using rule 88 (FACTOR -> VAR_CT .)
    /               reduce using rule 88 (FACTOR -> VAR_CT .)
    +               reduce using rule 88 (FACTOR -> VAR_CT .)
    -               reduce using rule 88 (FACTOR -> VAR_CT .)
    >               reduce using rule 88 (FACTOR -> VAR_CT .)
    <               reduce using rule 88 (FACTOR -> VAR_CT .)
    DIFFERENT       reduce using rule 88 (FACTOR -> VAR_CT .)
    EQUAL           reduce using rule 88 (FACTOR -> VAR_CT .)
    AND             reduce using rule 88 (FACTOR -> VAR_CT .)
    OR              reduce using rule 88 (FACTOR -> VAR_CT .)

  ! }               [ reduce using rule 88 (FACTOR -> VAR_CT .) ]


state 228

    (51) WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .

    ID              reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    PRINT           reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    IF              reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    WHILE           reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    FOR             reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    TRUE            reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    FALSE           reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    (               reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    *               reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    /               reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    I_CONST         reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    F_CONST         reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    C_CONST         reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    }               reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)
    RETURN          reduce using rule 51 (WRITE -> PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME ) .)


state 229

    (53) WRITE_PRIME -> , add_print_operator EXPRESSION . print_quad WRITE_PRIME
    (49) print_quad -> .

    ,               reduce using rule 49 (print_quad -> .)
    )               reduce using rule 49 (print_quad -> .)

    print_quad                     shift and go to state 236

state 230

    (54) WRITE_PRIME -> , add_print_operator TITLE . print_quad WRITE_PRIME
    (49) print_quad -> .

    ,               reduce using rule 49 (print_quad -> .)
    )               reduce using rule 49 (print_quad -> .)

    print_quad                     shift and go to state 237

state 231

    (56) CONDITION -> IF ( EXPRESSION ) { BLOCK } . ELSE_STMT
    (57) ELSE_STMT -> . ELSE { BLOCK }
    (58) ELSE_STMT -> . empty
    (93) empty -> .

    ELSE            shift and go to state 239
    ID              reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    (               reduce using rule 93 (empty -> .)
    *               reduce using rule 93 (empty -> .)
    /               reduce using rule 93 (empty -> .)
    I_CONST         reduce using rule 93 (empty -> .)
    F_CONST         reduce using rule 93 (empty -> .)
    C_CONST         reduce using rule 93 (empty -> .)
    }               reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)

    ELSE_STMT                      shift and go to state 238
    empty                          shift and go to state 240

state 232

    (59) WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .

    ID              reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    PRINT           reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    IF              reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    WHILE           reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    FOR             reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    TRUE            reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    FALSE           reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    (               reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    *               reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    /               reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    I_CONST         reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    F_CONST         reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    C_CONST         reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    }               reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)
    RETURN          reduce using rule 59 (WHILE_STMT -> WHILE ( EXPRESSION ) { BLOCK } .)


state 233

    (60) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO . { BLOCK }

    {               shift and go to state 241


state 234

    (25) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .

    FUNC            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)
    VOID            reduce using rule 25 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN EXPRESSION } .)


state 235

    (26) FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .

    FUNC            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)
    VOID            reduce using rule 26 (FUNCTION -> FUNC TIPO_SIMPLE ID ( PARAM ) { VARS_PRIME BLOCK RETURN VAR_CT } .)


state 236

    (53) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad . WRITE_PRIME
    (53) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (55) WRITE_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 211
    )               reduce using rule 93 (empty -> .)

    WRITE_PRIME                    shift and go to state 242
    empty                          shift and go to state 212

state 237

    (54) WRITE_PRIME -> , add_print_operator TITLE print_quad . WRITE_PRIME
    (53) WRITE_PRIME -> . , add_print_operator EXPRESSION print_quad WRITE_PRIME
    (54) WRITE_PRIME -> . , add_print_operator TITLE print_quad WRITE_PRIME
    (55) WRITE_PRIME -> . empty
    (93) empty -> .

    ,               shift and go to state 211
    )               reduce using rule 93 (empty -> .)

    WRITE_PRIME                    shift and go to state 243
    empty                          shift and go to state 212

state 238

    (56) CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .

    ID              reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    PRINT           reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    IF              reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    WHILE           reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    FOR             reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    TRUE            reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    FALSE           reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    (               reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    *               reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    /               reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    I_CONST         reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    F_CONST         reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    C_CONST         reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    }               reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)
    RETURN          reduce using rule 56 (CONDITION -> IF ( EXPRESSION ) { BLOCK } ELSE_STMT .)


state 239

    (57) ELSE_STMT -> ELSE . { BLOCK }

    {               shift and go to state 244


state 240

    (58) ELSE_STMT -> empty .

    ID              reduce using rule 58 (ELSE_STMT -> empty .)
    PRINT           reduce using rule 58 (ELSE_STMT -> empty .)
    IF              reduce using rule 58 (ELSE_STMT -> empty .)
    WHILE           reduce using rule 58 (ELSE_STMT -> empty .)
    FOR             reduce using rule 58 (ELSE_STMT -> empty .)
    TRUE            reduce using rule 58 (ELSE_STMT -> empty .)
    FALSE           reduce using rule 58 (ELSE_STMT -> empty .)
    (               reduce using rule 58 (ELSE_STMT -> empty .)
    *               reduce using rule 58 (ELSE_STMT -> empty .)
    /               reduce using rule 58 (ELSE_STMT -> empty .)
    I_CONST         reduce using rule 58 (ELSE_STMT -> empty .)
    F_CONST         reduce using rule 58 (ELSE_STMT -> empty .)
    C_CONST         reduce using rule 58 (ELSE_STMT -> empty .)
    }               reduce using rule 58 (ELSE_STMT -> empty .)
    RETURN          reduce using rule 58 (ELSE_STMT -> empty .)


state 241

    (60) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    EXPRESSION                     shift and go to state 106
    BLOCK                          shift and go to state 245
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 242

    (53) WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .

    )               reduce using rule 53 (WRITE_PRIME -> , add_print_operator EXPRESSION print_quad WRITE_PRIME .)


state 243

    (54) WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .

    )               reduce using rule 54 (WRITE_PRIME -> , add_print_operator TITLE print_quad WRITE_PRIME .)


state 244

    (57) ELSE_STMT -> ELSE { . BLOCK }
    (32) BLOCK -> . STATEMENT BLOCK
    (33) BLOCK -> . empty
    (34) STATEMENT -> . ASSIGNATION
    (35) STATEMENT -> . FUNC_CALL
    (36) STATEMENT -> . EXPRESSION ;
    (37) STATEMENT -> . WRITE
    (38) STATEMENT -> . CONDITION
    (39) STATEMENT -> . WHILE_STMT
    (40) STATEMENT -> . FOR_STMT
    (41) STATEMENT -> . DESCRIBE_STMT
    (93) empty -> .
    (45) ASSIGNATION -> . VARIABLE = add_operator EXPRESSION ; add_assignation_quad
    (46) FUNC_CALL -> . ID ( EXPRESSION FUNC_CALL_PRIME )
    (63) EXPRESSION -> . AND_EXP EXPRESSION_PRIME
    (51) WRITE -> . PRINT add_operator ( EXPRESSION print_quad WRITE_PRIME )
    (52) WRITE -> . PRINT add_operator ( TITLE WRITE_PRIME )
    (56) CONDITION -> . IF ( EXPRESSION ) { BLOCK } ELSE_STMT
    (59) WHILE_STMT -> . WHILE ( EXPRESSION ) { BLOCK }
    (60) FOR_STMT -> . FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK }
    (61) DESCRIBE_STMT -> . ID . DESCRIBE ( )
    (19) VARIABLE -> . ID get_variable
    (20) VARIABLE -> . ID [ EXPRESSION ]
    (66) AND_EXP -> . B_EXP AND_EXP_PRIME
    (69) B_EXP -> . TRUE
    (70) B_EXP -> . FALSE
    (71) B_EXP -> . EXP B_EXP_PRIME
    (77) EXP -> . TERM EXP_PRIME
    (81) TERM -> . FACTOR TERM_PRIME
    (85) FACTOR -> . ( EXPRESSION )
    (86) FACTOR -> . * VAR_CT
    (87) FACTOR -> . / VAR_CT
    (88) FACTOR -> . VAR_CT
    (89) VAR_CT -> . ID add_operand
    (90) VAR_CT -> . I_CONST add_operand
    (91) VAR_CT -> . F_CONST add_operand
    (92) VAR_CT -> . C_CONST add_operand

    }               reduce using rule 93 (empty -> .)
    ID              shift and go to state 100
    PRINT           shift and go to state 113
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    (               shift and go to state 57
    *               shift and go to state 58
    /               shift and go to state 60
    I_CONST         shift and go to state 61
    F_CONST         shift and go to state 62
    C_CONST         shift and go to state 63

    BLOCK                          shift and go to state 246
    STATEMENT                      shift and go to state 102
    empty                          shift and go to state 103
    ASSIGNATION                    shift and go to state 104
    FUNC_CALL                      shift and go to state 105
    EXPRESSION                     shift and go to state 106
    WRITE                          shift and go to state 107
    CONDITION                      shift and go to state 108
    WHILE_STMT                     shift and go to state 109
    FOR_STMT                       shift and go to state 110
    DESCRIBE_STMT                  shift and go to state 111
    VARIABLE                       shift and go to state 112
    AND_EXP                        shift and go to state 50
    B_EXP                          shift and go to state 51
    EXP                            shift and go to state 54
    TERM                           shift and go to state 55
    FACTOR                         shift and go to state 56
    VAR_CT                         shift and go to state 59

state 245

    (60) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK . }

    }               shift and go to state 247


state 246

    (57) ELSE_STMT -> ELSE { BLOCK . }

    }               shift and go to state 248


state 247

    (60) FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .

    ID              reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    PRINT           reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    IF              reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    WHILE           reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    FOR             reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    TRUE            reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    FALSE           reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    (               reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    *               reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    /               reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    I_CONST         reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    F_CONST         reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    C_CONST         reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    }               reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)
    RETURN          reduce using rule 60 (FOR_STMT -> FOR ID = EXPRESSION TO EXPRESSION DO { BLOCK } .)


state 248

    (57) ELSE_STMT -> ELSE { BLOCK } .

    ID              reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    PRINT           reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    IF              reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    WHILE           reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    FOR             reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    TRUE            reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    FALSE           reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    (               reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    *               reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    /               reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    I_CONST         reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    F_CONST         reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    C_CONST         reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    }               reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)
    RETURN          reduce using rule 57 (ELSE_STMT -> ELSE { BLOCK } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for / in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 184 resolved as shift
WARNING: shift/reduce conflict for / in state 184 resolved as shift
WARNING: shift/reduce conflict for * in state 185 resolved as shift
WARNING: shift/reduce conflict for / in state 185 resolved as shift
WARNING: shift/reduce conflict for } in state 227 resolved as shift
