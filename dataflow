#!/usr/bin/env python
from sys import argv
from parser import dataflow_parser, semantics
from collections import deque
from Memories.runtime_memory import Runtime_Memory
from Memories.virtual_memory import DATATYPE_SIZE

def check_if_global_variable(virtual_address: int):
    """
    This code defines a function that checks if a given virtual memory address corresponds to a global variable. 
    It categorizes the memory address based on the datatype size and returns True if the memory address falls into one of the global variable categories, 
    or False otherwise.

    """
    memory_categorizer = int(virtual_address / DATATYPE_SIZE)
    # INT
    if memory_categorizer == 0:
        return True
    if memory_categorizer == 1:
        return True
    # FLOAT
    if memory_categorizer == 4:
        return True
    if memory_categorizer == 5:
        return True
    # CHAR
    if memory_categorizer == 8:
        return True
    if memory_categorizer == 9:
        return True
    # BOOL
    if memory_categorizer == 12:
        return True
    if memory_categorizer == 13:
        return True
    
    return False

def virtual_machine(resources:str, constant_dict:str):

    """

    Function: virtual_machine
    
    This function represents the virtual machine that executes a series of quadruples generated by a dataflow program. It performs the following operations:

    Initializes the global memory and a deque of memories.
    Initializes a deque for storing program counters.
    Appends the global memory to the deque of memories.
    Retrieves the quadruples from the semantics module.
    Enters a loop to process each quadruple.
    Executes the corresponding operation based on the opcode of the current quadruple.
    Updates the instruction pointer (ip) accordingly.
    Terminates the loop when the 'endprogram' quadruple is encountered.
    """
    global_memory = Runtime_Memory(resources, constant_dict)
    memories = deque()
    migajita_de_pan = deque()
    memories.append(global_memory)
    quadruples = semantics.quadruples
    ip = 0
    local_memories = {}
    local_memories_counter = 1
    print('\nSTART OF DATAFLOW PROGRAM \n')

    while (True):
        current_quad = quadruples[ip]
        
        if current_quad.op_code == 'endprogram':
            break

        elif current_quad.op_code == '+':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand + right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '-':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand - right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '*':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand * right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '/':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand / right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '>':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand > right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '<=':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand <= right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)
        
        elif current_quad.op_code == '>=':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand >= right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '<':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand < next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand - right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '==':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand == right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '&&':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand and right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '||':
            if check_if_global_variable(current_quad.left_operand):
                current_memory = memories.popleft()
                left_operand = current_memory.return_content(current_quad.left_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                left_operand = current_memory.return_content(current_quad.left_operand)
                if left_operand is None:
                    next_current_memory = memories.pop()
                    left_operand = next_current_memory.return_content(current_quad.left_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.right_operand):
                current_memory = memories.popleft()
                right_operand = current_memory.return_content(current_quad.right_operand)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                right_operand = current_memory.return_content(current_quad.right_operand)
                if right_operand is None:
                    next_current_memory = memories.pop()
                    right_operand = next_current_memory.return_content(current_quad.right_operand)
                    memories.append(next_current_memory)
                memories.append(current_memory)
                
            current_memory = memories.pop()
            result = left_operand or right_operand
            current_memory.assign_content_value(current_quad.result, result)
            ip += 1
            memories.append(current_memory)

        elif current_quad.op_code == '=':
            if check_if_global_variable(current_quad.left_operand):
                global_memory = memories.popleft()
                result = global_memory.return_content(current_quad.left_operand)
                memories.appendleft(global_memory)
            else:
                current_memory = memories.pop()
                result = current_memory.return_content(current_quad.left_operand)
                memories.append(current_memory)
            if check_if_global_variable(current_quad.result):
                global_memory = memories.popleft()
                global_memory.assign_content(current_quad.result, result)
                memories.appendleft(global_memory)
            else:
                current_memory = memories.pop()
                current_memory.assign_content(current_quad.result, result)
                memories.append(current_memory)
            ip += 1

        elif current_quad.op_code == 'print':
            if check_if_global_variable(current_quad.result):
                current_memory = memories.popleft()
                result = current_memory.return_content(current_quad.result)
                memories.appendleft(current_memory)
            else:
                current_memory = memories.pop()
                result = current_memory.return_content(current_quad.result)
                memories.append(current_memory)
            print_content = result
            print(print_content)
            ip += 1

        elif current_quad.op_code == 'goto':
            ip = current_quad.result

        elif current_quad.op_code == 'gotof':
            current_memory = memories.pop()
            false_var = current_memory.return_content(current_quad.left_operand)
            memories.append(current_memory)
            if false_var == False:
                ip = current_quad.result
            else:
                ip += 1

        elif current_quad.op_code == 'gotot':
            current_memory = memories.pop()
            true_var = current_memory.return_content(current_quad.left_operand)
            memories.append(current_memory)
            if true_var:
                ip = current_quad.result
            else:
                ip += 1
        
        elif current_quad.op_code == 'era':
            local_memory = f"local_memory[{local_memories_counter}]"
            local_memories[local_memory] = Runtime_Memory(current_quad.result, constant_dict)
            local_memories_counter += 1
            memories.append(local_memories[local_memory])
            ip += 1

        elif current_quad.op_code == 'param':
            if check_if_global_variable(current_quad.left_operand):
                local_memory = memories.pop()
                global_memory = memories.popleft()
                local_memory.assign_content(current_quad.result, global_memory.return_content(current_quad.left_operand))
                memories.append(local_memory)
                memories.appendleft(global_memory)
            else:
                current_memory = memories.pop()
                current_memory.assign_content(current_quad.result, current_memory.return_content(current_quad.left_operand))
                memories.append(current_memory)
            ip += 1
        
        elif current_quad.op_code == 'gosub':
            migajita_de_pan.append(ip+1)
            ip = current_quad.result
        
        elif current_quad.op_code == 'return':
            local_memory = memories.pop()
            global_memory = memories.popleft()
            global_memory.assign_content(current_quad.result, local_memory.return_content(current_quad.left_operand))
            memories.append(current_memory)
            memories.appendleft(global_memory)
            ip += 1
        
        elif current_quad.op_code == 'endfunc':
            memories.pop() # Kill local memory
            ip = migajita_de_pan.pop()
        
        elif current_quad.op_code == 'ver':
            current_memory = memories.popleft()
            index = current_memory.return_content(current_quad.left_operand)
            lower_bound = current_quad.right_operand
            upper_bound = current_quad.result
            if index >= lower_bound and index <= upper_bound:
                ip += 1
            else:
                raise Exception(f'Index {index} out of bounds. Range should be {lower_bound} - {upper_bound}')
            memories.append(current_memory)
        
        elif current_quad.op_code == 'base_sum':
            current_memory = memories.pop()
            left_operand = current_memory.return_content(current_quad.left_operand)
            result = left_operand + current_quad.right_operand
            current_memory.assign_content_value(current_quad.result, result, memory_pointer= True)
            ip += 1
            memories.append(current_memory)
        


    print('\nEND OF DATAFLOW PROGRAM')


if __name__ == '__main__':
    """
    This code reads and processes a dataflow file (.df) specified as a command-line argument. It performs the following steps:

    Checks if the code is being executed as the main module.
    Validates the file extension, raising an exception if it is not '.df'.
    Opens the file and reads its contents.
    Parses the input string using the dataflow_parser module.
    Prints the values of various stacks and dictionaries used in the semantics module.
    Prints the quadruples generated by the semantics module.
    Calls the virtual_machine function with the final global memory and constant dictionary from the semantics module.
    """
    filename = argv[1]
    if filename[-3:] != ".df":
        raise Exception("Cannot read file without \'.df\' extension")
    else:
        file = open(filename)
        input_str = file.read()
        file.close()
        dataflow_parser.parse(input_str)
        virtual_machine(semantics.final_global_mem, semantics.final_global_constant_dict)